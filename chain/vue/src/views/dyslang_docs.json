{
  "ArithmeticError": {
    "docstring": "Base class for arithmetic errors.",
    "init_definition": "(self, *args)",
    "isclass": true
  },
  "AssertionError": {
    "docstring": "Assertion failed.",
    "init_definition": "(self, *args)",
    "isclass": true
  },
  "AttributeError": {
    "docstring": "Attribute not found.",
    "init_definition": "(self, *args, obj=None, name=None)",
    "isclass": true
  },
  "Exception": {
    "docstring": "Common base class for all non-exit exceptions.",
    "init_definition": "(self, *args)",
    "isclass": true
  },
  "FloatingPointError": {
    "docstring": "Floating point operation failed.",
    "init_definition": "(self, *args)",
    "isclass": true
  },
  "ImportError": {
    "docstring": "Import can't find module, or can't find name in module.",
    "init_definition": "(self, *args, name=None, path=None)",
    "isclass": true
  },
  "IndexError": {
    "docstring": "Sequence index out of range.",
    "init_definition": "(self, *args)",
    "isclass": true
  },
  "KeyError": {
    "docstring": "Mapping key not found.",
    "init_definition": "(self, *args)",
    "isclass": true
  },
  "LookupError": {
    "docstring": "Base class for lookup errors.",
    "init_definition": "(self, *args)",
    "isclass": true
  },
  "MemoryError": {
    "docstring": "Out of memory.",
    "init_definition": "(self, *args)",
    "isclass": true
  },
  "ModuleNotFoundError": {
    "docstring": "Module not found.",
    "init_definition": "(self, *args, name=None, path=None)",
    "isclass": true
  },
  "NameError": {
    "docstring": "Name not found globally.",
    "init_definition": "(self, *args, name=None)",
    "isclass": true
  },
  "NotImplementedError": {
    "docstring": "Method or function hasn't been implemented yet.",
    "init_definition": "(self, *args)",
    "isclass": true
  },
  "OverflowError": {
    "docstring": "Result too large to be represented.",
    "init_definition": "(self, *args)",
    "isclass": true
  },
  "PermissionError": {
    "docstring": "Not enough permissions.",
    "init_definition": "(self, *args, **keywords)",
    "isclass": true
  },
  "RecursionError": {
    "docstring": "Recursion limit exceeded.",
    "init_definition": "(self, *args)",
    "isclass": true
  },
  "SyntaxError": {
    "docstring": "Invalid syntax.",
    "init_definition": "(self, *args)",
    "isclass": true
  },
  "TypeError": {
    "docstring": "Inappropriate argument type.",
    "init_definition": "(self, *args)",
    "isclass": true
  },
  "UnboundLocalError": {
    "docstring": "Local name referenced but not bound to a value.",
    "init_definition": "(self, *args, name=None)",
    "isclass": true
  },
  "UnicodeDecodeError": {
    "docstring": "Unicode decoding error.",
    "init_definition": "(self, encoding, object, start, end, reason)",
    "isclass": true
  },
  "UnicodeEncodeError": {
    "docstring": "Unicode encoding error.",
    "init_definition": "(self, encoding, object, start, end, reason)",
    "isclass": true
  },
  "UnicodeError": {
    "docstring": "Unicode related error.",
    "init_definition": "(self, *args)",
    "isclass": true
  },
  "UnicodeTranslateError": {
    "docstring": "Unicode translation error.",
    "init_definition": "(self, object, start, end, reason)",
    "isclass": true
  },
  "ValueError": {
    "docstring": "Inappropriate argument value (of correct type).",
    "init_definition": "(self, *args)",
    "isclass": true
  },
  "ZeroDivisionError": {
    "docstring": "Second argument to a division or modulo operation was zero.",
    "init_definition": "(self, *args)",
    "isclass": true
  },
  "abs": {
    "definition": "(val)",
    "docstring": "abs(number) -> number\n\nReturn the absolute value of the argument."
  },
  "all": {
    "definition": "(seq)",
    "docstring": "all(iterable) -> bool\n\nReturn True if bool(x) is True for all values x in the iterable."
  },
  "any": {
    "definition": "(seq)",
    "docstring": "any(iterable) -> bool\n\nReturn True if bool(x) is True for any x in the iterable."
  },
  "base64.b64decode": {
    "definition": "(s, altchars=None, validate=False)",
    "docstring": "Decode the Base64 encoded bytes-like object or ASCII string s.\n\nOptional altchars must be a bytes-like object or ASCII string of length 2\nwhich specifies the alternative alphabet used instead of the '+' and '/'\ncharacters.\n\nThe result is returned as a bytes object.  A binascii.Error is raised if\ns is incorrectly padded.\n\nIf validate is False (the default), characters that are neither in the\nnormal base-64 alphabet nor the alternative alphabet are discarded prior\nto the padding check.  If validate is True, these non-alphabet characters\nin the input result in a binascii.Error."
  },
  "base64.b64encode": {
    "definition": "(s, altchars=None)",
    "docstring": "Encode the bytes-like object s using Base64 and return a bytes object.\n\nOptional altchars should be a byte string of length 2 which specifies an\nalternative alphabet for the '+' and '/' characters.  This allows an\napplication to e.g. generate url or filesystem safe Base64 strings."
  },
  "base64.decodebytes": {
    "definition": "(s)",
    "docstring": "Decode a bytestring of base-64 data into a bytes object."
  },
  "base64.encodebytes": {
    "definition": "(s)",
    "docstring": "Encode a bytestring into a bytes object containing multiple lines\nof base-64 data."
  },
  "base64.urlsafe_b64decode": {
    "definition": "(s)",
    "docstring": "Decode bytes using the URL- and filesystem-safe Base64 alphabet.\n\nArgument s is a bytes-like object or ASCII string to decode.  The result\nis returned as a bytes object.  A binascii.Error is raised if the input\nis incorrectly padded.  Characters that are not in the URL-safe base-64\nalphabet, and are not a plus '+' or slash '/', are discarded prior to the\npadding check.\n\nThe alphabet uses '-' instead of '+' and '_' instead of '/'."
  },
  "base64.urlsafe_b64encode": {
    "definition": "(s)",
    "docstring": "Encode bytes using the URL- and filesystem-safe Base64 alphabet.\n\nArgument s is a bytes-like object to encode.  The result is returned as a\nbytes object.  The alphabet uses '-' instead of '+' and '_' instead of\n'/'."
  },
  "bool": {
    "docstring": "bool(x) -> bool\n\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.",
    "init_definition": "(obj, *args, **keywords)",
    "isclass": true
  },
  "datetime.date": {
    "docstring": "Concrete date type.\n\nConstructors:\n\n__new__()\nfromtimestamp()\ntoday()\nfromordinal()\n\nOperators:\n\n__repr__, __str__\n__eq__, __le__, __lt__, __ge__, __gt__, __hash__\n__add__, __radd__, __sub__ (add/radd only with timedelta arg)\n\nMethods:\n\ntimetuple()\ntoordinal()\nweekday()\nisoweekday(), isocalendar(), isoformat()\nctime()\nstrftime()\n\nProperties (readonly):\nyear, month, day",
    "init_definition": "(year, month=None, day=None)",
    "isclass": true
  },
  "datetime.datetime": {
    "docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\nThe year, month and day arguments are required. tzinfo may be None, or an\ninstance of a tzinfo subclass. The remaining arguments may be ints.",
    "init_definition": "(\n    year,\n    month=None,\n    day=None,\n    hour=0,\n    minute=0,\n    second=0,\n    microsecond=0,\n    tzinfo=None,\n    *,\n    fold=0,\n)",
    "isclass": true
  },
  "datetime.datetime.isoformat": {
    "definition": "(self, sep='T', timespec='auto')",
    "docstring": "Return the time formatted according to ISO.\n\nThe full format looks like 'YYYY-MM-DD HH:MM:SS.mmmmmm'.\nBy default, the fractional part is omitted if self.microsecond == 0.\n\nIf self.tzinfo is not None, the UTC offset is also attached, giving\ngiving a full format of 'YYYY-MM-DD HH:MM:SS.mmmmmm+HH:MM'.\n\nOptional argument sep specifies the separator between date and\ntime, default 'T'.\n\nThe optional argument timespec specifies the number of additional\nterms of the time to include. Valid options are 'auto', 'hours',\n'minutes', 'seconds', 'milliseconds' and 'microseconds'."
  },
  "datetime.datetime.now": {
    "definition": "(tz=None)",
    "docstring": "Construct a datetime from time.time() and optional time zone info."
  },
  "datetime.datetime.timestamp": {
    "definition": "(self)",
    "docstring": "Return POSIX timestamp as float"
  },
  "datetime.time": {
    "docstring": "Time with time zone.\n\nConstructors:\n\n__new__()\n\nOperators:\n\n__repr__, __str__\n__eq__, __le__, __lt__, __ge__, __gt__, __hash__\n\nMethods:\n\nstrftime()\nisoformat()\nutcoffset()\ntzname()\ndst()\n\nProperties (readonly):\nhour, minute, second, microsecond, tzinfo, fold",
    "init_definition": "(hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)",
    "isclass": true
  },
  "datetime.timedelta": {
    "docstring": "Represent the difference between two datetime objects.\n\nSupported operators:\n\n- add, subtract timedelta\n- unary plus, minus, abs\n- compare to timedelta\n- multiply, divide by int\n\nIn addition, datetime supports subtraction of two datetime objects\nreturning a timedelta, and addition or subtraction of a datetime\nand a timedelta giving a datetime.\n\nRepresentation: (days, seconds, microseconds).  Why?  Because I\nfelt like it.",
    "init_definition": "(\n    days=0,\n    seconds=0,\n    microseconds=0,\n    milliseconds=0,\n    minutes=0,\n    hours=0,\n    weeks=0,\n)",
    "isclass": true
  },
  "datetime.timezone": {
    "docstring": "Abstract base class for time zone info classes.\n\nSubclasses must override the name(), utcoffset() and dst() methods.",
    "init_definition": "(offset, name=<object object at 0x234567>)",
    "isclass": true
  },
  "datetime.tzinfo": {
    "docstring": "Abstract base class for time zone info classes.\n\nSubclasses must override the name(), utcoffset() and dst() methods.",
    "init_definition": "(*args, **kwds)",
    "isclass": true
  },
  "decimal.Decimal": {
    "docstring": "Floating point class for decimal arithmetic.",
    "init_definition": "(value='0', context=None)",
    "isclass": true
  },
  "dict": {
    "docstring": "dict() -> new empty dictionary.\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs.\ndict(seq) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in seq:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)",
    "init_definition": "(self, *args, **keywords)",
    "isclass": true
  },
  "dict.clear": {
    "definition": "(self)",
    "docstring": "D.clear() -> None.  Remove all items from D."
  },
  "dict.copy": {
    "definition": "(self)",
    "docstring": "D.copy() -> a shallow copy of D"
  },
  "dict.fromkeys": {
    "definition": "(iterable, value=<no value>)",
    "docstring": "<no docstring>"
  },
  "dict.get": {
    "definition": "(self, key, default=None)",
    "docstring": "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None."
  },
  "dict.items": {
    "definition": "(self)",
    "docstring": "D.items() -> a set-like object providing a view on D's items"
  },
  "dict.keys": {
    "definition": "(self)",
    "docstring": "D.keys() -> a set-like object providing a view on D's keys"
  },
  "dict.pop": {
    "definition": "(self, key, default=<no value>)",
    "docstring": "D.pop(k[,d]) -> v, remove specified key and return the\n        corresponding value\nIf key is not found, d is returned if given,\n        otherwise KeyError is raised\n        "
  },
  "dict.popitem": {
    "definition": "(self)",
    "docstring": "D.popitem() -> (k, v), remove and return some (key, value) pair as\n        a\n2-tuple; but raise KeyError if D is empty"
  },
  "dict.setdefault": {
    "definition": "(self, key, default=None)",
    "docstring": "D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D"
  },
  "dict.update": {
    "definition": "(self, *args, **keywords)",
    "docstring": "D.update(E, **F) -> None.  Update D from E and F: for k in E: D[k]\n        = E[k]\n(if E has keys else: for (k, v) in E: D[k] = v) then: for k in\n        F: D[k] = F[k]"
  },
  "dict.values": {
    "definition": "(self)",
    "docstring": "D.values() -> an object providing a view on D's values"
  },
  "dys._chain": {
    "definition": "(method, **params)",
    "docstring": "The main way to interact with the chain from a script.\n\n:param method: the command to call on the chain, see TxBuilder for a list of possible commands\n`**kwargs` will depend on the command being called\n\n:returns: the response of the command or error"
  },
  "dys.get_block_info": {
    "definition": "() -> dict",
    "docstring": "Returns a dictionary of the current block info"
  },
  "dys.get_caller": {
    "definition": "() -> str",
    "docstring": "Returns the address of the caller of this script."
  },
  "dys.get_coins_sent": {
    "definition": "()",
    "docstring": "Returns the coins sent to this function.\nThis is not the gas or gas fees."
  },
  "dys.get_gas_consumed": {
    "definition": "()",
    "docstring": "The total amount of gas consumed so far."
  },
  "dys.get_gas_limit": {
    "definition": "()",
    "docstring": "The maximum amount of gas that can be used in this query or transaction"
  },
  "dys.get_script_address": {
    "definition": "() -> str",
    "docstring": "Returns the address of this current script."
  },
  "dys.rpc": {
    "definition": "(method, **params)",
    "docstring": "Depricated\nsee: dyson._chain"
  },
  "enumerate": {
    "docstring": "<no docstring>",
    "init_definition": "(obj, *args, **keywords)",
    "isclass": true
  },
  "float": {
    "docstring": "float(x) -> floating point number\n\nConvert a string or number to a floating point number, if possible.",
    "init_definition": "(obj, *args, **keywords)",
    "isclass": true
  },
  "hashlib.sha1": {
    "definition": "(string=b'', usedforsecurity=True)",
    "docstring": "<no docstring>"
  },
  "hashlib.sha256": {
    "definition": "(string=b'', usedforsecurity=True)",
    "docstring": "<no docstring>"
  },
  "hex": {
    "definition": "(x)",
    "docstring": "Return the hexadecimal representation of an integer.\n\n>>> hex(12648430)\n'0xc0ffee'"
  },
  "html.escape": {
    "definition": "(s, quote=True)",
    "docstring": "Replace special characters \"&\", \"<\" and \">\" to HTML-safe sequences.\nIf the optional flag quote is true (the default), the quotation mark\ncharacters, both double quote (\") and single quote (') characters are also\ntranslated."
  },
  "html.unescape": {
    "definition": "(s)",
    "docstring": "Convert all named and numeric character references (e.g. &gt;, &#62;,\n&x3e;) in the string s to the corresponding unicode characters.\nThis function uses the rules defined by the HTML 5 standard\nfor both valid and invalid character references, and the list of\nHTML 5 named character references defined in html.entities.html5."
  },
  "int": {
    "docstring": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
    "init_definition": "(obj, *args, **keywords)",
    "isclass": true
  },
  "io.BytesIO": {
    "docstring": "Base class for buffered IO objects.\n\nThe main difference with RawIOBase is that the read() method\nsupports omitting the size argument, and does not have a default\nimplementation that defers to readinto().\n\nIn addition, read(), readinto() and write() may raise\nBlockingIOError if the underlying raw stream is in non-blocking\nmode and not ready; unlike their raw counterparts, they will never\nreturn None.\n\nA typical implementation should not inherit from a RawIOBase\nimplementation, but wrap one.",
    "init_definition": "(self, initial_bytes=<no value>)",
    "isclass": true
  },
  "io.StringIO": {
    "docstring": "<no docstring>",
    "init_definition": "(self, initvalue=<no value>, newline=<no value>)",
    "isclass": true
  },
  "isinstance": {
    "definition": "(obj, klass_or_tuple)",
    "docstring": "Check whether an object is an instance of a class (or of a subclass\nthereof).  When using a tuple as the second argument, check whether 'obj'\nis an instance of any of the classes listed in the tuple."
  },
  "issubclass": {
    "definition": "(cls, klass_or_tuple)",
    "docstring": "Check whether a class 'cls' is a subclass (i.e., a derived class) of\nanother class.  When using a tuple as the second argument, check whether\n'cls' is a subclass of any of the classes listed in the tuple."
  },
  "iter": {
    "definition": "(collection_or_callable, sentinel=<no value>)",
    "docstring": "iter(collection) -> iterator over the elements of the collection.\n\niter(callable, sentinel) -> iterator calling callable() until it returns\n                            the sentinel."
  },
  "len": {
    "definition": "(obj)",
    "docstring": "len(object) -> integer\n\nReturn the number of items of a sequence or mapping."
  },
  "list": {
    "docstring": "list() -> new empty list\nlist(iterable) -> new list initialized from iterable's items",
    "init_definition": "(self, *args, **keywords)",
    "init_docstring": "Initialize self.  See help(type(self)) for accurate signature.",
    "isclass": true
  },
  "list.append": {
    "definition": "(self, item)",
    "docstring": "L.append(object) -> None -- append object to end"
  },
  "list.clear": {
    "definition": "(self)",
    "docstring": "L.clear() -> None -- remove all items from L"
  },
  "list.copy": {
    "definition": "(self)",
    "docstring": "L.copy() -> list -- a shallow copy of L"
  },
  "list.count": {
    "definition": "(self, value)",
    "docstring": "L.count(value) -> integer -- return number of occurrences of value"
  },
  "list.extend": {
    "definition": "(self, iterable)",
    "docstring": "L.extend(iterable) -- extend list by appending elements from the iterable"
  },
  "list.index": {
    "definition": "(self, value, start=0, stop=9223372036854775807)",
    "docstring": "L.index(value, [start, [stop]]) -> integer -- return first index of value.\nRaises ValueError if the value is not present."
  },
  "list.insert": {
    "definition": "(self, index, value)",
    "docstring": "L.insert(index, object) -- insert object before index"
  },
  "list.pop": {
    "definition": "(self, index=-1)",
    "docstring": "L.pop([index]) -> item -- remove and return item at index (default last).\nRaises IndexError if list is empty or index is out of range."
  },
  "list.remove": {
    "definition": "(self, value)",
    "docstring": "L.remove(value) -> None -- remove first occurrence of value.\nRaises ValueError if the value is not present."
  },
  "list.reverse": {
    "definition": "(self)",
    "docstring": "L.reverse() -- reverse *IN PLACE*"
  },
  "list.sort": {
    "definition": "(self, key=<no value>, reverse=<no value>)",
    "docstring": "L.sort(key=None, reverse=False) -> None -- stable sort *IN PLACE*"
  },
  "max": {
    "definition": "(*args, **keywords)",
    "docstring": "max(iterable, *[, default=obj, key=func]) -> value\nmax(arg1, arg2, *args, *[, key=func]) -> value\n\nWith a single iterable argument, return its biggest item. The\ndefault keyword-only argument specifies an object to return if\nthe provided iterable is empty.\nWith two or more arguments, return the largest argument.\n    "
  },
  "mimetypes.guess_type": {
    "definition": "(url, strict=True)",
    "docstring": "Guess the type of a file based on its URL.\n\nReturn value is a tuple (type, encoding) where type is None if the\ntype can't be guessed (no or unknown suffix) or a string of the\nform type/subtype, usable for a MIME Content-type header; and\nencoding is None for no encoding or the name of the program used\nto encode (e.g. compress or gzip).  The mappings are table\ndriven.  Encoding suffixes are case sensitive; type suffixes are\nfirst tried case sensitive, then case insensitive.\n\nThe suffixes .tgz, .taz and .tz (case sensitive!) are all mapped\nto \".tar.gz\".  (This is table-driven too, using the dictionary\nsuffix_map).\n\nOptional `strict' argument when false adds a bunch of commonly found, but\nnon-standard types."
  },
  "min": {
    "definition": "(*args, **keywords)",
    "docstring": "min(iterable, *[, default=obj, key=func]) -> value\nmin(arg1, arg2, *args, *[, key=func]) -> value\n\nWith a single iterable argument, return its smallest item. The\ndefault keyword-only argument specifies an object to return if\nthe provided iterable is empty.\nWith two or more arguments, return the smallest argument.\n    "
  },
  "pathlib.PurePath": {
    "docstring": "Base class for manipulating paths without I/O.\n\nPurePath represents a filesystem path and offers operations which\ndon't imply any actual filesystem I/O.  Depending on your system,\ninstantiating a PurePath will return either a PurePosixPath or a\nPureWindowsPath object.  You can also instantiate either of these classes\ndirectly, regardless of your system.",
    "init_definition": "(*args)",
    "isclass": true
  },
  "print": {
    "definition": "(*args, sep=' ', end='\\n', file=None, flush=False)",
    "docstring": "print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n\nPrints the values to a stream, or to sys.stdout by default.\nOptional keyword arguments:\nfile:  a file-like object (stream); defaults to the current sys.stdout.\nsep:   string inserted between values, default a space.\nend:   string appended after the last value, default a newline.\nflush: whether to forcibly flush the stream."
  },
  "random.Random.betavariate": {
    "definition": "(self, alpha, beta)",
    "docstring": "Beta distribution.\n\nConditions on the parameters are alpha > 0 and beta > 0.\nReturned values range between 0 and 1."
  },
  "random.Random.choice": {
    "definition": "(self, seq)",
    "docstring": "Choose a random element from a non-empty sequence."
  },
  "random.Random.choices": {
    "definition": "(self, population, weights=None, *, cum_weights=None, k=1)",
    "docstring": "Return a k sized list of population elements chosen with replacement.\n\nIf the relative weights or cumulative weights are not specified,\nthe selections are made with equal probability."
  },
  "random.Random.expovariate": {
    "definition": "(self, lambd)",
    "docstring": "Exponential distribution.\n\nlambd is 1.0 divided by the desired mean.  It should be\nnonzero.  (The parameter would be called \"lambda\", but that is\na reserved word in Python.)  Returned values range from 0 to\npositive infinity if lambd is positive, and from negative\ninfinity to 0 if lambd is negative."
  },
  "random.Random.gauss": {
    "definition": "(self, mu, sigma)",
    "docstring": "Gaussian distribution.\n\nmu is the mean, and sigma is the standard deviation.  This is\nslightly faster than the normalvariate() function.\n\nNot thread-safe without a lock around calls."
  },
  "random.Random.paretovariate": {
    "definition": "(self, alpha)",
    "docstring": "Pareto distribution.  alpha is the shape parameter."
  },
  "random.Random.sample": {
    "definition": "(self, population, k, *, counts=None)",
    "docstring": "Chooses k unique random elements from a population sequence or set.\n\nReturns a new list containing elements from the population while\nleaving the original population unchanged.  The resulting list is\nin selection order so that all sub-slices will also be valid random\nsamples.  This allows raffle winners (the sample) to be partitioned\ninto grand prize and second place winners (the subslices).\n\nMembers of the population need not be hashable or unique.  If the\npopulation contains repeats, then each occurrence is a possible\nselection in the sample.\n\nRepeated elements can be specified one at a time or with the optional\ncounts parameter.  For example:\n\n    sample(['red', 'blue'], counts=[4, 2], k=5)\n\nis equivalent to:\n\n    sample(['red', 'red', 'red', 'red', 'blue', 'blue'], k=5)\n\nTo choose a sample from a range of integers, use range() for the\npopulation argument.  This is especially fast and space efficient\nfor sampling from a large population:\n\n    sample(range(10000000), 60)"
  },
  "random.Random.shuffle": {
    "definition": "(self, x, random=None)",
    "docstring": "Shuffle list x in place, and return None.\n\nOptional argument random is a 0-argument function returning a\nrandom float in [0.0, 1.0); if it is the default None, the\nstandard random.random will be used."
  },
  "random.Random.triangular": {
    "definition": "(self, low=0.0, high=1.0, mode=None)",
    "docstring": "Triangular distribution.\n\nContinuous distribution bounded by given lower and upper limits,\nand having a given mode value in-between.\n\nhttp://en.wikipedia.org/wiki/Triangular_distribution"
  },
  "random.Random.uniform": {
    "definition": "(self, a, b)",
    "docstring": "Get a random number in the range [a, b) or [a, b] depending on rounding."
  },
  "range": {
    "docstring": "<no docstring>",
    "init_definition": "(obj, *args, **keywords)",
    "isclass": true
  },
  "re2.BackreferencesException": {
    "docstring": "Search pattern contains backreferences.",
    "init_definition": "(self, *args)",
    "isclass": true
  },
  "re2.CharClassProblemException": {
    "docstring": "Search pattern contains unsupported character class.",
    "init_definition": "(self, *args)",
    "isclass": true
  },
  "re2.compile": {
    "docstring": "<no docstring>",
    "call_def": "(*args, **keywords)"
  },
  "re2.contains": {
    "docstring": "Scan through string looking for a match to the pattern, returning\nTrue or False.",
    "call_def": "(*args, **keywords)"
  },
  "re2.count": {
    "docstring": "Return number of non-overlapping matches in the string.\n\nEmpty matches are included in the count.",
    "call_def": "(*args, **keywords)"
  },
  "re2.escape": {
    "docstring": "Escape all non-alphanumeric characters in pattern.",
    "call_def": "(*args, **keywords)"
  },
  "re2.findall": {
    "docstring": "Return a list of all non-overlapping matches in the string.\n\nEach match is represented as a string or a tuple (when there are two ore\nmore groups). Empty matches are included in the result.",
    "call_def": "(*args, **keywords)"
  },
  "re2.finditer": {
    "docstring": "Yield all non-overlapping matches in the string.\n\nFor each match, the iterator returns a ``Match`` object.\nEmpty matches are included in the result.",
    "call_def": "(*args, **keywords)"
  },
  "re2.fullmatch": {
    "docstring": "Try to apply the pattern to the entire string, returning\na ``Match`` object, or ``None`` if no match was found.",
    "call_def": "(*args, **keywords)"
  },
  "re2.match": {
    "docstring": "Try to apply the pattern at the start of the string, returning\na ``Match`` object, or ``None`` if no match was found.",
    "call_def": "(*args, **keywords)"
  },
  "re2.search": {
    "docstring": "Scan through string looking for a match to the pattern, returning\na ``Match`` object or none if no match was found.",
    "call_def": "(*args, **keywords)"
  },
  "re2.split": {
    "docstring": "Split the source string by the occurrences of the pattern,\nreturning a list containing the resulting substrings.",
    "call_def": "(*args, **keywords)"
  },
  "re2.sub": {
    "docstring": "Return the string obtained by replacing the leftmost\nnon-overlapping occurrences of the pattern in string by the\nreplacement ``repl``. ``repl`` can be either a string or a callable;\nif a string, backslash escapes in it are processed. If it is\na callable, it's passed the ``Match`` object and must return\na replacement string to be used.",
    "call_def": "(*args, **keywords)"
  },
  "re2.subn": {
    "docstring": "Return a 2-tuple containing ``(new_string, number)``.\nnew_string is the string obtained by replacing the leftmost\nnon-overlapping occurrences of the pattern in the source\nstring by the replacement ``repl``. ``number`` is the number of\nsubstitutions that were made. ``repl`` can be either a string or a\ncallable; if a string, backslash escapes in it are processed.\nIf it is a callable, it's passed the ``Match`` object and must\nreturn a replacement string to be used.",
    "call_def": "(*args, **keywords)"
  },
  "round": {
    "definition": "(number, ndigits=<no value>)",
    "docstring": "round(number[, ndigits]) -> number\n\nRound a number to a given precision in decimal digits (default 0 digits).\nThis returns an int when called with one argument or if ndigits=None,\notherwise the same type as the number. ndigits may be negative."
  },
  "set": {
    "docstring": "set(iterable) --> set object\n\nBuild an unordered collection.",
    "init_definition": "(self, *args, **keywords)",
    "isclass": true
  },
  "simplejson.dumps": {
    "definition": "(\n    obj,\n    skipkeys=False,\n    ensure_ascii=True,\n    check_circular=True,\n    allow_nan=True,\n    cls=None,\n    indent=None,\n    separators=None,\n    encoding='utf-8',\n    default=None,\n    use_decimal=True,\n    namedtuple_as_object=True,\n    tuple_as_array=True,\n    bigint_as_string=False,\n    sort_keys=False,\n    item_sort_key=None,\n    for_json=False,\n    ignore_nan=False,\n    int_as_string_bitcount=None,\n    iterable_as_array=False,\n    **kw,\n)",
    "docstring": "Serialize ``obj`` to a JSON formatted ``str``.\n\nIf ``skipkeys`` is false then ``dict`` keys that are not basic types\n(``str``, ``int``, ``long``, ``float``, ``bool``, ``None``)\nwill be skipped instead of raising a ``TypeError``.\n\nIf *ensure_ascii* is false (default: ``True``), then the output may\ncontain non-ASCII characters, so long as they do not need to be escaped\nby JSON. When it is true, all non-ASCII characters are escaped.\n\nIf ``check_circular`` is false, then the circular reference check\nfor container types will be skipped and a circular reference will\nresult in an ``OverflowError`` (or worse).\n\nIf ``allow_nan`` is false, then it will be a ``ValueError`` to\nserialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in\nstrict compliance of the JSON specification, instead of using the\nJavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n\nIf ``indent`` is a string, then JSON array elements and object members\nwill be pretty-printed with a newline followed by that string repeated\nfor each level of nesting. ``None`` (the default) selects the most compact\nrepresentation without any newlines. For backwards compatibility with\nversions of simplejson earlier than 2.1.0, an integer is also accepted\nand is converted to a string with that many spaces.\n\nIf specified, ``separators`` should be an\n``(item_separator, key_separator)`` tuple.  The default is ``(', ', ': ')``\nif *indent* is ``None`` and ``(',', ': ')`` otherwise.  To get the most\ncompact JSON representation, you should specify ``(',', ':')`` to eliminate\nwhitespace.\n\n``encoding`` is the character encoding for bytes instances, default is\nUTF-8.\n\n``default(obj)`` is a function that should return a serializable version\nof obj or raise TypeError. The default simply raises TypeError.\n\nIf *use_decimal* is true (default: ``True``) then decimal.Decimal\nwill be natively serialized to JSON with full precision.\n\nIf *namedtuple_as_object* is true (default: ``True``),\n:class:`tuple` subclasses with ``_asdict()`` methods will be encoded\nas JSON objects.\n\nIf *tuple_as_array* is true (default: ``True``),\n:class:`tuple` (and subclasses) will be encoded as JSON arrays.\n\nIf *iterable_as_array* is true (default: ``False``),\nany object not in the above table that implements ``__iter__()``\nwill be encoded as a JSON array.\n\nIf *bigint_as_string* is true (not the default), ints 2**53 and higher\nor lower than -2**53 will be encoded as strings. This is to avoid the\nrounding that happens in Javascript otherwise.\n\nIf *int_as_string_bitcount* is a positive number (n), then int of size\ngreater than or equal to 2**n or lower than or equal to -2**n will be\nencoded as strings.\n\nIf specified, *item_sort_key* is a callable used to sort the items in\neach dictionary. This is useful if you want to sort items other than\nin alphabetical order by key. This option takes precedence over\n*sort_keys*.\n\nIf *sort_keys* is true (default: ``False``), the output of dictionaries\nwill be sorted by item.\n\nIf *for_json* is true (default: ``False``), objects with a ``for_json()``\nmethod will use the return value of that method for encoding as JSON\ninstead of the object.\n\nIf *ignore_nan* is true (default: ``False``), then out of range\n:class:`float` values (``nan``, ``inf``, ``-inf``) will be serialized as\n``null`` in compliance with the ECMA-262 specification. If true, this will\noverride *allow_nan*.\n\nTo use a custom ``JSONEncoder`` subclass (e.g. one that overrides the\n``.default()`` method to serialize additional types), specify it with\nthe ``cls`` kwarg. NOTE: You should use *default* instead of subclassing\nwhenever possible."
  },
  "simplejson.errors.JSONDecodeError": {
    "docstring": "Subclass of ValueError with the following additional properties:\n\nmsg: The unformatted error message\ndoc: The JSON document being parsed\npos: The start index of doc where parsing failed\nend: The end index of doc where parsing failed (may be None)\nlineno: The line corresponding to pos\ncolno: The column corresponding to pos\nendlineno: The line corresponding to end (may be None)\nendcolno: The column corresponding to end (may be None)",
    "init_definition": "(msg, doc, pos, end=None)",
    "isclass": true
  },
  "simplejson.loads": {
    "definition": "(\n    s,\n    encoding=None,\n    cls=None,\n    object_hook=None,\n    parse_float=None,\n    parse_int=None,\n    parse_constant=None,\n    object_pairs_hook=None,\n    use_decimal=False,\n    **kw,\n)",
    "docstring": "Deserialize ``s`` (a ``str`` or ``unicode`` instance containing a JSON\ndocument) to a Python object.\n\n*encoding* determines the encoding used to interpret any\n:class:`bytes` objects decoded by this instance (``'utf-8'`` by\ndefault). It has no effect when decoding :class:`unicode` objects.\n\n*object_hook*, if specified, will be called with the result of every\nJSON object decoded and its return value will be used in place of the\ngiven :class:`dict`.  This can be used to provide custom\ndeserializations (e.g. to support JSON-RPC class hinting).\n\n*object_pairs_hook* is an optional function that will be called with\nthe result of any object literal decode with an ordered list of pairs.\nThe return value of *object_pairs_hook* will be used instead of the\n:class:`dict`.  This feature can be used to implement custom decoders\nthat rely on the order that the key and value pairs are decoded (for\nexample, :func:`collections.OrderedDict` will remember the order of\ninsertion). If *object_hook* is also defined, the *object_pairs_hook*\ntakes priority.\n\n*parse_float*, if specified, will be called with the string of every\nJSON float to be decoded.  By default, this is equivalent to\n``float(num_str)``. This can be used to use another datatype or parser\nfor JSON floats (e.g. :class:`decimal.Decimal`).\n\n*parse_int*, if specified, will be called with the string of every\nJSON int to be decoded.  By default, this is equivalent to\n``int(num_str)``.  This can be used to use another datatype or parser\nfor JSON integers (e.g. :class:`float`).\n\n*parse_constant*, if specified, will be called with one of the\nfollowing strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``.  This\ncan be used to raise an exception if invalid JSON numbers are\nencountered.\n\nIf *use_decimal* is true (default: ``False``) then it implies\nparse_float=decimal.Decimal for parity with ``dump``.\n\nTo use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\nkwarg. NOTE: You should use *object_hook* or *object_pairs_hook* instead\nof subclassing whenever possible."
  },
  "sorted": {
    "definition": "(iterable, /, *, key=None, reverse=False)",
    "docstring": "sorted(iterable, key=None, reverse=False) --> new sorted list"
  },
  "str": {
    "docstring": "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.",
    "init_definition": "(obj, *args, **keywords)",
    "isclass": true
  },
  "str.capitalize": {
    "definition": "(self)",
    "docstring": "S.capitalize() -> unicode\n\nReturn a capitalized version of S, i.e. make the first character\nhave upper case and the rest lower case."
  },
  "str.casefold": {
    "definition": "(self)",
    "docstring": "S.casefold() -> str\n\nReturn a version of S suitable for caseless comparisons."
  },
  "str.count": {
    "definition": "(self, sub, start=<no value>, end=<no value>)",
    "docstring": "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nUnicode string S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation."
  },
  "str.encode": {
    "definition": "(self, encoding=<no value>, errors=<no value>)",
    "docstring": "S.encode(encoding=None, errors='strict') -> string or unicode\n\nEncode S using the codec registered for encoding. encoding defaults\nto the default encoding. errors may be given to set a different error\nhandling scheme. Default is 'strict' meaning that encoding errors raise\na UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n'xmlcharrefreplace' as well as any other name registered with\ncodecs.register_error that can handle UnicodeEncodeErrors."
  },
  "str.endswith": {
    "definition": "(self, suffix, start=<no value>, end=<no value>)",
    "docstring": "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try."
  },
  "str.find": {
    "definition": "(self, sub, start=<no value>, end=<no value>)",
    "docstring": "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure."
  },
  "str.index": {
    "definition": "(self, sub, start=<no value>, end=<no value>)",
    "docstring": "S.index(sub[, start[, end]]) -> int\n\nLike S.find() but raise ValueError when the substring is not found."
  },
  "str.isalnum": {
    "definition": "(self)",
    "docstring": "S.isalnum() -> bool\n\nReturn True if all characters in S are alphanumeric\nand there is at least one character in S, False otherwise."
  },
  "str.isalpha": {
    "definition": "(self)",
    "docstring": "S.isalpha() -> bool\n\nReturn True if all characters in S are alphabetic\nand there is at least one character in S, False otherwise."
  },
  "str.isascii": {
    "definition": "(self)",
    "docstring": "Return True if all characters in the string are ASCII, False otherwise.\n\nASCII characters have code points in the range U+0000-U+007F.\nEmpty string is ASCII too."
  },
  "str.isdecimal": {
    "definition": "(self)",
    "docstring": "S.isdecimal() -> bool\n\nReturn True if there are only decimal characters in S,\nFalse otherwise."
  },
  "str.isdigit": {
    "definition": "(self)",
    "docstring": "S.isdigit() -> bool\n\nReturn True if all characters in S are digits\nand there is at least one character in S, False otherwise."
  },
  "str.isidentifier": {
    "definition": "(self)",
    "docstring": "S.isidentifier() -> bool\n\nReturn True if S is a valid identifier according to the language\ndefinition."
  },
  "str.islower": {
    "definition": "(self)",
    "docstring": "S.islower() -> bool\n\nReturn True if all cased characters in S are lowercase and there is\nat least one cased character in S, False otherwise."
  },
  "str.isnumeric": {
    "definition": "(self)",
    "docstring": "S.isnumeric() -> bool\n\nReturn True if there are only numeric characters in S,\nFalse otherwise."
  },
  "str.isprintable": {
    "definition": "(self)",
    "docstring": "S.isprintable() -> bool\n\nReturn True if all characters in S are considered printable in\nrepr() or S is empty, False otherwise."
  },
  "str.isspace": {
    "definition": "(self)",
    "docstring": "S.isspace() -> bool\n\nReturn True if all characters in S are whitespace\nand there is at least one character in S, False otherwise."
  },
  "str.istitle": {
    "definition": "(self)",
    "docstring": "S.istitle() -> bool\n\nReturn True if S is a titlecased string and there is at least one\ncharacter in S, i.e. upper- and titlecase characters may only\nfollow uncased characters and lowercase characters only cased ones.\nReturn False otherwise."
  },
  "str.isupper": {
    "definition": "(self)",
    "docstring": "S.isupper() -> bool\n\nReturn True if all cased characters in S are uppercase and there is\nat least one cased character in S, False otherwise."
  },
  "str.join": {
    "definition": "(self, iterable)",
    "docstring": "S.join(iterable) -> unicode\n\nReturn a string which is the concatenation of the strings in the\niterable.  The separator between elements is S."
  },
  "str.lower": {
    "definition": "(self)",
    "docstring": "S.lower() -> unicode\n\nReturn a copy of the string S converted to lowercase."
  },
  "str.lstrip": {
    "definition": "(self, chars=<no value>)",
    "docstring": "S.lstrip([chars]) -> unicode\n\nReturn a copy of the string S with leading whitespace removed.\nIf chars is given and not None, remove characters in chars instead.\nIf chars is a str, it will be converted to unicode before stripping"
  },
  "str.partition": {
    "definition": "(self, sub)",
    "docstring": "S.partition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, and return the part before it,\nthe separator itself, and the part after it.  If the separator is not\nfound, return S and two empty strings."
  },
  "str.removeprefix": {
    "definition": "(self, prefix)",
    "docstring": "<no docstring>"
  },
  "str.removesuffix": {
    "definition": "(self, suffix)",
    "docstring": "<no docstring>"
  },
  "str.rfind": {
    "definition": "(self, sub, start=<no value>, end=<no value>)",
    "docstring": "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure."
  },
  "str.rindex": {
    "definition": "(self, sub, start=<no value>, end=<no value>)",
    "docstring": "S.rindex(sub[, start[, end]]) -> int\n\nLike S.rfind() but raise ValueError when the substring is not found."
  },
  "str.rpartition": {
    "definition": "(self, sub)",
    "docstring": "S.rpartition(sep) -> (head, sep, tail)\n\nSearch for the separator sep in S, starting at the end of S, and return\nthe part before it, the separator itself, and the part after it.  If\nthe separator is not found, return two empty strings and S."
  },
  "str.rsplit": {
    "definition": "(self, sep=<no value>, maxsplit=<no value>)",
    "docstring": "S.rsplit(sep=None, maxsplit=-1) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string, starting at the end of the string and\nworking to the front.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified, any whitespace string\nis a separator."
  },
  "str.rstrip": {
    "definition": "(self, chars=<no value>)",
    "docstring": "S.rstrip([chars]) -> unicode\n\nReturn a copy of the string S with trailing whitespace removed.\nIf chars is given and not None, remove characters in chars instead.\nIf chars is a str, it will be converted to unicode before stripping"
  },
  "str.split": {
    "definition": "(self, sep=<no value>, maxsplit=<no value>)",
    "docstring": "S.split(sep=None, maxsplit=-1) -> list of strings\n\nReturn a list of the words in S, using sep as the\ndelimiter string.  If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator and empty strings are\nremoved from the result."
  },
  "str.splitlines": {
    "definition": "(self, keepends=False)",
    "docstring": "S.splitlines(keepends=False) -> list of strings\n\nReturn a list of the lines in S, breaking at line boundaries.\nLine breaks are not included in the resulting list unless keepends\nis given and true."
  },
  "str.startswith": {
    "definition": "(self, prefix, start=<no value>, end=<no value>)",
    "docstring": "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try."
  },
  "str.strip": {
    "definition": "(self, chars=<no value>)",
    "docstring": "S.strip([chars]) -> unicode\n\nReturn a copy of the string S with leading and trailing\nwhitespace removed.\nIf chars is given and not None, remove characters in chars instead.\nIf chars is a str, it will be converted to unicode before stripping"
  },
  "str.swapcase": {
    "definition": "(self)",
    "docstring": "S.swapcase() -> unicode\n\nReturn a copy of S with uppercase characters converted to lowercase\nand vice versa."
  },
  "str.title": {
    "definition": "(self)",
    "docstring": "S.title() -> unicode\n\nReturn a titlecased version of S, i.e. words start with title case\ncharacters, all remaining cased characters have lower case."
  },
  "str.upper": {
    "definition": "(self)",
    "docstring": "S.upper() -> unicode\n\nReturn a copy of S converted to uppercase."
  },
  "string.Template": {
    "docstring": "A string class for supporting $-substitutions.",
    "init_definition": "(template)",
    "isclass": true
  },
  "string.Template.safe_substitute": {
    "definition": "(self, mapping={}, /, **kws)",
    "docstring": "<no docstring>"
  },
  "string.Template.substitute": {
    "definition": "(self, mapping={}, /, **kws)",
    "docstring": "<no docstring>"
  },
  "sum": {
    "definition": "(sequence, start=0)",
    "docstring": "sum(sequence[, start]) -> value\n\nReturns the sum of a sequence of numbers (NOT strings) plus the value\nof parameter 'start' (which defaults to 0).  When the sequence is\nempty, returns start."
  },
  "tuple": {
    "docstring": "tuple() -> an empty tuple\ntuple(sequence) -> tuple initialized from sequence's items\n\nIf the argument is a tuple, the return value is the same object.",
    "init_definition": "(obj, *args, **keywords)",
    "isclass": true
  },
  "typing.Annotated": {
    "docstring": "Add context specific metadata to a type.\n\nExample: Annotated[int, runtime_check.Unsigned] indicates to the\nhypothetical runtime_check module that this type is an unsigned int.\nEvery other consumer of this type can ignore this metadata and treat\nthis type as int.\n\nThe first argument to Annotated must be a valid type.\n\nDetails:\n\n- It's an error to call `Annotated` with less than two arguments.\n- Nested Annotated are flattened::\n\n    Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]\n\n- Instantiating an annotated type is equivalent to instantiating the\nunderlying type::\n\n    Annotated[C, Ann1](5) == C(5)\n\n- Annotated can be used as a generic type alias::\n\n    Optimized = Annotated[T, runtime.Optimize()]\n    Optimized[int] == Annotated[int, runtime.Optimize()]\n\n    OptimizedList = Annotated[List[T], runtime.Optimize()]\n    OptimizedList[int] == Annotated[List[int], runtime.Optimize()]",
    "init_definition": "(*args, **kwargs)",
    "isclass": true
  },
  "typing.Any": {
    "definition": "(*args, **kwds)",
    "docstring": "Special type indicating an unconstrained type.\n\n- Any is compatible with every type.\n- Any assumed to have all methods.\n- All values assumed to be instances of Any.\n\nNote that all the above statements are true from the point of view of\nstatic type checkers. At runtime, Any should not be used with instance\nor class checks."
  },
  "typing.Callable": {
    "definition": "(*args, **kwargs)",
    "docstring": "Callable type; Callable[[int], str] is a function of (int) -> str.\n\nThe subscription syntax must always be used with exactly two\nvalues: the argument list and the return type.  The argument list\nmust be a list of types or ellipsis; the return type must be a single type.\n\nThere is no syntax to indicate optional or keyword arguments,\nsuch function types are rarely used as callback types.",
    "class_docstring": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict."
  },
  "typing.Literal": {
    "definition": "(*args, **kwds)",
    "docstring": "Special typing form to define literal types (a.k.a. value types).\n\nThis form can be used to indicate to type checkers that the corresponding\nvariable or function parameter has a value equivalent to the provided\nliteral (or one of several literals):\n\n  def validate_simple(data: Any) -> Literal[True]:  # always returns True\n      ...\n\n  MODE = Literal['r', 'rb', 'w', 'wb']\n  def open_helper(file: str, mode: MODE) -> str:\n      ...\n\n  open_helper('/some/path', 'r')  # Passes type check\n  open_helper('/other/path', 'typo')  # Error in type checker\n\nLiteral[...] cannot be subclassed. At runtime, an arbitrary value\nis allowed as type argument to Literal[...], but type checkers may\nimpose restrictions."
  },
  "typing.Optional": {
    "definition": "(*args, **kwds)",
    "docstring": "Optional type.\n\nOptional[X] is equivalent to Union[X, None]."
  },
  "typing.Union": {
    "definition": "(*args, **kwds)",
    "docstring": "Union type; Union[X, Y] means either X or Y.\n\nTo define a union, use e.g. Union[int, str].  Details:\n- The arguments must be types and there must be at least one.\n- None as an argument is a special case and is replaced by\n  type(None).\n- Unions of unions are flattened, e.g.::\n\n    Union[Union[int, str], float] == Union[int, str, float]\n\n- Unions of a single argument vanish, e.g.::\n\n    Union[int] == int  # The constructor actually returns int\n\n- Redundant arguments are skipped, e.g.::\n\n    Union[int, str, int] == Union[int, str]\n\n- When comparing unions, the argument order is ignored, e.g.::\n\n    Union[int, str] == Union[str, int]\n\n- You cannot subclass or instantiate a union.\n- You can use Optional[X] as a shorthand for Union[X, None]."
  },
  "urllib.parse.parse_qs": {
    "definition": "(\n    qs,\n    keep_blank_values=False,\n    strict_parsing=False,\n    encoding='utf-8',\n    errors='replace',\n    max_num_fields=None,\n    separator='&',\n)",
    "docstring": "Parse a query given as a string argument.\n\nArguments:\n\nqs: percent-encoded query string to be parsed\n\nkeep_blank_values: flag indicating whether blank values in\n    percent-encoded queries should be treated as blank strings.\n    A true value indicates that blanks should be retained as\n    blank strings.  The default false value indicates that\n    blank values are to be ignored and treated as if they were\n    not included.\n\nstrict_parsing: flag indicating what to do with parsing errors.\n    If false (the default), errors are silently ignored.\n    If true, errors raise a ValueError exception.\n\nencoding and errors: specify how to decode percent-encoded sequences\n    into Unicode characters, as accepted by the bytes.decode() method.\n\nmax_num_fields: int. If set, then throws a ValueError if there\n    are more than n fields read by parse_qsl().\n\nseparator: str. The symbol to use for separating the query arguments.\n    Defaults to &.\n\nReturns a dictionary."
  },
  "urllib.parse.parse_qsl": {
    "definition": "(\n    qs,\n    keep_blank_values=False,\n    strict_parsing=False,\n    encoding='utf-8',\n    errors='replace',\n    max_num_fields=None,\n    separator='&',\n)",
    "docstring": "Parse a query given as a string argument.\n\nArguments:\n\nqs: percent-encoded query string to be parsed\n\nkeep_blank_values: flag indicating whether blank values in\n    percent-encoded queries should be treated as blank strings.\n    A true value indicates that blanks should be retained as blank\n    strings.  The default false value indicates that blank values\n    are to be ignored and treated as if they were  not included.\n\nstrict_parsing: flag indicating what to do with parsing errors. If\n    false (the default), errors are silently ignored. If true,\n    errors raise a ValueError exception.\n\nencoding and errors: specify how to decode percent-encoded sequences\n    into Unicode characters, as accepted by the bytes.decode() method.\n\nmax_num_fields: int. If set, then throws a ValueError\n    if there are more than n fields read by parse_qsl().\n\nseparator: str. The symbol to use for separating the query arguments.\n    Defaults to &.\n\nReturns a list, as G-d intended."
  },
  "urllib.parse.quote": {
    "definition": "(string, safe='/', encoding=None, errors=None)",
    "docstring": "quote('abc def') -> 'abc%20def'\n\nEach part of a URL, e.g. the path info, the query, etc., has a\ndifferent set of reserved characters that must be quoted. The\nquote function offers a cautious (not minimal) way to quote a\nstring for most of these parts.\n\nRFC 3986 Uniform Resource Identifier (URI): Generic Syntax lists\nthe following (un)reserved characters.\n\nunreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\nreserved      = gen-delims / sub-delims\ngen-delims    = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\nsub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n              / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n\nEach of the reserved characters is reserved in some component of a URL,\nbut not necessarily in all of them.\n\nThe quote function %-escapes all characters that are neither in the\nunreserved chars (\"always safe\") nor the additional chars set via the\nsafe arg.\n\nThe default for the safe arg is '/'. The character is reserved, but in\ntypical usage the quote function is being called on a path where the\nexisting slash characters are to be preserved.\n\nPython 3.7 updates from using RFC 2396 to RFC 3986 to quote URL strings.\nNow, \"~\" is included in the set of unreserved characters.\n\nstring and safe may be either str or bytes objects. encoding and errors\nmust not be specified if string is a bytes object.\n\nThe optional encoding and errors parameters specify how to deal with\nnon-ASCII characters, as accepted by the str.encode method.\nBy default, encoding='utf-8' (characters are encoded with UTF-8), and\nerrors='strict' (unsupported characters raise a UnicodeEncodeError)."
  },
  "urllib.parse.quote_from_bytes": {
    "definition": "(bs, safe='/')",
    "docstring": "Like quote(), but accepts a bytes object rather than a str, and does\nnot perform string-to-bytes encoding.  It always returns an ASCII string.\nquote_from_bytes(b'abc def?') -> 'abc%20def%3f'"
  },
  "urllib.parse.quote_plus": {
    "definition": "(string, safe='', encoding=None, errors=None)",
    "docstring": "Like quote(), but also replace ' ' with '+', as required for quoting\nHTML form values. Plus signs in the original string are escaped unless\nthey are included in safe. It also does not have safe default to '/'."
  },
  "urllib.parse.unquote": {
    "definition": "(string, encoding='utf-8', errors='replace')",
    "docstring": "Replace %xx escapes by their single-character equivalent. The optional\nencoding and errors parameters specify how to decode percent-encoded\nsequences into Unicode characters, as accepted by the bytes.decode()\nmethod.\nBy default, percent-encoded sequences are decoded with UTF-8, and invalid\nsequences are replaced by a placeholder character.\n\nunquote('abc%20def') -> 'abc def'."
  },
  "urllib.parse.unquote_plus": {
    "definition": "(string, encoding='utf-8', errors='replace')",
    "docstring": "Like unquote(), but also replace plus signs by spaces, as required for\nunquoting HTML form values.\n\nunquote_plus('%7e/abc+def') -> '~/abc def'"
  },
  "urllib.parse.unquote_to_bytes": {
    "definition": "(string)",
    "docstring": "unquote_to_bytes('abc%20def') -> b'abc def'."
  },
  "urllib.parse.urldefrag": {
    "definition": "(url)",
    "docstring": "Removes any existing fragment from URL.\n\nReturns a tuple of the defragmented URL and the fragment.  If\nthe URL contained no fragments, the second element is the\nempty string."
  },
  "urllib.parse.urljoin": {
    "definition": "(base, url, allow_fragments=True)",
    "docstring": "Join a base URL and a possibly relative URL to form an absolute\ninterpretation of the latter."
  },
  "urllib.parse.urlsplit": {
    "definition": "(url, scheme='', allow_fragments=True)",
    "docstring": "Parse a URL into 5 components:\n<scheme>://<netloc>/<path>?<query>#<fragment>\n\nThe result is a named 5-tuple with fields corresponding to the\nabove. It is either a SplitResult or SplitResultBytes object,\ndepending on the type of the url parameter.\n\nThe username, password, hostname, and port sub-components of netloc\ncan also be accessed as attributes of the returned object.\n\nThe scheme argument provides the default value of the scheme\ncomponent when no scheme is found in url.\n\nIf allow_fragments is False, no attempt is made to separate the\nfragment component from the previous component, which can be either\npath or query.\n\nNote that % escapes are not expanded."
  },
  "urllib.parse.urlunsplit": {
    "definition": "(components)",
    "docstring": "Combine the elements of a tuple as returned by urlsplit() into a\ncomplete URL as a string. The data argument can be any five-item iterable.\nThis may result in a slightly different, but equivalent URL, if the URL that\nwas parsed originally had unnecessary delimiters (for example, a ? with an\nempty query; the RFC states that these are equivalent)."
  },
  "wsgiref.handlers.BaseHandler.start_response": {
    "definition": "(self, status, headers, exc_info=None)",
    "docstring": "'start_response()' callable as specified by PEP 3333"
  },
  "wsgiref.handlers.BaseHandler.write": {
    "definition": "(self, data)",
    "docstring": "'write()' callable as specified by PEP 3333"
  }
}