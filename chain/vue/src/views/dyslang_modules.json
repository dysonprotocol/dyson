{
  "datetime": {
    "timedelta": "Represent the difference between two datetime objects.\n\n    Supported operators:\n\n    - add, subtract timedelta\n    - unary plus, minus, abs\n    - compare to timedelta\n    - multiply, divide by int\n\n    In addition, datetime supports subtraction of two datetime objects\n    returning a timedelta, and addition or subtraction of a datetime\n    and a timedelta giving a datetime.\n\n    Representation: (days, seconds, microseconds).  Why?  Because I\n    felt like it.\n    ",
    "date": "Concrete date type.\n\n    Constructors:\n\n    __new__()\n    fromtimestamp()\n    today()\n    fromordinal()\n\n    Operators:\n\n    __repr__, __str__\n    __eq__, __le__, __lt__, __ge__, __gt__, __hash__\n    __add__, __radd__, __sub__ (add/radd only with timedelta arg)\n\n    Methods:\n\n    timetuple()\n    toordinal()\n    weekday()\n    isoweekday(), isocalendar(), isoformat()\n    ctime()\n    strftime()\n\n    Properties (readonly):\n    year, month, day\n    ",
    "time": "Time with time zone.\n\n    Constructors:\n\n    __new__()\n\n    Operators:\n\n    __repr__, __str__\n    __eq__, __le__, __lt__, __ge__, __gt__, __hash__\n\n    Methods:\n\n    strftime()\n    isoformat()\n    utcoffset()\n    tzname()\n    dst()\n\n    Properties (readonly):\n    hour, minute, second, microsecond, tzinfo, fold\n    ",
    "datetime": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\n    The year, month and day arguments are required. tzinfo may be None, or an\n    instance of a tzinfo subclass. The remaining arguments may be ints.\n    ",
    "tzinfo": "Abstract base class for time zone info classes.\n\n    Subclasses must override the name(), utcoffset() and dst() methods.\n    ",
    "timezone": null
  },
  "pathlib": {
    "PurePath": "Base class for manipulating paths without I/O.\n\n    PurePath represents a filesystem path and offers operations which\n    don't imply any actual filesystem I/O.  Depending on your system,\n    instantiating a PurePath will return either a PurePosixPath or a\n    PureWindowsPath object.  You can also instantiate either of these classes\n    directly, regardless of your system.\n    "
  },
  "uuid": {
    "uuid4": "Generate a random UUID."
  },
  "mimetypes": {
    "guess_type": "Guess the type of a file based on its URL.\n\n    Return value is a tuple (type, encoding) where type is None if the\n    type can't be guessed (no or unknown suffix) or a string of the\n    form type/subtype, usable for a MIME Content-type header; and\n    encoding is None for no encoding or the name of the program used\n    to encode (e.g. compress or gzip).  The mappings are table\n    driven.  Encoding suffixes are case sensitive; type suffixes are\n    first tried case sensitive, then case insensitive.\n\n    The suffixes .tgz, .taz and .tz (case sensitive!) are all mapped\n    to \".tar.gz\".  (This is table-driven too, using the dictionary\n    suffix_map).\n\n    Optional `strict' argument when false adds a bunch of commonly found, but\n    non-standard types.\n    "
  },
  "urllib": {
    "parse": "Parse (absolute and relative) URLs.\n\nurlparse module is based upon the following RFC specifications.\n\nRFC 3986 (STD66): \"Uniform Resource Identifiers\" by T. Berners-Lee, R. Fielding\nand L.  Masinter, January 2005.\n\nRFC 2732 : \"Format for Literal IPv6 Addresses in URL's by R.Hinden, B.Carpenter\nand L.Masinter, December 1999.\n\nRFC 2396:  \"Uniform Resource Identifiers (URI)\": Generic Syntax by T.\nBerners-Lee, R. Fielding, and L. Masinter, August 1998.\n\nRFC 2368: \"The mailto URL scheme\", by P.Hoffman , L Masinter, J. Zawinski, July 1998.\n\nRFC 1808: \"Relative Uniform Resource Locators\", by R. Fielding, UC Irvine, June\n1995.\n\nRFC 1738: \"Uniform Resource Locators (URL)\" by T. Berners-Lee, L. Masinter, M.\nMcCahill, December 1994\n\nRFC 3986 is considered the current standard and any future changes to\nurlparse module should conform with it.  The urlparse module is\ncurrently not entirely compliant with this RFC due to defacto\nscenarios for parsing, and for backward compatibility purposes, some\nparsing quirks from older RFCs are retained. The testcases in\ntest_urlparse.py provides a good indicator of parsing behavior.\n"
  },
  "base64": {
    "decodebytes": "Decode a bytestring of base-64 data into a bytes object.",
    "encodebytes": "Encode a bytestring into a bytes object containing multiple lines\n    of base-64 data.",
    "b64decode": "Decode the Base64 encoded bytes-like object or ASCII string s.\n\n    Optional altchars must be a bytes-like object or ASCII string of length 2\n    which specifies the alternative alphabet used instead of the '+' and '/'\n    characters.\n\n    The result is returned as a bytes object.  A binascii.Error is raised if\n    s is incorrectly padded.\n\n    If validate is False (the default), characters that are neither in the\n    normal base-64 alphabet nor the alternative alphabet are discarded prior\n    to the padding check.  If validate is True, these non-alphabet characters\n    in the input result in a binascii.Error.\n    ",
    "b64encode": "Encode the bytes-like object s using Base64 and return a bytes object.\n\n    Optional altchars should be a byte string of length 2 which specifies an\n    alternative alphabet for the '+' and '/' characters.  This allows an\n    application to e.g. generate url or filesystem safe Base64 strings.\n    ",
    "urlsafe_b64encode": "Encode bytes using the URL- and filesystem-safe Base64 alphabet.\n\n    Argument s is a bytes-like object to encode.  The result is returned as a\n    bytes object.  The alphabet uses '-' instead of '+' and '_' instead of\n    '/'.\n    ",
    "urlsafe_b64decode": "Decode bytes using the URL- and filesystem-safe Base64 alphabet.\n\n    Argument s is a bytes-like object or ASCII string to decode.  The result\n    is returned as a bytes object.  A binascii.Error is raised if the input\n    is incorrectly padded.  Characters that are not in the URL-safe base-64\n    alphabet, and are not a plus '+' or slash '/', are discarded prior to the\n    padding check.\n\n    The alphabet uses '-' instead of '+' and '_' instead of '/'.\n    "
  },
  "decimal": {
    "Decimal": "Floating point class for decimal arithmetic."
  },
  "json": {
    "dumps": "Serialize ``obj`` to a JSON formatted ``str``.\n\n    If ``skipkeys`` is false then ``dict`` keys that are not basic types\n    (``str``, ``int``, ``long``, ``float``, ``bool``, ``None``)\n    will be skipped instead of raising a ``TypeError``.\n\n    If *ensure_ascii* is false (default: ``True``), then the output may\n    contain non-ASCII characters, so long as they do not need to be escaped\n    by JSON. When it is true, all non-ASCII characters are escaped.\n\n    If ``check_circular`` is false, then the circular reference check\n    for container types will be skipped and a circular reference will\n    result in an ``OverflowError`` (or worse).\n\n    If ``allow_nan`` is false, then it will be a ``ValueError`` to\n    serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in\n    strict compliance of the JSON specification, instead of using the\n    JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n\n    If ``indent`` is a string, then JSON array elements and object members\n    will be pretty-printed with a newline followed by that string repeated\n    for each level of nesting. ``None`` (the default) selects the most compact\n    representation without any newlines. For backwards compatibility with\n    versions of simplejson earlier than 2.1.0, an integer is also accepted\n    and is converted to a string with that many spaces.\n\n    If specified, ``separators`` should be an\n    ``(item_separator, key_separator)`` tuple.  The default is ``(', ', ': ')``\n    if *indent* is ``None`` and ``(',', ': ')`` otherwise.  To get the most\n    compact JSON representation, you should specify ``(',', ':')`` to eliminate\n    whitespace.\n\n    ``encoding`` is the character encoding for bytes instances, default is\n    UTF-8.\n\n    ``default(obj)`` is a function that should return a serializable version\n    of obj or raise TypeError. The default simply raises TypeError.\n\n    If *use_decimal* is true (default: ``True``) then decimal.Decimal\n    will be natively serialized to JSON with full precision.\n\n    If *namedtuple_as_object* is true (default: ``True``),\n    :class:`tuple` subclasses with ``_asdict()`` methods will be encoded\n    as JSON objects.\n\n    If *tuple_as_array* is true (default: ``True``),\n    :class:`tuple` (and subclasses) will be encoded as JSON arrays.\n\n    If *iterable_as_array* is true (default: ``False``),\n    any object not in the above table that implements ``__iter__()``\n    will be encoded as a JSON array.\n\n    If *bigint_as_string* is true (not the default), ints 2**53 and higher\n    or lower than -2**53 will be encoded as strings. This is to avoid the\n    rounding that happens in Javascript otherwise.\n\n    If *int_as_string_bitcount* is a positive number (n), then int of size\n    greater than or equal to 2**n or lower than or equal to -2**n will be\n    encoded as strings.\n\n    If specified, *item_sort_key* is a callable used to sort the items in\n    each dictionary. This is useful if you want to sort items other than\n    in alphabetical order by key. This option takes precedence over\n    *sort_keys*.\n\n    If *sort_keys* is true (default: ``False``), the output of dictionaries\n    will be sorted by item.\n\n    If *for_json* is true (default: ``False``), objects with a ``for_json()``\n    method will use the return value of that method for encoding as JSON\n    instead of the object.\n\n    If *ignore_nan* is true (default: ``False``), then out of range\n    :class:`float` values (``nan``, ``inf``, ``-inf``) will be serialized as\n    ``null`` in compliance with the ECMA-262 specification. If true, this will\n    override *allow_nan*.\n\n    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the\n    ``.default()`` method to serialize additional types), specify it with\n    the ``cls`` kwarg. NOTE: You should use *default* instead of subclassing\n    whenever possible.\n\n    ",
    "loads": "Deserialize ``s`` (a ``str`` or ``unicode`` instance containing a JSON\n    document) to a Python object.\n\n    *encoding* determines the encoding used to interpret any\n    :class:`bytes` objects decoded by this instance (``'utf-8'`` by\n    default). It has no effect when decoding :class:`unicode` objects.\n\n    *object_hook*, if specified, will be called with the result of every\n    JSON object decoded and its return value will be used in place of the\n    given :class:`dict`.  This can be used to provide custom\n    deserializations (e.g. to support JSON-RPC class hinting).\n\n    *object_pairs_hook* is an optional function that will be called with\n    the result of any object literal decode with an ordered list of pairs.\n    The return value of *object_pairs_hook* will be used instead of the\n    :class:`dict`.  This feature can be used to implement custom decoders\n    that rely on the order that the key and value pairs are decoded (for\n    example, :func:`collections.OrderedDict` will remember the order of\n    insertion). If *object_hook* is also defined, the *object_pairs_hook*\n    takes priority.\n\n    *parse_float*, if specified, will be called with the string of every\n    JSON float to be decoded.  By default, this is equivalent to\n    ``float(num_str)``. This can be used to use another datatype or parser\n    for JSON floats (e.g. :class:`decimal.Decimal`).\n\n    *parse_int*, if specified, will be called with the string of every\n    JSON int to be decoded.  By default, this is equivalent to\n    ``int(num_str)``.  This can be used to use another datatype or parser\n    for JSON integers (e.g. :class:`float`).\n\n    *parse_constant*, if specified, will be called with one of the\n    following strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``.  This\n    can be used to raise an exception if invalid JSON numbers are\n    encountered.\n\n    If *use_decimal* is true (default: ``False``) then it implies\n    parse_float=decimal.Decimal for parity with ``dump``.\n\n    To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\n    kwarg. NOTE: You should use *object_hook* or *object_pairs_hook* instead\n    of subclassing whenever possible.\n\n    ",
    "JSONDecodeError": "Subclass of ValueError with the following additional properties:\n\n    msg: The unformatted error message\n    doc: The JSON document being parsed\n    pos: The start index of doc where parsing failed\n    end: The end index of doc where parsing failed (may be None)\n    lineno: The line corresponding to pos\n    colno: The column corresponding to pos\n    endlineno: The line corresponding to end (may be None)\n    endcolno: The column corresponding to end (may be None)\n\n    "
  },
  "jsonschema": {
    "validate": "\n    Validate an instance under the given schema.\n\n        >>> validate([2, 3, 4], {\"maxItems\": 2})\n        Traceback (most recent call last):\n            ...\n        ValidationError: [2, 3, 4] is too long\n\n    :func:`validate` will first verify that the provided schema is\n    itself valid, since not doing so can lead to less obvious error\n    messages and fail in less obvious or consistent ways.\n\n    If you know you have a valid schema already, especially if you\n    intend to validate multiple instances with the same schema, you\n    likely would prefer using the `IValidator.validate` method directly\n    on a specific validator (e.g. ``Draft7Validator.validate``).\n\n\n    Arguments:\n\n        instance:\n\n            The instance to validate\n\n        schema:\n\n            The schema to validate with\n\n        cls (IValidator):\n\n            The class that will be used to validate the instance.\n\n    If the ``cls`` argument is not provided, two things will happen\n    in accordance with the specification. First, if the schema has a\n    :validator:`$schema` property containing a known meta-schema [#]_\n    then the proper validator will be used. The specification recommends\n    that all schemas contain :validator:`$schema` properties for this\n    reason. If no :validator:`$schema` property is found, the default\n    validator class is the latest released draft.\n\n    Any other provided positional and keyword arguments will be passed\n    on when instantiating the ``cls``.\n\n    Raises:\n\n        `jsonschema.exceptions.ValidationError` if the instance\n            is invalid\n\n        `jsonschema.exceptions.SchemaError` if the schema itself\n            is invalid\n\n    .. rubric:: Footnotes\n    .. [#] known by a validator registered with\n        `jsonschema.validators.validates`\n    "
  },
  "jsonschema.exceptions": {
    "ValidationError": "\n    An instance was invalid under a provided schema.\n    ",
    "FormatError": "\n    Validating a format failed.\n    "
  },
  "html": {
    "escape": "\n    Replace special characters \"&\", \"<\" and \">\" to HTML-safe sequences.\n    If the optional flag quote is true (the default), the quotation mark\n    characters, both double quote (\") and single quote (') characters are also\n    translated.\n    "
  },
  "io": {
    "StringIO": null,
    "BytesIO": null
  },
  "hashlib": {
    "sha1": null,
    "sha256": null
  },
  "typing": {
    "Callable": "Callable type; Callable[[int], str] is a function of (int) -> str.\n\n    The subscription syntax must always be used with exactly two\n    values: the argument list and the return type.  The argument list\n    must be a list of types or ellipsis; the return type must be a single type.\n\n    There is no syntax to indicate optional or keyword arguments,\n    such function types are rarely used as callback types.\n    ",
    "Any": "Special type indicating an unconstrained type.\n\n    - Any is compatible with every type.\n    - Any assumed to have all methods.\n    - All values assumed to be instances of Any.\n\n    Note that all the above statements are true from the point of view of\n    static type checkers. At runtime, Any should not be used with instance\n    or class checks.\n    ",
    "Union": "Union type; Union[X, Y] means either X or Y.\n\n    To define a union, use e.g. Union[int, str].  Details:\n    - The arguments must be types and there must be at least one.\n    - None as an argument is a special case and is replaced by\n      type(None).\n    - Unions of unions are flattened, e.g.::\n\n        Union[Union[int, str], float] == Union[int, str, float]\n\n    - Unions of a single argument vanish, e.g.::\n\n        Union[int] == int  # The constructor actually returns int\n\n    - Redundant arguments are skipped, e.g.::\n\n        Union[int, str, int] == Union[int, str]\n\n    - When comparing unions, the argument order is ignored, e.g.::\n\n        Union[int, str] == Union[str, int]\n\n    - You cannot subclass or instantiate a union.\n    - You can use Optional[X] as a shorthand for Union[X, None].\n    ",
    "Optional": "Optional type.\n\n    Optional[X] is equivalent to Union[X, None].\n    ",
    "Literal": "Special typing form to define literal types (a.k.a. value types).\n\n    This form can be used to indicate to type checkers that the corresponding\n    variable or function parameter has a value equivalent to the provided\n    literal (or one of several literals):\n\n      def validate_simple(data: Any) -> Literal[True]:  # always returns True\n          ...\n\n      MODE = Literal['r', 'rb', 'w', 'wb']\n      def open_helper(file: str, mode: MODE) -> str:\n          ...\n\n      open_helper('/some/path', 'r')  # Passes type check\n      open_helper('/other/path', 'typo')  # Error in type checker\n\n    Literal[...] cannot be subclassed. At runtime, an arbitrary value\n    is allowed as type argument to Literal[...], but type checkers may\n    impose restrictions.\n    ",
    "Annotated": "Add context specific metadata to a type.\n\n    Example: Annotated[int, runtime_check.Unsigned] indicates to the\n    hypothetical runtime_check module that this type is an unsigned int.\n    Every other consumer of this type can ignore this metadata and treat\n    this type as int.\n\n    The first argument to Annotated must be a valid type.\n\n    Details:\n\n    - It's an error to call `Annotated` with less than two arguments.\n    - Nested Annotated are flattened::\n\n        Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]\n\n    - Instantiating an annotated type is equivalent to instantiating the\n    underlying type::\n\n        Annotated[C, Ann1](5) == C(5)\n\n    - Annotated can be used as a generic type alias::\n\n        Optimized = Annotated[T, runtime.Optimize()]\n        Optimized[int] == Annotated[int, runtime.Optimize()]\n\n        OptimizedList = Annotated[List[T], runtime.Optimize()]\n        OptimizedList[int] == Annotated[List[int], runtime.Optimize()]\n    "
  },
  "string": {
    "Template": "A string class for supporting $-substitutions."
  },
  "re2": {
    "findall": "Return a list of all non-overlapping matches in the string.\n\n    Each match is represented as a string or a tuple (when there are two ore\n    more groups). Empty matches are included in the result.",
    "finditer": "Yield all non-overlapping matches in the string.\n\n    For each match, the iterator returns a ``Match`` object.\n    Empty matches are included in the result.",
    "fullmatch": "Try to apply the pattern to the entire string, returning\n    a ``Match`` object, or ``None`` if no match was found.",
    "match": "Try to apply the pattern at the start of the string, returning\n    a ``Match`` object, or ``None`` if no match was found.",
    "search": "Scan through string looking for a match to the pattern, returning\n    a ``Match`` object or none if no match was found.",
    "split": "Split the source string by the occurrences of the pattern,\n    returning a list containing the resulting substrings.",
    "UNICODE": "An enumeration."
  }
}