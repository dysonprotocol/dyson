{
  "cosmos.auth.v1beta1/QueryAccount": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "address"
        ]
      }
    ],
    "module_name": "cosmos.auth.v1beta1",
    "name": "Account",
    "request_schema": {
      "$ref": "#/definitions/QueryAccountRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryAccountRequest": {
          "additionalProperties": false,
          "description": "QueryAccountRequest is the request type for the Query/Account RPC method.",
          "properties": {
            "address": {
              "description": "address defines the address to query for.",
              "type": "string"
            }
          },
          "title": "Query Account Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/auth/v1beta1/accounts/{address}",
    "service_name": "Query"
  },
  "cosmos.auth.v1beta1/QueryAccountAddressByID": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "id"
        ]
      }
    ],
    "module_name": "cosmos.auth.v1beta1",
    "name": "AccountAddressByID",
    "request_schema": {
      "$ref": "#/definitions/QueryAccountAddressByIDRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryAccountAddressByIDRequest": {
          "additionalProperties": false,
          "description": "QueryAccountAddressByIDRequest is the request type for AccountAddressByID rpc method Since: cosmos-sdk 0.46.2",
          "properties": {
            "id": {
              "description": "id is the account number of the address to be queried. This field should have been an uint64 (like all account numbers), and will be updated to uint64 in a future version of the auth query.",
              "type": "string"
            }
          },
          "title": "Query Account Address By ID Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/auth/v1beta1/address_by_id/{id}",
    "service_name": "Query"
  },
  "cosmos.auth.v1beta1/QueryAccounts": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "cosmos.auth.v1beta1",
    "name": "Accounts",
    "request_schema": {
      "$ref": "#/definitions/QueryAccountsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryAccountsRequest": {
          "additionalProperties": false,
          "description": "QueryAccountsRequest is the request type for the Query/Accounts RPC method. Since: cosmos-sdk 0.43",
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            }
          },
          "title": "Query Accounts Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/auth/v1beta1/accounts",
    "service_name": "Query"
  },
  "cosmos.auth.v1beta1/QueryAddressBytesToString": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "address_bytes"
        ]
      }
    ],
    "module_name": "cosmos.auth.v1beta1",
    "name": "AddressBytesToString",
    "request_schema": {
      "$ref": "#/definitions/AddressBytesToStringRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "AddressBytesToStringRequest": {
          "additionalProperties": false,
          "description": "AddressBytesToStringRequest is the request type for AddressString rpc method. Since: cosmos-sdk 0.46",
          "properties": {
            "address_bytes": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            }
          },
          "title": "Address Bytes To String Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/auth/v1beta1/bech32/{address_bytes}",
    "service_name": "Query"
  },
  "cosmos.auth.v1beta1/QueryAddressStringToBytes": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "address_string"
        ]
      }
    ],
    "module_name": "cosmos.auth.v1beta1",
    "name": "AddressStringToBytes",
    "request_schema": {
      "$ref": "#/definitions/AddressStringToBytesRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "AddressStringToBytesRequest": {
          "additionalProperties": false,
          "description": "AddressStringToBytesRequest is the request type for AccountBytes rpc method. Since: cosmos-sdk 0.46",
          "properties": {
            "address_string": {
              "type": "string"
            }
          },
          "title": "Address String To Bytes Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/auth/v1beta1/bech32/{address_string}",
    "service_name": "Query"
  },
  "cosmos.auth.v1beta1/QueryBech32Prefix": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "cosmos.auth.v1beta1",
    "name": "Bech32Prefix",
    "request_schema": {
      "$ref": "#/definitions/Bech32PrefixRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "Bech32PrefixRequest": {
          "additionalProperties": false,
          "description": "Bech32PrefixRequest is the request type for Bech32Prefix rpc method. Since: cosmos-sdk 0.46",
          "title": "Bech 32 Prefix Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/auth/v1beta1/bech32",
    "service_name": "Query"
  },
  "cosmos.auth.v1beta1/QueryModuleAccountByName": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "name"
        ]
      }
    ],
    "module_name": "cosmos.auth.v1beta1",
    "name": "ModuleAccountByName",
    "request_schema": {
      "$ref": "#/definitions/QueryModuleAccountByNameRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryModuleAccountByNameRequest": {
          "additionalProperties": false,
          "description": "QueryModuleAccountByNameRequest is the request type for the Query/ModuleAccountByName RPC method.",
          "properties": {
            "name": {
              "type": "string"
            }
          },
          "title": "Query Module Account By Name Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/auth/v1beta1/module_accounts/{name}",
    "service_name": "Query"
  },
  "cosmos.auth.v1beta1/QueryModuleAccounts": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "cosmos.auth.v1beta1",
    "name": "ModuleAccounts",
    "request_schema": {
      "$ref": "#/definitions/QueryModuleAccountsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryModuleAccountsRequest": {
          "additionalProperties": false,
          "description": "QueryModuleAccountsRequest is the request type for the Query/ModuleAccounts RPC method. Since: cosmos-sdk 0.46",
          "title": "Query Module Accounts Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/auth/v1beta1/module_accounts",
    "service_name": "Query"
  },
  "cosmos.auth.v1beta1/QueryParams": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "cosmos.auth.v1beta1",
    "name": "Params",
    "request_schema": {
      "$ref": "#/definitions/QueryParamsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryParamsRequest": {
          "additionalProperties": false,
          "description": "QueryParamsRequest is the request type for the Query/Params RPC method.",
          "title": "Query Params Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/auth/v1beta1/params",
    "service_name": "Query"
  },
  "cosmos.authz.v1beta1/QueryGranteeGrants": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "grantee"
        ]
      }
    ],
    "module_name": "cosmos.authz.v1beta1",
    "name": "GranteeGrants",
    "request_schema": {
      "$ref": "#/definitions/QueryGranteeGrantsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryGranteeGrantsRequest": {
          "additionalProperties": false,
          "description": "QueryGranteeGrantsRequest is the request type for the Query/IssuedGrants RPC method.",
          "properties": {
            "grantee": {
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an pagination for the request."
            }
          },
          "title": "Query Grantee Grants Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/authz/v1beta1/grants/grantee/{grantee}",
    "service_name": "Query"
  },
  "cosmos.authz.v1beta1/QueryGranterGrants": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "granter"
        ]
      }
    ],
    "module_name": "cosmos.authz.v1beta1",
    "name": "GranterGrants",
    "request_schema": {
      "$ref": "#/definitions/QueryGranterGrantsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryGranterGrantsRequest": {
          "additionalProperties": false,
          "description": "QueryGranterGrantsRequest is the request type for the Query/GranterGrants RPC method.",
          "properties": {
            "granter": {
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an pagination for the request."
            }
          },
          "title": "Query Granter Grants Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/authz/v1beta1/grants/granter/{granter}",
    "service_name": "Query"
  },
  "cosmos.authz.v1beta1/QueryGrants": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "cosmos.authz.v1beta1",
    "name": "Grants",
    "request_schema": {
      "$ref": "#/definitions/QueryGrantsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryGrantsRequest": {
          "additionalProperties": false,
          "description": "QueryGrantsRequest is the request type for the Query/Grants RPC method.",
          "properties": {
            "grantee": {
              "type": "string"
            },
            "granter": {
              "type": "string"
            },
            "msg_type_url": {
              "description": "Optional, msg_type_url, when set, will query only grants matching given msg type.",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an pagination for the request."
            }
          },
          "title": "Query Grants Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/authz/v1beta1/grants",
    "service_name": "Query"
  },
  "cosmos.authz.v1beta1/sendMsgExec": {
    "http_rules": null,
    "module_name": "cosmos.authz.v1beta1",
    "name": "Exec",
    "request_schema": {
      "$ref": "#/definitions/MsgExec",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgAccept": {
          "additionalProperties": false,
          "description": "Accept the name that was offered to you",
          "properties": {
            "name": {
              "description": "The name to accept",
              "type": "string"
            },
            "new_owner": {
              "description": "The owner address of the name",
              "type": "string"
            }
          },
          "title": "Msg Accept",
          "type": "object"
        },
        "MsgAcknowledgement": {
          "additionalProperties": false,
          "description": "MsgAcknowledgement receives incoming IBC acknowledgement",
          "properties": {
            "acknowledgement": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "packet": {
              "$ref": "#/definitions/ibc.core.channel.v1.Packet",
              "additionalProperties": false
            },
            "proof_acked": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Acknowledgement",
          "type": "object"
        },
        "MsgBeginRedelegate": {
          "additionalProperties": false,
          "description": "MsgBeginRedelegate defines a SDK message for performing a redelegation of coins from a delegator and source validator to a destination validator.",
          "properties": {
            "amount": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false
            },
            "delegator_address": {
              "type": "string"
            },
            "validator_dst_address": {
              "type": "string"
            },
            "validator_src_address": {
              "type": "string"
            }
          },
          "title": "Msg Begin Redelegate",
          "type": "object"
        },
        "MsgBurnCoins": {
          "additionalProperties": false,
          "properties": {
            "amount": {
              "description": "The amount of coins to burn, the owner must have enough coins to burn",
              "type": "string"
            },
            "owner": {
              "description": "The owner of the Dys name",
              "type": "string"
            }
          },
          "title": "Msg Burn Coins",
          "type": "object"
        },
        "MsgBurnNft": {
          "additionalProperties": false,
          "description": "Burn an NFT of the given class ID and NFT ID.",
          "properties": {
            "class_id": {
              "description": "the NFT Class ID",
              "type": "string"
            },
            "class_owner": {
              "description": "The owner of the NFT Class",
              "type": "string"
            },
            "id": {
              "description": "The ID of this NFT to burn. The owner must currently own this NFT to burn it.",
              "type": "string"
            }
          },
          "title": "Msg Burn Nft",
          "type": "object"
        },
        "MsgBuy": {
          "additionalProperties": false,
          "description": "All names have a listed price, this message allows you to buy the name at the listed price.",
          "properties": {
            "buyer": {
              "description": "The address of the buyer",
              "type": "string"
            },
            "name": {
              "description": "The name to buy",
              "type": "string"
            },
            "price": {
              "description": "Confirm the  price of the name is the same as the listed price.",
              "type": "string"
            }
          },
          "title": "Msg Buy",
          "type": "object"
        },
        "MsgCancelUnbondingDelegation": {
          "additionalProperties": false,
          "description": "MsgCancelUnbondingDelegation defines the SDK message for performing a cancel unbonding delegation for delegator Since: cosmos-sdk 0.46",
          "properties": {
            "amount": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false,
              "description": "amount is always less than or equal to unbonding delegation entry balance"
            },
            "creation_height": {
              "description": "creation_height is the height which the unbonding took place.",
              "type": "string"
            },
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Cancel Unbonding Delegation",
          "type": "object"
        },
        "MsgCancelUpgrade": {
          "additionalProperties": false,
          "description": "MsgCancelUpgrade is the Msg/CancelUpgrade request type. Since: cosmos-sdk 0.46",
          "properties": {
            "authority": {
              "description": "authority is the address of the governance account.",
              "type": "string"
            }
          },
          "title": "Msg Cancel Upgrade",
          "type": "object"
        },
        "MsgChannelCloseConfirm": {
          "additionalProperties": false,
          "description": "MsgChannelCloseConfirm defines a msg sent by a Relayer to Chain B to acknowledge the change of channel state to CLOSED on Chain A.",
          "properties": {
            "channel_id": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_init": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Close Confirm",
          "type": "object"
        },
        "MsgChannelCloseInit": {
          "additionalProperties": false,
          "description": "MsgChannelCloseInit defines a msg sent by a Relayer to Chain A to close a channel with Chain B.",
          "properties": {
            "channel_id": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Close Init",
          "type": "object"
        },
        "MsgChannelOpenAck": {
          "additionalProperties": false,
          "description": "MsgChannelOpenAck defines a msg sent by a Relayer to Chain A to acknowledge the change of channel state to TRYOPEN on Chain B.",
          "properties": {
            "channel_id": {
              "type": "string"
            },
            "counterparty_channel_id": {
              "type": "string"
            },
            "counterparty_version": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_try": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Open Ack",
          "type": "object"
        },
        "MsgChannelOpenConfirm": {
          "additionalProperties": false,
          "description": "MsgChannelOpenConfirm defines a msg sent by a Relayer to Chain B to acknowledge the change of channel state to OPEN on Chain A.",
          "properties": {
            "channel_id": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            },
            "proof_ack": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Open Confirm",
          "type": "object"
        },
        "MsgChannelOpenInit": {
          "additionalProperties": false,
          "description": "MsgChannelOpenInit defines an sdk.Msg to initialize a channel handshake. It is called by a relayer on Chain A.",
          "properties": {
            "channel": {
              "$ref": "#/definitions/ibc.core.channel.v1.Channel",
              "additionalProperties": false
            },
            "port_id": {
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Open Init",
          "type": "object"
        },
        "MsgChannelOpenTry": {
          "additionalProperties": false,
          "description": "MsgChannelOpenInit defines a msg sent by a Relayer to try to open a channel on Chain B. The version field within the Channel field has been deprecated. Its value will be ignored by core IBC.",
          "properties": {
            "channel": {
              "$ref": "#/definitions/ibc.core.channel.v1.Channel",
              "additionalProperties": false,
              "description": "NOTE: the version field within the channel has been deprecated. Its value will be ignored by core IBC."
            },
            "counterparty_version": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            },
            "previous_channel_id": {
              "description": "Deprecated: this field is unused. Crossing hello's are no longer supported in core IBC.",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_init": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Open Try",
          "type": "object"
        },
        "MsgConnectionOpenAck": {
          "additionalProperties": false,
          "description": "MsgConnectionOpenAck defines a msg sent by a Relayer to Chain A to acknowledge the change of connection state to TRYOPEN on Chain B.",
          "properties": {
            "client_state": {
              "additionalProperties": false,
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "connection_id": {
              "type": "string"
            },
            "consensus_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "counterparty_connection_id": {
              "type": "string"
            },
            "proof_client": {
              "binaryEncoding": "base64",
              "description": "proof of client state included in message",
              "format": "binary",
              "type": "string"
            },
            "proof_consensus": {
              "binaryEncoding": "base64",
              "description": "proof of client consensus state",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_try": {
              "binaryEncoding": "base64",
              "description": "proof of the initialization the connection on Chain B: `UNITIALIZED -> TRYOPEN`",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            },
            "version": {
              "$ref": "#/definitions/ibc.core.connection.v1.Version",
              "additionalProperties": false
            }
          },
          "title": "Msg Connection Open Ack",
          "type": "object"
        },
        "MsgConnectionOpenConfirm": {
          "additionalProperties": false,
          "description": "MsgConnectionOpenConfirm defines a msg sent by a Relayer to Chain B to acknowledge the change of connection state to OPEN on Chain A.",
          "properties": {
            "connection_id": {
              "type": "string"
            },
            "proof_ack": {
              "binaryEncoding": "base64",
              "description": "proof for the change of the connection state on Chain A: `INIT -> OPEN`",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Connection Open Confirm",
          "type": "object"
        },
        "MsgConnectionOpenInit": {
          "additionalProperties": false,
          "description": "MsgConnectionOpenInit defines the msg sent by an account on Chain A to initialize a connection with Chain B.",
          "properties": {
            "client_id": {
              "type": "string"
            },
            "counterparty": {
              "$ref": "#/definitions/ibc.core.connection.v1.Counterparty",
              "additionalProperties": false
            },
            "delay_period": {
              "type": "string"
            },
            "signer": {
              "type": "string"
            },
            "version": {
              "$ref": "#/definitions/ibc.core.connection.v1.Version",
              "additionalProperties": false
            }
          },
          "title": "Msg Connection Open Init",
          "type": "object"
        },
        "MsgConnectionOpenTry": {
          "additionalProperties": false,
          "description": "MsgConnectionOpenTry defines a msg sent by a Relayer to try to open a connection on Chain B.",
          "properties": {
            "client_id": {
              "type": "string"
            },
            "client_state": {
              "additionalProperties": false,
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "consensus_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "counterparty": {
              "$ref": "#/definitions/ibc.core.connection.v1.Counterparty",
              "additionalProperties": false
            },
            "counterparty_versions": {
              "items": {
                "$ref": "#/definitions/ibc.core.connection.v1.Version"
              },
              "type": "array"
            },
            "delay_period": {
              "type": "string"
            },
            "previous_connection_id": {
              "description": "Deprecated: this field is unused. Crossing hellos are no longer supported in core IBC.",
              "type": "string"
            },
            "proof_client": {
              "binaryEncoding": "base64",
              "description": "proof of client state included in message",
              "format": "binary",
              "type": "string"
            },
            "proof_consensus": {
              "binaryEncoding": "base64",
              "description": "proof of client consensus state",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_init": {
              "binaryEncoding": "base64",
              "description": "proof of the initialization the connection on Chain A: `UNITIALIZED -> INIT`",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Connection Open Try",
          "type": "object"
        },
        "MsgCreateClient": {
          "additionalProperties": false,
          "description": "MsgCreateClient defines a message to create an IBC client",
          "properties": {
            "client_state": {
              "additionalProperties": false,
              "description": "light client state",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "consensus_state": {
              "additionalProperties": false,
              "description": "consensus state associated with the client that corresponds to a given height.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "signer": {
              "description": "signer address",
              "type": "string"
            }
          },
          "title": "Msg Create Client",
          "type": "object"
        },
        "MsgCreateGroup": {
          "additionalProperties": false,
          "description": "Groups  MsgCreateGroup is the Msg/CreateGroup request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "members": {
              "description": "members defines the group members.",
              "items": {
                "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
              },
              "type": "array"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata to attached to the group.",
              "type": "string"
            }
          },
          "title": "Groups",
          "type": "object"
        },
        "MsgCreateGroupPolicy": {
          "additionalProperties": false,
          "description": "Group Policies  MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "decision_policy": {
              "additionalProperties": false,
              "description": "decision_policy specifies the group policy's decision policy.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata attached to the group policy.",
              "type": "string"
            }
          },
          "title": "Group Policies",
          "type": "object"
        },
        "MsgCreateGroupWithPolicy": {
          "additionalProperties": false,
          "description": "MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group and group policy admin.",
              "type": "string"
            },
            "decision_policy": {
              "additionalProperties": false,
              "description": "decision_policy specifies the group policy's decision policy.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "group_metadata": {
              "description": "group_metadata is any arbitrary metadata attached to the group.",
              "type": "string"
            },
            "group_policy_as_admin": {
              "description": "group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group and group policy admin.",
              "type": "boolean"
            },
            "group_policy_metadata": {
              "description": "group_policy_metadata is any arbitrary metadata attached to the group policy.",
              "type": "string"
            },
            "members": {
              "description": "members defines the group members.",
              "items": {
                "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
              },
              "type": "array"
            }
          },
          "title": "Msg Create Group With Policy",
          "type": "object"
        },
        "MsgCreatePeriodicVestingAccount": {
          "additionalProperties": false,
          "description": "MsgCreateVestingAccount defines a message that enables creating a vesting account. Since: cosmos-sdk 0.46",
          "properties": {
            "from_address": {
              "type": "string"
            },
            "start_time": {
              "type": "string"
            },
            "to_address": {
              "type": "string"
            },
            "vesting_periods": {
              "items": {
                "$ref": "#/definitions/cosmos.vesting.v1beta1.Period"
              },
              "type": "array"
            }
          },
          "title": "Msg Create Periodic Vesting Account",
          "type": "object"
        },
        "MsgCreatePermanentLockedAccount": {
          "additionalProperties": false,
          "description": "MsgCreatePermanentLockedAccount defines a message that enables creating a permanent locked account. Since: cosmos-sdk 0.46",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "from_address": {
              "type": "string"
            },
            "to_address": {
              "type": "string"
            }
          },
          "title": "Msg Create Permanent Locked Account",
          "type": "object"
        },
        "MsgCreateScheduledRun": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            },
            "gas": {
              "type": "string"
            },
            "height": {
              "type": "string"
            },
            "msg": {
              "$ref": "#/definitions/dyson.MsgRun",
              "additionalProperties": false
            }
          },
          "title": "Msg Create Scheduled Run",
          "type": "object"
        },
        "MsgCreateStorage": {
          "additionalProperties": false,
          "description": "Create a new storage of arbitrary text",
          "properties": {
            "creator": {
              "description": "The address signing this transaction",
              "type": "string"
            },
            "data": {
              "description": "data to store at this index",
              "type": "string"
            },
            "force": {
              "description": "If true, force will always store the data at this address regardless of already existing storage",
              "type": "boolean"
            },
            "index": {
              "description": "Name of the Storage, must be prefixed with the creators address (for example: \"dys..1a3/some_name\")",
              "type": "string"
            }
          },
          "title": "Msg Create Storage",
          "type": "object"
        },
        "MsgCreateValidator": {
          "additionalProperties": false,
          "description": "MsgCreateValidator defines a SDK message for creating a new validator.",
          "properties": {
            "commission": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.CommissionRates",
              "additionalProperties": false
            },
            "delegator_address": {
              "type": "string"
            },
            "description": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.Description",
              "additionalProperties": false
            },
            "min_self_delegation": {
              "type": "string"
            },
            "pubkey": {
              "additionalProperties": false,
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "validator_address": {
              "type": "string"
            },
            "value": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false
            }
          },
          "title": "Msg Create Validator",
          "type": "object"
        },
        "MsgCreateVestingAccount": {
          "additionalProperties": false,
          "description": "MsgCreateVestingAccount defines a message that enables creating a vesting account.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "delayed": {
              "type": "boolean"
            },
            "end_time": {
              "type": "string"
            },
            "from_address": {
              "type": "string"
            },
            "to_address": {
              "type": "string"
            }
          },
          "title": "Msg Create Vesting Account",
          "type": "object"
        },
        "MsgDelegate": {
          "additionalProperties": false,
          "description": "MsgDelegate defines a SDK message for performing a delegation of coins from a delegator to a validator.",
          "properties": {
            "amount": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false
            },
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Delegate",
          "type": "object"
        },
        "MsgDeleteName": {
          "additionalProperties": false,
          "description": "Delete the Dyson Protocol name",
          "properties": {
            "name": {
              "description": "The name to delete",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            }
          },
          "title": "Msg Delete Name",
          "type": "object"
        },
        "MsgDeleteScheduledRun": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            },
            "index": {
              "type": "string"
            }
          },
          "title": "Msg Delete Scheduled Run",
          "type": "object"
        },
        "MsgDeleteScript": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            }
          },
          "title": "Msg Delete Script",
          "type": "object"
        },
        "MsgDeleteStorage": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            },
            "index": {
              "type": "string"
            }
          },
          "title": "Msg Delete Storage",
          "type": "object"
        },
        "MsgDeployAutonomousScript": {
          "additionalProperties": false,
          "description": "Deploy an Autonomous Script at a new address",
          "properties": {
            "code": {
              "format": "python",
              "type": "string"
            },
            "creator": {
              "type": "string"
            }
          },
          "title": "Msg Deploy Autonomous Script",
          "type": "object"
        },
        "MsgDeposit": {
          "additionalProperties": false,
          "description": "MsgDeposit defines a message to submit a deposit to an existing proposal.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "depositor": {
              "type": "string"
            },
            "proposal_id": {
              "type": "string"
            }
          },
          "title": "Msg Deposit",
          "type": "object"
        },
        "MsgEditValidator": {
          "additionalProperties": false,
          "description": "MsgEditValidator defines a SDK message for editing an existing validator.",
          "properties": {
            "commission_rate": {
              "description": "We pass a reference to the new commission rate and min self delegation as it's not mandatory to update. If not updated, the deserialized rate will be zero with no way to distinguish if an update was intended. REF: #2373",
              "type": "string"
            },
            "description": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.Description",
              "additionalProperties": false
            },
            "min_self_delegation": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Edit Validator",
          "type": "object"
        },
        "MsgExec": {
          "additionalProperties": false,
          "description": "MsgExec attempts to execute the provided messages using authorizations granted to the grantee. Each message should have only one signer corresponding to the granter of the authorization.",
          "properties": {
            "grantee": {
              "type": "string"
            },
            "msgs": {
              "description": "Authorization Msg requests to execute. Each msg must implement Authorization interface The x/authz will try to find a grant matching (msg.signers[0], grantee, MsgTypeURL(msg)) triple and validate it.",
              "items": {
                "oneOf": [
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgExec"
                      },
                      "type_url": {
                        "default": "/cosmos.authz.v1beta1.MsgExec",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.authz.v1beta1.MsgExec"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.authz.v1beta1.MsgExec",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgGrant"
                      },
                      "type_url": {
                        "default": "/cosmos.authz.v1beta1.MsgGrant",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.authz.v1beta1.MsgGrant"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.authz.v1beta1.MsgGrant",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgRevoke"
                      },
                      "type_url": {
                        "default": "/cosmos.authz.v1beta1.MsgRevoke",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.authz.v1beta1.MsgRevoke"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.authz.v1beta1.MsgRevoke",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgMultiSend"
                      },
                      "type_url": {
                        "default": "/cosmos.bank.v1beta1.MsgMultiSend",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.bank.v1beta1.MsgMultiSend"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.bank.v1beta1.MsgMultiSend",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSend"
                      },
                      "type_url": {
                        "default": "/cosmos.bank.v1beta1.MsgSend",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.bank.v1beta1.MsgSend"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.bank.v1beta1.MsgSend",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgVerifyInvariant"
                      },
                      "type_url": {
                        "default": "/cosmos.crisis.v1beta1.MsgVerifyInvariant",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.crisis.v1beta1.MsgVerifyInvariant"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.crisis.v1beta1.MsgVerifyInvariant",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgFundCommunityPool"
                      },
                      "type_url": {
                        "default": "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.distribution.v1beta1.MsgFundCommunityPool"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.distribution.v1beta1.MsgFundCommunityPool",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSetWithdrawAddress"
                      },
                      "type_url": {
                        "default": "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgWithdrawDelegatorReward"
                      },
                      "type_url": {
                        "default": "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgWithdrawValidatorCommission"
                      },
                      "type_url": {
                        "default": "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSubmitEvidence"
                      },
                      "type_url": {
                        "default": "/cosmos.evidence.v1beta1.MsgSubmitEvidence",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.evidence.v1beta1.MsgSubmitEvidence"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.evidence.v1beta1.MsgSubmitEvidence",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgGrantAllowance"
                      },
                      "type_url": {
                        "default": "/cosmos.feegrant.v1beta1.MsgGrantAllowance",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.feegrant.v1beta1.MsgGrantAllowance"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.feegrant.v1beta1.MsgGrantAllowance",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgRevokeAllowance"
                      },
                      "type_url": {
                        "default": "/cosmos.feegrant.v1beta1.MsgRevokeAllowance",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.feegrant.v1beta1.MsgRevokeAllowance"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.feegrant.v1beta1.MsgRevokeAllowance",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeposit"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1.MsgDeposit",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1.MsgDeposit"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1.MsgDeposit",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgExecLegacyContent"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1.MsgExecLegacyContent",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1.MsgExecLegacyContent"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1.MsgExecLegacyContent",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSubmitProposal"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1.MsgSubmitProposal",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1.MsgSubmitProposal"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1.MsgSubmitProposal",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgVote"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1.MsgVote",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1.MsgVote"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1.MsgVote",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgVoteWeighted"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1.MsgVoteWeighted",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1.MsgVoteWeighted"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1.MsgVoteWeighted",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeposit"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1beta1.MsgDeposit",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1beta1.MsgDeposit"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1beta1.MsgDeposit",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSubmitProposal"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1beta1.MsgSubmitProposal",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1beta1.MsgSubmitProposal"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1beta1.MsgSubmitProposal",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgVote"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1beta1.MsgVote",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1beta1.MsgVote"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1beta1.MsgVote",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgVoteWeighted"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1beta1.MsgVoteWeighted",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1beta1.MsgVoteWeighted"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1beta1.MsgVoteWeighted",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateGroup"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgCreateGroup",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgCreateGroup"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgCreateGroup",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateGroupPolicy"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgCreateGroupPolicy",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgCreateGroupPolicy"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgCreateGroupPolicy",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateGroupWithPolicy"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgCreateGroupWithPolicy",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgCreateGroupWithPolicy"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgCreateGroupWithPolicy",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgExec"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgExec",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgExec"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgExec",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgLeaveGroup"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgLeaveGroup",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgLeaveGroup"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgLeaveGroup",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSubmitProposal"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgSubmitProposal",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgSubmitProposal"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgSubmitProposal",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateGroupAdmin"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgUpdateGroupAdmin",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgUpdateGroupAdmin"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgUpdateGroupAdmin",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateGroupMembers"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgUpdateGroupMembers",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgUpdateGroupMembers"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgUpdateGroupMembers",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateGroupMetadata"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgUpdateGroupMetadata",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgUpdateGroupMetadata"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgUpdateGroupMetadata",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateGroupPolicyAdmin"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateGroupPolicyDecisionPolicy"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateGroupPolicyMetadata"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgVote"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgVote",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgVote"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgVote",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgWithdrawProposal"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgWithdrawProposal",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgWithdrawProposal"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgWithdrawProposal",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSend"
                      },
                      "type_url": {
                        "default": "/cosmos.nft.v1beta1.MsgSend",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.nft.v1beta1.MsgSend"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.nft.v1beta1.MsgSend",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUnjail"
                      },
                      "type_url": {
                        "default": "/cosmos.slashing.v1beta1.MsgUnjail",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.slashing.v1beta1.MsgUnjail"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.slashing.v1beta1.MsgUnjail",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgBeginRedelegate"
                      },
                      "type_url": {
                        "default": "/cosmos.staking.v1beta1.MsgBeginRedelegate",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.staking.v1beta1.MsgBeginRedelegate"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.staking.v1beta1.MsgBeginRedelegate",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCancelUnbondingDelegation"
                      },
                      "type_url": {
                        "default": "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateValidator"
                      },
                      "type_url": {
                        "default": "/cosmos.staking.v1beta1.MsgCreateValidator",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.staking.v1beta1.MsgCreateValidator"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.staking.v1beta1.MsgCreateValidator",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDelegate"
                      },
                      "type_url": {
                        "default": "/cosmos.staking.v1beta1.MsgDelegate",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.staking.v1beta1.MsgDelegate"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.staking.v1beta1.MsgDelegate",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgEditValidator"
                      },
                      "type_url": {
                        "default": "/cosmos.staking.v1beta1.MsgEditValidator",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.staking.v1beta1.MsgEditValidator"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.staking.v1beta1.MsgEditValidator",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUndelegate"
                      },
                      "type_url": {
                        "default": "/cosmos.staking.v1beta1.MsgUndelegate",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.staking.v1beta1.MsgUndelegate"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.staking.v1beta1.MsgUndelegate",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCancelUpgrade"
                      },
                      "type_url": {
                        "default": "/cosmos.upgrade.v1beta1.MsgCancelUpgrade",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.upgrade.v1beta1.MsgCancelUpgrade"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.upgrade.v1beta1.MsgCancelUpgrade",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSoftwareUpgrade"
                      },
                      "type_url": {
                        "default": "/cosmos.upgrade.v1beta1.MsgSoftwareUpgrade",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.upgrade.v1beta1.MsgSoftwareUpgrade"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.upgrade.v1beta1.MsgSoftwareUpgrade",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreatePeriodicVestingAccount"
                      },
                      "type_url": {
                        "default": "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreatePermanentLockedAccount"
                      },
                      "type_url": {
                        "default": "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateVestingAccount"
                      },
                      "type_url": {
                        "default": "/cosmos.vesting.v1beta1.MsgCreateVestingAccount",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.vesting.v1beta1.MsgCreateVestingAccount"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.vesting.v1beta1.MsgCreateVestingAccount",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateScheduledRun"
                      },
                      "type_url": {
                        "default": "/dyson.MsgCreateScheduledRun",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgCreateScheduledRun"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgCreateScheduledRun",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateStorage"
                      },
                      "type_url": {
                        "default": "/dyson.MsgCreateStorage",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgCreateStorage"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgCreateStorage",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeleteScheduledRun"
                      },
                      "type_url": {
                        "default": "/dyson.MsgDeleteScheduledRun",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgDeleteScheduledRun"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgDeleteScheduledRun",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeleteScript"
                      },
                      "type_url": {
                        "default": "/dyson.MsgDeleteScript",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgDeleteScript"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgDeleteScript",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeleteStorage"
                      },
                      "type_url": {
                        "default": "/dyson.MsgDeleteStorage",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgDeleteStorage"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgDeleteStorage",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeployAutonomousScript"
                      },
                      "type_url": {
                        "default": "/dyson.MsgDeployAutonomousScript",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgDeployAutonomousScript"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgDeployAutonomousScript",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgRun"
                      },
                      "type_url": {
                        "default": "/dyson.MsgRun",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgRun"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgRun",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateScheduledRun"
                      },
                      "type_url": {
                        "default": "/dyson.MsgUpdateScheduledRun",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgUpdateScheduledRun"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgUpdateScheduledRun",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateScript"
                      },
                      "type_url": {
                        "default": "/dyson.MsgUpdateScript",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgUpdateScript"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgUpdateScript",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateStorage"
                      },
                      "type_url": {
                        "default": "/dyson.MsgUpdateStorage",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgUpdateStorage"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgUpdateStorage",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgRegisterInterchainAccount"
                      },
                      "type_url": {
                        "default": "/ibc.applications.interchain_accounts.controller.v1.MsgRegisterInterchainAccount",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.applications.interchain_accounts.controller.v1.MsgRegisterInterchainAccount"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.applications.interchain_accounts.controller.v1.MsgRegisterInterchainAccount",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSendTx"
                      },
                      "type_url": {
                        "default": "/ibc.applications.interchain_accounts.controller.v1.MsgSendTx",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.applications.interchain_accounts.controller.v1.MsgSendTx"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.applications.interchain_accounts.controller.v1.MsgSendTx",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgTransfer"
                      },
                      "type_url": {
                        "default": "/ibc.applications.transfer.v1.MsgTransfer",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.applications.transfer.v1.MsgTransfer"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.applications.transfer.v1.MsgTransfer",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgAcknowledgement"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgAcknowledgement",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgAcknowledgement"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgAcknowledgement",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgChannelCloseConfirm"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgChannelCloseConfirm",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgChannelCloseConfirm"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgChannelCloseConfirm",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgChannelCloseInit"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgChannelCloseInit",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgChannelCloseInit"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgChannelCloseInit",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgChannelOpenAck"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgChannelOpenAck",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgChannelOpenAck"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgChannelOpenAck",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgChannelOpenConfirm"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgChannelOpenConfirm",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgChannelOpenConfirm"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgChannelOpenConfirm",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgChannelOpenInit"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgChannelOpenInit",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgChannelOpenInit"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgChannelOpenInit",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgChannelOpenTry"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgChannelOpenTry",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgChannelOpenTry"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgChannelOpenTry",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgRecvPacket"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgRecvPacket",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgRecvPacket"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgRecvPacket",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgTimeout"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgTimeout",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgTimeout"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgTimeout",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgTimeoutOnClose"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgTimeoutOnClose",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgTimeoutOnClose"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgTimeoutOnClose",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateClient"
                      },
                      "type_url": {
                        "default": "/ibc.core.client.v1.MsgCreateClient",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.client.v1.MsgCreateClient"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.client.v1.MsgCreateClient",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSubmitMisbehaviour"
                      },
                      "type_url": {
                        "default": "/ibc.core.client.v1.MsgSubmitMisbehaviour",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.client.v1.MsgSubmitMisbehaviour"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.client.v1.MsgSubmitMisbehaviour",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateClient"
                      },
                      "type_url": {
                        "default": "/ibc.core.client.v1.MsgUpdateClient",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.client.v1.MsgUpdateClient"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.client.v1.MsgUpdateClient",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpgradeClient"
                      },
                      "type_url": {
                        "default": "/ibc.core.client.v1.MsgUpgradeClient",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.client.v1.MsgUpgradeClient"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.client.v1.MsgUpgradeClient",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgConnectionOpenAck"
                      },
                      "type_url": {
                        "default": "/ibc.core.connection.v1.MsgConnectionOpenAck",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.connection.v1.MsgConnectionOpenAck"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.connection.v1.MsgConnectionOpenAck",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgConnectionOpenConfirm"
                      },
                      "type_url": {
                        "default": "/ibc.core.connection.v1.MsgConnectionOpenConfirm",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.connection.v1.MsgConnectionOpenConfirm"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.connection.v1.MsgConnectionOpenConfirm",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgConnectionOpenInit"
                      },
                      "type_url": {
                        "default": "/ibc.core.connection.v1.MsgConnectionOpenInit",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.connection.v1.MsgConnectionOpenInit"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.connection.v1.MsgConnectionOpenInit",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgConnectionOpenTry"
                      },
                      "type_url": {
                        "default": "/ibc.core.connection.v1.MsgConnectionOpenTry",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.connection.v1.MsgConnectionOpenTry"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.connection.v1.MsgConnectionOpenTry",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgAccept"
                      },
                      "type_url": {
                        "default": "/names.MsgAccept",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgAccept"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgAccept",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgBurnCoins"
                      },
                      "type_url": {
                        "default": "/names.MsgBurnCoins",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgBurnCoins"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgBurnCoins",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgBurnNft"
                      },
                      "type_url": {
                        "default": "/names.MsgBurnNft",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgBurnNft"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgBurnNft",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgBuy"
                      },
                      "type_url": {
                        "default": "/names.MsgBuy",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgBuy"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgBuy",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeleteName"
                      },
                      "type_url": {
                        "default": "/names.MsgDeleteName",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgDeleteName"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgDeleteName",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgMintCoins"
                      },
                      "type_url": {
                        "default": "/names.MsgMintCoins",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgMintCoins"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgMintCoins",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgMintNft"
                      },
                      "type_url": {
                        "default": "/names.MsgMintNft",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgMintNft"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgMintNft",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgOfferTo"
                      },
                      "type_url": {
                        "default": "/names.MsgOfferTo",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgOfferTo"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgOfferTo",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgRegister"
                      },
                      "type_url": {
                        "default": "/names.MsgRegister",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgRegister"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgRegister",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgReveal"
                      },
                      "type_url": {
                        "default": "/names.MsgReveal",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgReveal"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgReveal",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSetNftClass"
                      },
                      "type_url": {
                        "default": "/names.MsgSetNftClass",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgSetNftClass"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgSetNftClass",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSetPriceAndExtend"
                      },
                      "type_url": {
                        "default": "/names.MsgSetPriceAndExtend",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgSetPriceAndExtend"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgSetPriceAndExtend",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateName"
                      },
                      "type_url": {
                        "default": "/names.MsgUpdateName",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgUpdateName"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgUpdateName",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateNft"
                      },
                      "type_url": {
                        "default": "/names.MsgUpdateNft",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgUpdateNft"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgUpdateNft",
                    "type": "object"
                  }
                ]
              },
              "type": "array"
            }
          },
          "title": "Msg Exec",
          "type": "object"
        },
        "MsgExecLegacyContent": {
          "additionalProperties": false,
          "description": "MsgExecLegacyContent is used to wrap the legacy content field into a message. This ensures backwards compatibility with v1beta1.MsgSubmitProposal.",
          "properties": {
            "authority": {
              "description": "authority must be the gov module address.",
              "type": "string"
            },
            "content": {
              "additionalProperties": false,
              "description": "content is the proposal's content.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "title": "Msg Exec Legacy Content",
          "type": "object"
        },
        "MsgFundCommunityPool": {
          "additionalProperties": false,
          "description": "MsgFundCommunityPool allows an account to directly fund the community pool.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "depositor": {
              "type": "string"
            }
          },
          "title": "Msg Fund Community Pool",
          "type": "object"
        },
        "MsgGrant": {
          "additionalProperties": false,
          "description": "MsgGrant is a request type for Grant method. It declares authorization to the grantee on behalf of the granter with the provided expiration time.",
          "properties": {
            "grant": {
              "$ref": "#/definitions/cosmos.authz.v1beta1.Grant",
              "additionalProperties": false
            },
            "grantee": {
              "type": "string"
            },
            "granter": {
              "type": "string"
            }
          },
          "title": "Msg Grant",
          "type": "object"
        },
        "MsgGrantAllowance": {
          "additionalProperties": false,
          "description": "MsgGrantAllowance adds permission for Grantee to spend up to Allowance of fees from the account of Granter.",
          "properties": {
            "allowance": {
              "additionalProperties": false,
              "description": "allowance can be any of basic, periodic, allowed fee allowance.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "grantee": {
              "description": "grantee is the address of the user being granted an allowance of another user's funds.",
              "type": "string"
            },
            "granter": {
              "description": "granter is the address of the user granting an allowance of their funds.",
              "type": "string"
            }
          },
          "title": "Msg Grant Allowance",
          "type": "object"
        },
        "MsgLeaveGroup": {
          "additionalProperties": false,
          "description": "MsgLeaveGroup is the Msg/LeaveGroup request type.",
          "properties": {
            "address": {
              "description": "address is the account address of the group member.",
              "type": "string"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            }
          },
          "title": "Msg Leave Group",
          "type": "object"
        },
        "MsgMintCoins": {
          "additionalProperties": false,
          "description": "Mint coins with a denom of a name or subname. For example if you own the name \"example.dys\" you can mint coins with the denom \"example.dys\" or \"subname.example.dys\"",
          "properties": {
            "amount": {
              "description": "The amount of coins to mint in the format \"[amount] [denom]\".   Each coin costs 1 gas.",
              "type": "string"
            },
            "owner": {
              "description": "The owner of the Dys name",
              "type": "string"
            }
          },
          "title": "Msg Mint Coins",
          "type": "object"
        },
        "MsgMintNft": {
          "additionalProperties": false,
          "description": "Mint an NFT with the given class ID and NFT ID. The NFT ID is unique to the class ID.",
          "properties": {
            "class_id": {
              "description": "the NFT Class ID",
              "type": "string"
            },
            "class_owner": {
              "description": "The owner of the Dys name",
              "type": "string"
            },
            "id": {
              "description": "The ID of this NFT, must be unique to the class ID",
              "type": "string"
            },
            "uri": {
              "description": "The URI of the NFT (optional)",
              "type": "string"
            },
            "uri_hash": {
              "description": "The URI hash of the NFT (optional)",
              "type": "string"
            }
          },
          "title": "Msg Mint Nft",
          "type": "object"
        },
        "MsgMultiSend": {
          "additionalProperties": false,
          "description": "MsgMultiSend represents an arbitrary multi-in, multi-out send message.",
          "properties": {
            "inputs": {
              "items": {
                "$ref": "#/definitions/cosmos.bank.v1beta1.Input"
              },
              "type": "array"
            },
            "outputs": {
              "items": {
                "$ref": "#/definitions/cosmos.bank.v1beta1.Output"
              },
              "type": "array"
            }
          },
          "title": "Msg Multi Send",
          "type": "object"
        },
        "MsgOfferTo": {
          "additionalProperties": false,
          "description": "Offer the name to a new owner",
          "properties": {
            "name": {
              "description": "The name to offer",
              "type": "string"
            },
            "new_owner": {
              "description": "The address to offer the name to. They can take ownership of the name with the Accept message",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            }
          },
          "title": "Msg Offer To",
          "type": "object"
        },
        "MsgRecvPacket": {
          "additionalProperties": false,
          "description": "MsgRecvPacket receives incoming IBC packet",
          "properties": {
            "packet": {
              "$ref": "#/definitions/ibc.core.channel.v1.Packet",
              "additionalProperties": false
            },
            "proof_commitment": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Recv Packet",
          "type": "object"
        },
        "MsgRegister": {
          "additionalProperties": false,
          "properties": {
            "auto_renew": {
              "description": "Should the name be automatically renewed",
              "type": "boolean"
            },
            "commit": {
              "description": "The Shake256(owner+name+salt) hexdigest",
              "type": "string"
            },
            "owner": {
              "description": "Address of the owner",
              "type": "string"
            },
            "price": {
              "description": "The price that this name is valued at and can be purchased for example 100dys. The yearly fee (31,536,000 blocks) is 1% of this price.",
              "type": "string"
            }
          },
          "title": "Msg Register",
          "type": "object"
        },
        "MsgRegisterInterchainAccount": {
          "additionalProperties": false,
          "description": "MsgRegisterInterchainAccount defines the payload for Msg/MsgRegisterInterchainAccount",
          "properties": {
            "connection_id": {
              "type": "string"
            },
            "owner": {
              "type": "string"
            },
            "version": {
              "type": "string"
            }
          },
          "title": "Msg Register Interchain Account",
          "type": "object"
        },
        "MsgReveal": {
          "additionalProperties": false,
          "description": "Reveal the name that was committed to with the Register message",
          "properties": {
            "name": {
              "description": "The name to reveal",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            },
            "salt": {
              "description": "The salt that was used to commit to the name",
              "type": "string"
            }
          },
          "title": "Msg Reveal",
          "type": "object"
        },
        "MsgRevoke": {
          "additionalProperties": false,
          "description": "MsgRevoke revokes any authorization with the provided sdk.Msg type on the granter's account with that has been granted to the grantee.",
          "properties": {
            "grantee": {
              "type": "string"
            },
            "granter": {
              "type": "string"
            },
            "msg_type_url": {
              "type": "string"
            }
          },
          "title": "Msg Revoke",
          "type": "object"
        },
        "MsgRevokeAllowance": {
          "additionalProperties": false,
          "description": "MsgRevokeAllowance removes any existing Allowance from Granter to Grantee.",
          "properties": {
            "grantee": {
              "description": "grantee is the address of the user being granted an allowance of another user's funds.",
              "type": "string"
            },
            "granter": {
              "description": "granter is the address of the user granting an allowance of their funds.",
              "type": "string"
            }
          },
          "title": "Msg Revoke Allowance",
          "type": "object"
        },
        "MsgRun": {
          "additionalProperties": false,
          "description": "MsgRun runs a script at a specific address",
          "properties": {
            "address": {
              "description": "Dys address of the script to call",
              "type": "string"
            },
            "args": {
              "description": "Optional args to call the function with",
              "type": "string"
            },
            "coins": {
              "description": "Optional comma seperated list of coins to send the script (for example \"123dys,456token\") this entire amount will be sent to the script",
              "type": "string"
            },
            "creator": {
              "description": "The account sending this transaction",
              "type": "string"
            },
            "extra_lines": {
              "description": "Optional extra source code to append to the end of the script before running. Only available to the script address itself.",
              "type": "string"
            },
            "function_name": {
              "description": "Optional function to call",
              "type": "string"
            },
            "kwargs": {
              "description": "Optional kwargs to run",
              "type": "string"
            },
            "nfts": {
              "description": "Optional NFTs to send the script, formatted [class_id]/[id], [class_id]/[id] (for example \"example.dys/123, example.dys/456\")",
              "type": "string"
            }
          },
          "title": "Msg Run",
          "type": "object"
        },
        "MsgSend": {
          "additionalProperties": false,
          "description": "MsgSend represents a message to send a nft from one account to another account.",
          "properties": {
            "class_id": {
              "description": "class_id defines the unique identifier of the nft classification, similar to the contract address of ERC721",
              "type": "string"
            },
            "id": {
              "description": "id defines the unique identification of nft",
              "type": "string"
            },
            "receiver": {
              "description": "receiver is the receiver address of nft",
              "type": "string"
            },
            "sender": {
              "description": "sender is the address of the owner of nft",
              "type": "string"
            }
          },
          "title": "Msg Send",
          "type": "object"
        },
        "MsgSendTx": {
          "additionalProperties": false,
          "description": "MsgSendTx defines the payload for Msg/SendTx",
          "properties": {
            "connection_id": {
              "type": "string"
            },
            "owner": {
              "type": "string"
            },
            "packet_data": {
              "$ref": "#/definitions/ibc.applications.interchain_accounts.v1.InterchainAccountPacketData",
              "additionalProperties": false
            },
            "relative_timeout": {
              "description": "Relative timeout timestamp provided will be added to the current block time during transaction execution. The timeout timestamp must be non-zero.",
              "type": "string"
            }
          },
          "title": "Msg Send Tx",
          "type": "object"
        },
        "MsgSetNftClass": {
          "additionalProperties": false,
          "description": "Create or update an NFT class. The NFT class is identified by the Dys name of the class ID.",
          "properties": {
            "description": {
              "description": "The  description of the NFT class (optional)",
              "type": "string"
            },
            "id": {
              "description": "the ID is the Dys name or subname of the NFT class. For example if you own the name \"example.dys\" you can create an NFT class with the ID \"example.dys\" or \"subname.example.dys\"",
              "type": "string"
            },
            "name": {
              "description": "More descriptive name of the NFT class (optional)",
              "type": "string"
            },
            "owner": {
              "description": "The owner of the Dys name of the NFT class ID",
              "type": "string"
            },
            "symbol": {
              "description": "The symbol of the NFT class (optional)",
              "type": "string"
            },
            "uri": {
              "description": "The URI of the NFT class (optional)",
              "type": "string"
            },
            "uri_hash": {
              "description": "The URI hash of the NFT class (optional)",
              "type": "string"
            }
          },
          "title": "Msg Set Nft Class",
          "type": "object"
        },
        "MsgSetPriceAndExtend": {
          "additionalProperties": false,
          "description": "Set the price of the name and extend the expiration height",
          "properties": {
            "name": {
              "description": "The name to set the price for",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            },
            "price": {
              "description": "The new price that this name is valued at and can be purchased for example 100dys. The fee is 1% of this price and will be paid by the owner now. The expiration height is extended by 31,536,000 blocks.",
              "type": "string"
            }
          },
          "title": "Msg Set Price And Extend",
          "type": "object"
        },
        "MsgSetWithdrawAddress": {
          "additionalProperties": false,
          "description": "MsgSetWithdrawAddress sets the withdraw address for a delegator (or validator self-delegation).",
          "properties": {
            "delegator_address": {
              "type": "string"
            },
            "withdraw_address": {
              "type": "string"
            }
          },
          "title": "Msg Set Withdraw Address",
          "type": "object"
        },
        "MsgSoftwareUpgrade": {
          "additionalProperties": false,
          "description": "MsgSoftwareUpgrade is the Msg/SoftwareUpgrade request type. Since: cosmos-sdk 0.46",
          "properties": {
            "authority": {
              "description": "authority is the address of the governance account.",
              "type": "string"
            },
            "plan": {
              "$ref": "#/definitions/cosmos.upgrade.v1beta1.Plan",
              "additionalProperties": false,
              "description": "plan is the upgrade plan."
            }
          },
          "title": "Msg Software Upgrade",
          "type": "object"
        },
        "MsgSubmitEvidence": {
          "additionalProperties": false,
          "description": "MsgSubmitEvidence represents a message that supports submitting arbitrary Evidence of misbehavior such as equivocation or counterfactual signing.",
          "properties": {
            "evidence": {
              "additionalProperties": false,
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "submitter": {
              "type": "string"
            }
          },
          "title": "Msg Submit Evidence",
          "type": "object"
        },
        "MsgSubmitMisbehaviour": {
          "additionalProperties": false,
          "description": "MsgSubmitMisbehaviour defines an sdk.Msg type that submits Evidence for light client misbehaviour.",
          "properties": {
            "client_id": {
              "description": "client unique identifier",
              "type": "string"
            },
            "misbehaviour": {
              "additionalProperties": false,
              "description": "misbehaviour used for freezing the light client",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "signer": {
              "description": "signer address",
              "type": "string"
            }
          },
          "title": "Msg Submit Misbehaviour",
          "type": "object"
        },
        "MsgSubmitProposal": {
          "additionalProperties": false,
          "description": "MsgSubmitProposal is the Msg/SubmitProposal request type.",
          "properties": {
            "exec": {
              "description": "Proposals and Voting  Exec defines modes of execution of a proposal on creation or on new vote.",
              "enum": [
                "EXEC_UNSPECIFIED",
                0,
                "EXEC_TRY",
                1
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Proposals and Voting"
            },
            "group_policy_address": {
              "description": "group_policy_address is the account address of group policy.",
              "type": "string"
            },
            "messages": {
              "description": "messages is a list of `sdk.Msg`s that will be executed if the proposal passes.",
              "items": {
                "additionalProperties": false,
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message. Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type. Example 1: Pack and unpack a message in C++.     Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     } Example 2: Pack and unpack a message in Java.     Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }  Example 3: Pack and unpack a message in Python.     foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...  Example 4: Pack and unpack a message in Go      foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      } The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\". JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:     package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }     {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     } If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):     {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }",
                "properties": {
                  "type_url": {
                    "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                    "type": "string"
                  },
                  "value": {
                    "binaryEncoding": "base64",
                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                    "format": "binary",
                    "type": "string"
                  }
                },
                "title": "Any",
                "type": "object"
              },
              "type": "array"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata to attached to the proposal.",
              "type": "string"
            },
            "proposers": {
              "description": "proposers are the account addresses of the proposers. Proposers signatures will be counted as yes votes.",
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          },
          "title": "Msg Submit Proposal",
          "type": "object"
        },
        "MsgTimeout": {
          "additionalProperties": false,
          "description": "MsgTimeout receives timed-out packet",
          "properties": {
            "next_sequence_recv": {
              "type": "string"
            },
            "packet": {
              "$ref": "#/definitions/ibc.core.channel.v1.Packet",
              "additionalProperties": false
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_unreceived": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Timeout",
          "type": "object"
        },
        "MsgTimeoutOnClose": {
          "additionalProperties": false,
          "description": "MsgTimeoutOnClose timed-out packet upon counterparty channel closure.",
          "properties": {
            "next_sequence_recv": {
              "type": "string"
            },
            "packet": {
              "$ref": "#/definitions/ibc.core.channel.v1.Packet",
              "additionalProperties": false
            },
            "proof_close": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_unreceived": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Timeout On Close",
          "type": "object"
        },
        "MsgTransfer": {
          "additionalProperties": false,
          "description": "MsgTransfer defines a msg to transfer fungible tokens (i.e Coins) between ICS20 enabled chains. See ICS Spec here: https://github.com/cosmos/ibc/tree/master/spec/app/ics-020-fungible-token-transfer#data-structures",
          "properties": {
            "memo": {
              "description": "optional memo",
              "type": "string"
            },
            "receiver": {
              "description": "the recipient address on the destination chain",
              "type": "string"
            },
            "sender": {
              "description": "the sender address",
              "type": "string"
            },
            "source_channel": {
              "description": "the channel by which the packet will be sent",
              "type": "string"
            },
            "source_port": {
              "description": "the port on which the packet will be sent",
              "type": "string"
            },
            "timeout_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false,
              "description": "Timeout height relative to the current block height. The timeout is disabled when set to 0."
            },
            "timeout_timestamp": {
              "description": "Timeout timestamp in absolute nanoseconds since unix epoch. The timeout is disabled when set to 0.",
              "type": "string"
            },
            "token": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false,
              "description": "the tokens to be transferred"
            }
          },
          "title": "Msg Transfer",
          "type": "object"
        },
        "MsgUndelegate": {
          "additionalProperties": false,
          "description": "MsgUndelegate defines a SDK message for performing an undelegation from a delegate and a validator.",
          "properties": {
            "amount": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false
            },
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Undelegate",
          "type": "object"
        },
        "MsgUnjail": {
          "additionalProperties": false,
          "description": "MsgUnjail defines the Msg/Unjail request type",
          "properties": {
            "validator_addr": {
              "type": "string"
            }
          },
          "title": "Msg Unjail",
          "type": "object"
        },
        "MsgUpdateClient": {
          "additionalProperties": false,
          "description": "MsgUpdateClient defines an sdk.Msg to update a IBC client state using the given header.",
          "properties": {
            "client_id": {
              "description": "client unique identifier",
              "type": "string"
            },
            "header": {
              "additionalProperties": false,
              "description": "header to update the light client",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "signer": {
              "description": "signer address",
              "type": "string"
            }
          },
          "title": "Msg Update Client",
          "type": "object"
        },
        "MsgUpdateGroupAdmin": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.",
          "properties": {
            "admin": {
              "description": "admin is the current account address of the group admin.",
              "type": "string"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "new_admin": {
              "description": "new_admin is the group new admin account address.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Admin",
          "type": "object"
        },
        "MsgUpdateGroupMembers": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "member_updates": {
              "description": "member_updates is the list of members to update, set weight to 0 to remove a member.",
              "items": {
                "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
              },
              "type": "array"
            }
          },
          "title": "Msg Update Group Members",
          "type": "object"
        },
        "MsgUpdateGroupMetadata": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is the updated group's metadata.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Metadata",
          "type": "object"
        },
        "MsgUpdateGroupPolicyAdmin": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "group_policy_address": {
              "description": "group_policy_address is the account address of the group policy.",
              "type": "string"
            },
            "new_admin": {
              "description": "new_admin is the new group policy admin.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Policy Admin",
          "type": "object"
        },
        "MsgUpdateGroupPolicyDecisionPolicy": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "decision_policy": {
              "additionalProperties": false,
              "description": "decision_policy is the updated group policy's decision policy.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "group_policy_address": {
              "description": "group_policy_address is the account address of group policy.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Policy Decision Policy",
          "type": "object"
        },
        "MsgUpdateGroupPolicyMetadata": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "group_policy_address": {
              "description": "group_policy_address is the account address of group policy.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is the updated group policy metadata.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Policy Metadata",
          "type": "object"
        },
        "MsgUpdateName": {
          "additionalProperties": false,
          "description": "Update the details of the Dyson Protocol name",
          "properties": {
            "authorized": {
              "description": "The address that this name is OfferedTo, they can take ownership of the name with the Accept message",
              "type": "string"
            },
            "auto_renew": {
              "description": "Will the name be automatically renewed at the expiration height. The expiration height is extended by 31,536,000 blocks (about 1 year). The fee is 1% of the price and is paid by the owner at the time of the renewal.",
              "type": "boolean"
            },
            "destination": {
              "description": "The new destination address for the name",
              "type": "string"
            },
            "name": {
              "description": "The name to update",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            }
          },
          "title": "Msg Update Name",
          "type": "object"
        },
        "MsgUpdateNft": {
          "additionalProperties": false,
          "description": "Update the details of an NFT",
          "properties": {
            "class_id": {
              "description": "the NFT Class ID",
              "type": "string"
            },
            "class_owner": {
              "description": "The owner of the NFT Class",
              "type": "string"
            },
            "id": {
              "description": "The ID of this NFT to update",
              "type": "string"
            },
            "uri": {
              "description": "The URI of the NFT (optional)",
              "type": "string"
            },
            "uri_hash": {
              "description": "The URI hash of the NFT (optional)",
              "type": "string"
            }
          },
          "title": "Msg Update Nft",
          "type": "object"
        },
        "MsgUpdateScheduledRun": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            },
            "index": {
              "type": "string"
            },
            "msg": {
              "$ref": "#/definitions/dyson.MsgRun",
              "additionalProperties": false
            }
          },
          "title": "Msg Update Scheduled Run",
          "type": "object"
        },
        "MsgUpdateScript": {
          "additionalProperties": false,
          "properties": {
            "code": {
              "format": "python",
              "type": "string"
            },
            "creator": {
              "type": "string"
            }
          },
          "title": "Msg Update Script",
          "type": "object"
        },
        "MsgUpdateStorage": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "description": "The address signing this transaction",
              "type": "string"
            },
            "data": {
              "description": "data to store at this index",
              "type": "string"
            },
            "force": {
              "description": "If true, force will always store the data at this address regardless of already existing storage",
              "type": "boolean"
            },
            "index": {
              "description": "Name of the Storage, must be prefixed with the creators address (for example: \"dys..1a3/some_name\")",
              "type": "string"
            }
          },
          "title": "Msg Update Storage",
          "type": "object"
        },
        "MsgUpgradeClient": {
          "additionalProperties": false,
          "description": "MsgUpgradeClient defines an sdk.Msg to upgrade an IBC client to a new client state",
          "properties": {
            "client_id": {
              "description": "client unique identifier",
              "type": "string"
            },
            "client_state": {
              "additionalProperties": false,
              "description": "upgraded client state",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "consensus_state": {
              "additionalProperties": false,
              "description": "upgraded consensus state, only contains enough information to serve as a basis of trust in update logic",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "proof_upgrade_client": {
              "binaryEncoding": "base64",
              "description": "proof that old chain committed to new client",
              "format": "binary",
              "type": "string"
            },
            "proof_upgrade_consensus_state": {
              "binaryEncoding": "base64",
              "description": "proof that old chain committed to new consensus state",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "description": "signer address",
              "type": "string"
            }
          },
          "title": "Msg Upgrade Client",
          "type": "object"
        },
        "MsgVerifyInvariant": {
          "additionalProperties": false,
          "description": "MsgVerifyInvariant represents a message to verify a particular invariance.",
          "properties": {
            "invariant_module_name": {
              "type": "string"
            },
            "invariant_route": {
              "type": "string"
            },
            "sender": {
              "type": "string"
            }
          },
          "title": "Msg Verify Invariant",
          "type": "object"
        },
        "MsgVote": {
          "additionalProperties": false,
          "description": "MsgVote is the Msg/Vote request type.",
          "properties": {
            "exec": {
              "description": "Proposals and Voting  Exec defines modes of execution of a proposal on creation or on new vote.",
              "enum": [
                "EXEC_UNSPECIFIED",
                0,
                "EXEC_TRY",
                1
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Proposals and Voting"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata to attached to the vote.",
              "type": "string"
            },
            "option": {
              "description": "VoteOption enumerates the valid vote options for a given proposal.",
              "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                0,
                "VOTE_OPTION_YES",
                1,
                "VOTE_OPTION_ABSTAIN",
                2,
                "VOTE_OPTION_NO",
                3,
                "VOTE_OPTION_NO_WITH_VETO",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Vote Option"
            },
            "proposal_id": {
              "description": "proposal is the unique ID of the proposal.",
              "type": "string"
            },
            "voter": {
              "description": "voter is the voter account address.",
              "type": "string"
            }
          },
          "title": "Msg Vote",
          "type": "object"
        },
        "MsgVoteWeighted": {
          "additionalProperties": false,
          "description": "MsgVoteWeighted defines a message to cast a vote. Since: cosmos-sdk 0.43",
          "properties": {
            "options": {
              "items": {
                "$ref": "#/definitions/cosmos.gov.v1beta1.WeightedVoteOption"
              },
              "type": "array"
            },
            "proposal_id": {
              "type": "string"
            },
            "voter": {
              "type": "string"
            }
          },
          "title": "Msg Vote Weighted",
          "type": "object"
        },
        "MsgWithdrawDelegatorReward": {
          "additionalProperties": false,
          "description": "MsgWithdrawDelegatorReward represents delegation withdrawal to a delegator from a single validator.",
          "properties": {
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Withdraw Delegator Reward",
          "type": "object"
        },
        "MsgWithdrawProposal": {
          "additionalProperties": false,
          "description": "MsgWithdrawProposal is the Msg/WithdrawProposal request type.",
          "properties": {
            "address": {
              "description": "address is the admin of the group policy or one of the proposer of the proposal.",
              "type": "string"
            },
            "proposal_id": {
              "description": "proposal is the unique ID of the proposal.",
              "type": "string"
            }
          },
          "title": "Msg Withdraw Proposal",
          "type": "object"
        },
        "MsgWithdrawValidatorCommission": {
          "additionalProperties": false,
          "description": "MsgWithdrawValidatorCommission withdraws the full commission to the validator address.",
          "properties": {
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Withdraw Validator Commission",
          "type": "object"
        },
        "cosmos.authz.v1beta1.Grant": {
          "additionalProperties": false,
          "description": "Grant gives permissions to execute the provide method with expiration time.",
          "properties": {
            "authorization": {
              "additionalProperties": false,
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "expiration": {
              "description": "time when the grant will expire and will be pruned. If null, then the grant doesn't have a time expiration (other conditions  in `authorization` may apply to invalidate the grant)",
              "format": "date-time",
              "type": "string"
            }
          },
          "title": "Grant",
          "type": "object"
        },
        "cosmos.bank.v1beta1.Input": {
          "additionalProperties": false,
          "description": "Input models transaction input.",
          "properties": {
            "address": {
              "type": "string"
            },
            "coins": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            }
          },
          "title": "Input",
          "type": "object"
        },
        "cosmos.bank.v1beta1.Output": {
          "additionalProperties": false,
          "description": "Output models transaction outputs.",
          "properties": {
            "address": {
              "type": "string"
            },
            "coins": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            }
          },
          "title": "Output",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        },
        "cosmos.gov.v1.WeightedVoteOption": {
          "additionalProperties": false,
          "description": "WeightedVoteOption defines a unit of vote for vote split.",
          "properties": {
            "option": {
              "description": "VoteOption enumerates the valid vote options for a given governance proposal.",
              "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                0,
                "VOTE_OPTION_YES",
                1,
                "VOTE_OPTION_ABSTAIN",
                2,
                "VOTE_OPTION_NO",
                3,
                "VOTE_OPTION_NO_WITH_VETO",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Vote Option"
            },
            "weight": {
              "type": "string"
            }
          },
          "title": "Weighted Vote Option",
          "type": "object"
        },
        "cosmos.gov.v1beta1.WeightedVoteOption": {
          "additionalProperties": false,
          "description": "WeightedVoteOption defines a unit of vote for vote split. Since: cosmos-sdk 0.43",
          "properties": {
            "option": {
              "description": "VoteOption enumerates the valid vote options for a given governance proposal.",
              "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                0,
                "VOTE_OPTION_YES",
                1,
                "VOTE_OPTION_ABSTAIN",
                2,
                "VOTE_OPTION_NO",
                3,
                "VOTE_OPTION_NO_WITH_VETO",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Vote Option"
            },
            "weight": {
              "type": "string"
            }
          },
          "title": "Weighted Vote Option",
          "type": "object"
        },
        "cosmos.group.v1.MemberRequest": {
          "additionalProperties": false,
          "description": "MemberRequest represents a group member to be used in Msg server requests. Contrary to `Member`, it doesn't have any `added_at` field since this field cannot be set as part of requests.",
          "properties": {
            "address": {
              "description": "address is the member's account address.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata attached to the member.",
              "type": "string"
            },
            "weight": {
              "description": "weight is the member's voting weight that should be greater than 0.",
              "type": "string"
            }
          },
          "title": "Member Request",
          "type": "object"
        },
        "cosmos.staking.v1beta1.CommissionRates": {
          "additionalProperties": false,
          "description": "CommissionRates defines the initial commission rates to be used for creating a validator.",
          "properties": {
            "max_change_rate": {
              "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction.",
              "type": "string"
            },
            "max_rate": {
              "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction.",
              "type": "string"
            },
            "rate": {
              "description": "rate is the commission rate charged to delegators, as a fraction.",
              "type": "string"
            }
          },
          "title": "Commission Rates",
          "type": "object"
        },
        "cosmos.staking.v1beta1.Description": {
          "additionalProperties": false,
          "description": "Description defines a validator description.",
          "properties": {
            "details": {
              "description": "details define other optional details.",
              "type": "string"
            },
            "identity": {
              "description": "identity defines an optional identity signature (ex. UPort or Keybase).",
              "type": "string"
            },
            "moniker": {
              "description": "moniker defines a human-readable name for the validator.",
              "type": "string"
            },
            "security_contact": {
              "description": "security_contact defines an optional email for security contact.",
              "type": "string"
            },
            "website": {
              "description": "website defines an optional website link.",
              "type": "string"
            }
          },
          "title": "Description",
          "type": "object"
        },
        "cosmos.upgrade.v1beta1.Plan": {
          "additionalProperties": false,
          "description": "Plan specifies information about a planned upgrade and when it should occur.",
          "properties": {
            "height": {
              "description": "The height at which the upgrade must be performed. Only used if Time is not set.",
              "type": "string"
            },
            "info": {
              "description": "Any application specific upgrade info to be included on-chain such as a git commit that validators could automatically upgrade to",
              "type": "string"
            },
            "name": {
              "description": "Sets the name for the upgrade. This name will be used by the upgraded version of the software to apply any special \"on-upgrade\" commands during the first BeginBlock method after the upgrade is applied. It is also used to detect whether a software version can handle a given upgrade. If no upgrade handler with this name has been set in the software, it will be assumed that the software is out-of-date when the upgrade Time or Height is reached and the software will exit.",
              "type": "string"
            },
            "time": {
              "description": "Deprecated: Time based upgrades have been deprecated. Time based upgrade logic has been removed from the SDK. If this field is not empty, an error will be thrown.",
              "format": "date-time",
              "type": "string"
            },
            "upgraded_client_state": {
              "additionalProperties": false,
              "description": "Deprecated: UpgradedClientState field has been deprecated. IBC upgrade logic has been moved to the IBC module in the sub module 02-client. If this field is not empty, an error will be thrown.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "title": "Plan",
          "type": "object"
        },
        "cosmos.vesting.v1beta1.Period": {
          "additionalProperties": false,
          "description": "Period defines a length of time and amount of coins that will vest.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "length": {
              "type": "string"
            }
          },
          "title": "Period",
          "type": "object"
        },
        "dyson.MsgRun": {
          "additionalProperties": false,
          "description": "MsgRun runs a script at a specific address",
          "properties": {
            "address": {
              "description": "Dys address of the script to call",
              "type": "string"
            },
            "args": {
              "description": "Optional args to call the function with",
              "type": "string"
            },
            "coins": {
              "description": "Optional comma seperated list of coins to send the script (for example \"123dys,456token\") this entire amount will be sent to the script",
              "type": "string"
            },
            "creator": {
              "description": "The account sending this transaction",
              "type": "string"
            },
            "extra_lines": {
              "description": "Optional extra source code to append to the end of the script before running. Only available to the script address itself.",
              "type": "string"
            },
            "function_name": {
              "description": "Optional function to call",
              "type": "string"
            },
            "kwargs": {
              "description": "Optional kwargs to run",
              "type": "string"
            },
            "nfts": {
              "description": "Optional NFTs to send the script, formatted [class_id]/[id], [class_id]/[id] (for example \"example.dys/123, example.dys/456\")",
              "type": "string"
            }
          },
          "title": "Msg Run",
          "type": "object"
        },
        "ibc.applications.interchain_accounts.v1.InterchainAccountPacketData": {
          "additionalProperties": false,
          "description": "InterchainAccountPacketData is comprised of a raw transaction, type of transaction and optional memo field.",
          "properties": {
            "data": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "memo": {
              "type": "string"
            },
            "type": {
              "description": "Type defines a classification of message issued from a controller chain to its associated interchain accounts host",
              "enum": [
                "TYPE_UNSPECIFIED",
                0,
                "TYPE_EXECUTE_TX",
                1
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Type"
            }
          },
          "title": "Interchain Account Packet Data",
          "type": "object"
        },
        "ibc.core.channel.v1.Channel": {
          "additionalProperties": false,
          "description": "Channel defines pipeline for exactly-once packet delivery between specific modules on separate blockchains, which has at least one end capable of sending packets and one end capable of receiving packets.",
          "properties": {
            "connection_hops": {
              "description": "list of connection identifiers, in order, along which packets sent on this channel will travel",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "counterparty": {
              "$ref": "#/definitions/ibc.core.channel.v1.Counterparty",
              "additionalProperties": false,
              "description": "counterparty channel end"
            },
            "ordering": {
              "description": "Order defines if a channel is ORDERED or UNORDERED",
              "enum": [
                "ORDER_NONE_UNSPECIFIED",
                0,
                "ORDER_UNORDERED",
                1,
                "ORDER_ORDERED",
                2
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Order"
            },
            "state": {
              "description": "State defines if a channel is in one of the following states: CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.",
              "enum": [
                "STATE_UNINITIALIZED_UNSPECIFIED",
                0,
                "STATE_INIT",
                1,
                "STATE_TRYOPEN",
                2,
                "STATE_OPEN",
                3,
                "STATE_CLOSED",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "State"
            },
            "version": {
              "description": "opaque channel version, which is agreed upon during the handshake",
              "type": "string"
            }
          },
          "title": "Channel",
          "type": "object"
        },
        "ibc.core.channel.v1.Counterparty": {
          "additionalProperties": false,
          "description": "Counterparty defines a channel end counterparty",
          "properties": {
            "channel_id": {
              "description": "channel end on the counterparty chain",
              "type": "string"
            },
            "port_id": {
              "description": "port on the counterparty chain which owns the other end of the channel.",
              "type": "string"
            }
          },
          "title": "Counterparty",
          "type": "object"
        },
        "ibc.core.channel.v1.Packet": {
          "additionalProperties": false,
          "description": "Packet defines a type that carries data across different chains through IBC",
          "properties": {
            "data": {
              "binaryEncoding": "base64",
              "description": "actual opaque bytes transferred directly to the application module",
              "format": "binary",
              "type": "string"
            },
            "destination_channel": {
              "description": "identifies the channel end on the receiving chain.",
              "type": "string"
            },
            "destination_port": {
              "description": "identifies the port on the receiving chain.",
              "type": "string"
            },
            "sequence": {
              "description": "number corresponds to the order of sends and receives, where a Packet with an earlier sequence number must be sent and received before a Packet with a later sequence number.",
              "type": "string"
            },
            "source_channel": {
              "description": "identifies the channel end on the sending chain.",
              "type": "string"
            },
            "source_port": {
              "description": "identifies the port on the sending chain.",
              "type": "string"
            },
            "timeout_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false,
              "description": "block height after which the packet times out"
            },
            "timeout_timestamp": {
              "description": "block timestamp (in nanoseconds) after which the packet times out",
              "type": "string"
            }
          },
          "title": "Packet",
          "type": "object"
        },
        "ibc.core.client.v1.Height": {
          "additionalProperties": false,
          "description": "Height is a monotonically increasing data type that can be compared against another Height for the purposes of updating and freezing clients Normally the RevisionHeight is incremented at each height while keeping RevisionNumber the same. However some consensus algorithms may choose to reset the height in certain conditions e.g. hard forks, state-machine breaking changes In these cases, the RevisionNumber is incremented so that height continues to be monitonically increasing even as the RevisionHeight gets reset",
          "properties": {
            "revision_height": {
              "description": "the height within the given revision",
              "type": "string"
            },
            "revision_number": {
              "description": "the revision that the client is currently on",
              "type": "string"
            }
          },
          "title": "Height",
          "type": "object"
        },
        "ibc.core.commitment.v1.MerklePrefix": {
          "additionalProperties": false,
          "description": "MerklePrefix is merkle path prefixed to the key. The constructed key from the Path and the key will be append(Path.KeyPath, append(Path.KeyPrefix, key...))",
          "properties": {
            "key_prefix": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            }
          },
          "title": "Merkle Prefix",
          "type": "object"
        },
        "ibc.core.connection.v1.Counterparty": {
          "additionalProperties": false,
          "description": "Counterparty defines the counterparty chain associated with a connection end.",
          "properties": {
            "client_id": {
              "description": "identifies the client on the counterparty chain associated with a given connection.",
              "type": "string"
            },
            "connection_id": {
              "description": "identifies the connection end on the counterparty chain associated with a given connection.",
              "type": "string"
            },
            "prefix": {
              "$ref": "#/definitions/ibc.core.commitment.v1.MerklePrefix",
              "additionalProperties": false,
              "description": "commitment merkle prefix of the counterparty chain."
            }
          },
          "title": "Counterparty",
          "type": "object"
        },
        "ibc.core.connection.v1.Version": {
          "additionalProperties": false,
          "description": "Version defines the versioning scheme used to negotiate the IBC verison in the connection handshake.",
          "properties": {
            "features": {
              "description": "list of features compatible with the specified identifier",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "identifier": {
              "description": "unique version identifier",
              "type": "string"
            }
          },
          "title": "Version",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.authz.v1beta1/sendMsgGrant": {
    "http_rules": null,
    "module_name": "cosmos.authz.v1beta1",
    "name": "Grant",
    "request_schema": {
      "$ref": "#/definitions/MsgGrant",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "GenericAuthorization": {
          "additionalProperties": false,
          "description": "GenericAuthorization gives the grantee unrestricted permissions to execute the provided method on behalf of the granter's account.",
          "properties": {
            "msg": {
              "description": "Msg, identified by it's type URL, to grant unrestricted permissions to execute",
              "type": "string"
            }
          },
          "title": "Generic Authorization",
          "type": "object"
        },
        "MsgGrant": {
          "additionalProperties": false,
          "description": "MsgGrant is a request type for Grant method. It declares authorization to the grantee on behalf of the granter with the provided expiration time.",
          "properties": {
            "grant": {
              "$ref": "#/definitions/cosmos.authz.v1beta1.Grant",
              "additionalProperties": false
            },
            "grantee": {
              "type": "string"
            },
            "granter": {
              "type": "string"
            }
          },
          "title": "Msg Grant",
          "type": "object"
        },
        "SendAuthorization": {
          "additionalProperties": false,
          "description": "SendAuthorization allows the grantee to spend up to spend_limit coins from the granter's account. Since: cosmos-sdk 0.43",
          "properties": {
            "spend_limit": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            }
          },
          "title": "Send Authorization",
          "type": "object"
        },
        "StakeAuthorization": {
          "additionalProperties": false,
          "description": "StakeAuthorization defines authorization for delegate/undelegate/redelegate. Since: cosmos-sdk 0.43",
          "properties": {
            "allow_list": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.StakeAuthorization.Validators",
              "additionalProperties": false,
              "description": "allow_list specifies list of validator addresses to whom grantee can delegate tokens on behalf of granter's account."
            },
            "authorization_type": {
              "description": "AuthorizationType defines the type of staking module authorization type Since: cosmos-sdk 0.43",
              "enum": [
                "AUTHORIZATION_TYPE_UNSPECIFIED",
                0,
                "AUTHORIZATION_TYPE_DELEGATE",
                1,
                "AUTHORIZATION_TYPE_UNDELEGATE",
                2,
                "AUTHORIZATION_TYPE_REDELEGATE",
                3
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Authorization Type"
            },
            "deny_list": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.StakeAuthorization.Validators",
              "additionalProperties": false,
              "description": "deny_list specifies list of validator addresses to whom grantee can not delegate tokens."
            },
            "max_tokens": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false,
              "description": "max_tokens specifies the maximum amount of tokens can be delegate to a validator. If it is empty, there is no spend limit and any amount of coins can be delegated."
            }
          },
          "title": "Stake Authorization",
          "type": "object"
        },
        "cosmos.authz.v1beta1.Grant": {
          "additionalProperties": false,
          "description": "Grant gives permissions to execute the provide method with expiration time.",
          "properties": {
            "authorization": {
              "oneOf": [
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/GenericAuthorization"
                    },
                    "type_url": {
                      "default": "/cosmos.authz.v1beta1.GenericAuthorization",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.authz.v1beta1.GenericAuthorization"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.authz.v1beta1.GenericAuthorization",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/SendAuthorization"
                    },
                    "type_url": {
                      "default": "/cosmos.bank.v1beta1.SendAuthorization",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.bank.v1beta1.SendAuthorization"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.bank.v1beta1.SendAuthorization",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/StakeAuthorization"
                    },
                    "type_url": {
                      "default": "/cosmos.staking.v1beta1.StakeAuthorization",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.staking.v1beta1.StakeAuthorization"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.staking.v1beta1.StakeAuthorization",
                  "type": "object"
                }
              ]
            },
            "expiration": {
              "description": "time when the grant will expire and will be pruned. If null, then the grant doesn't have a time expiration (other conditions  in `authorization` may apply to invalidate the grant)",
              "format": "date-time",
              "type": "string"
            }
          },
          "title": "Grant",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        },
        "cosmos.staking.v1beta1.StakeAuthorization.Validators": {
          "additionalProperties": false,
          "description": "Validators defines list of validator addresses.",
          "properties": {
            "address": {
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          },
          "title": "Validators",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.authz.v1beta1/sendMsgRevoke": {
    "http_rules": null,
    "module_name": "cosmos.authz.v1beta1",
    "name": "Revoke",
    "request_schema": {
      "$ref": "#/definitions/MsgRevoke",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgRevoke": {
          "additionalProperties": false,
          "description": "MsgRevoke revokes any authorization with the provided sdk.Msg type on the granter's account with that has been granted to the grantee.",
          "properties": {
            "grantee": {
              "type": "string"
            },
            "granter": {
              "type": "string"
            },
            "msg_type_url": {
              "type": "string"
            }
          },
          "title": "Msg Revoke",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.bank.v1beta1/QueryAllBalances": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "address"
        ]
      }
    ],
    "module_name": "cosmos.bank.v1beta1",
    "name": "AllBalances",
    "request_schema": {
      "$ref": "#/definitions/QueryAllBalancesRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryAllBalancesRequest": {
          "additionalProperties": false,
          "description": "QueryBalanceRequest is the request type for the Query/AllBalances RPC method.",
          "properties": {
            "address": {
              "description": "address is the address to query balances for.",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            }
          },
          "title": "Query All Balances Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/bank/v1beta1/balances/{address}",
    "service_name": "Query"
  },
  "cosmos.bank.v1beta1/QueryBalance": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "address"
        ]
      }
    ],
    "module_name": "cosmos.bank.v1beta1",
    "name": "Balance",
    "request_schema": {
      "$ref": "#/definitions/QueryBalanceRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryBalanceRequest": {
          "additionalProperties": false,
          "description": "QueryBalanceRequest is the request type for the Query/Balance RPC method.",
          "properties": {
            "address": {
              "description": "address is the address to query balances for.",
              "type": "string"
            },
            "denom": {
              "description": "denom is the coin denom to query balances for.",
              "type": "string"
            }
          },
          "title": "Query Balance Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/bank/v1beta1/balances/{address}/by_denom",
    "service_name": "Query"
  },
  "cosmos.bank.v1beta1/QueryDenomMetadata": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "denom"
        ]
      }
    ],
    "module_name": "cosmos.bank.v1beta1",
    "name": "DenomMetadata",
    "request_schema": {
      "$ref": "#/definitions/QueryDenomMetadataRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryDenomMetadataRequest": {
          "additionalProperties": false,
          "description": "QueryDenomMetadataRequest is the request type for the Query/DenomMetadata RPC method.",
          "properties": {
            "denom": {
              "description": "denom is the coin denom to query the metadata for.",
              "type": "string"
            }
          },
          "title": "Query Denom Metadata Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/bank/v1beta1/denoms_metadata/{denom}",
    "service_name": "Query"
  },
  "cosmos.bank.v1beta1/QueryDenomOwners": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "denom"
        ]
      }
    ],
    "module_name": "cosmos.bank.v1beta1",
    "name": "DenomOwners",
    "request_schema": {
      "$ref": "#/definitions/QueryDenomOwnersRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryDenomOwnersRequest": {
          "additionalProperties": false,
          "description": "QueryDenomOwnersRequest defines the request type for the DenomOwners RPC query, which queries for a paginated set of all account holders of a particular denomination.",
          "properties": {
            "denom": {
              "description": "denom defines the coin denomination to query all account holders for.",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            }
          },
          "title": "Query Denom Owners Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/bank/v1beta1/denom_owners/{denom}",
    "service_name": "Query"
  },
  "cosmos.bank.v1beta1/QueryDenomsMetadata": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "cosmos.bank.v1beta1",
    "name": "DenomsMetadata",
    "request_schema": {
      "$ref": "#/definitions/QueryDenomsMetadataRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryDenomsMetadataRequest": {
          "additionalProperties": false,
          "description": "QueryDenomsMetadataRequest is the request type for the Query/DenomsMetadata RPC method.",
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            }
          },
          "title": "Query Denoms Metadata Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/bank/v1beta1/denoms_metadata",
    "service_name": "Query"
  },
  "cosmos.bank.v1beta1/QueryParams": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "cosmos.bank.v1beta1",
    "name": "Params",
    "request_schema": {
      "$ref": "#/definitions/QueryParamsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryParamsRequest": {
          "additionalProperties": false,
          "description": "QueryParamsRequest defines the request type for querying x/bank parameters.",
          "title": "Query Params Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/bank/v1beta1/params",
    "service_name": "Query"
  },
  "cosmos.bank.v1beta1/QuerySpendableBalances": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "address"
        ]
      }
    ],
    "module_name": "cosmos.bank.v1beta1",
    "name": "SpendableBalances",
    "request_schema": {
      "$ref": "#/definitions/QuerySpendableBalancesRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QuerySpendableBalancesRequest": {
          "additionalProperties": false,
          "description": "QuerySpendableBalancesRequest defines the gRPC request structure for querying an account's spendable balances. Since: cosmos-sdk 0.46",
          "properties": {
            "address": {
              "description": "address is the address to query spendable balances for.",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            }
          },
          "title": "Query Spendable Balances Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/bank/v1beta1/spendable_balances/{address}",
    "service_name": "Query"
  },
  "cosmos.bank.v1beta1/QuerySupplyOf": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "cosmos.bank.v1beta1",
    "name": "SupplyOf",
    "request_schema": {
      "$ref": "#/definitions/QuerySupplyOfRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QuerySupplyOfRequest": {
          "additionalProperties": false,
          "description": "QuerySupplyOfRequest is the request type for the Query/SupplyOf RPC method.",
          "properties": {
            "denom": {
              "description": "denom is the coin denom to query balances for.",
              "type": "string"
            }
          },
          "title": "Query Supply Of Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/bank/v1beta1/supply/by_denom",
    "service_name": "Query"
  },
  "cosmos.bank.v1beta1/QueryTotalSupply": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "cosmos.bank.v1beta1",
    "name": "TotalSupply",
    "request_schema": {
      "$ref": "#/definitions/QueryTotalSupplyRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryTotalSupplyRequest": {
          "additionalProperties": false,
          "description": "QueryTotalSupplyRequest is the request type for the Query/TotalSupply RPC method.",
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request. Since: cosmos-sdk 0.43"
            }
          },
          "title": "Query Total Supply Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/bank/v1beta1/supply",
    "service_name": "Query"
  },
  "cosmos.bank.v1beta1/sendMsgMultiSend": {
    "http_rules": null,
    "module_name": "cosmos.bank.v1beta1",
    "name": "MultiSend",
    "request_schema": {
      "$ref": "#/definitions/MsgMultiSend",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgMultiSend": {
          "additionalProperties": false,
          "description": "MsgMultiSend represents an arbitrary multi-in, multi-out send message.",
          "properties": {
            "inputs": {
              "items": {
                "$ref": "#/definitions/cosmos.bank.v1beta1.Input"
              },
              "type": "array"
            },
            "outputs": {
              "items": {
                "$ref": "#/definitions/cosmos.bank.v1beta1.Output"
              },
              "type": "array"
            }
          },
          "title": "Msg Multi Send",
          "type": "object"
        },
        "cosmos.bank.v1beta1.Input": {
          "additionalProperties": false,
          "description": "Input models transaction input.",
          "properties": {
            "address": {
              "type": "string"
            },
            "coins": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            }
          },
          "title": "Input",
          "type": "object"
        },
        "cosmos.bank.v1beta1.Output": {
          "additionalProperties": false,
          "description": "Output models transaction outputs.",
          "properties": {
            "address": {
              "type": "string"
            },
            "coins": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            }
          },
          "title": "Output",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.bank.v1beta1/sendMsgSend": {
    "http_rules": null,
    "module_name": "cosmos.bank.v1beta1",
    "name": "Send",
    "request_schema": {
      "$ref": "#/definitions/MsgSend",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgSend": {
          "additionalProperties": false,
          "description": "MsgSend represents a message to send coins from one account to another.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "from_address": {
              "type": "string"
            },
            "to_address": {
              "type": "string"
            }
          },
          "title": "Msg Send",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.distribution.v1beta1/QueryCommunityPool": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "cosmos.distribution.v1beta1",
    "name": "CommunityPool",
    "request_schema": {
      "$ref": "#/definitions/QueryCommunityPoolRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryCommunityPoolRequest": {
          "additionalProperties": false,
          "description": "QueryCommunityPoolRequest is the request type for the Query/CommunityPool RPC method.",
          "title": "Query Community Pool Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/distribution/v1beta1/community_pool",
    "service_name": "Query"
  },
  "cosmos.distribution.v1beta1/QueryDelegationRewards": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "delegator_address",
          "validator_address"
        ]
      }
    ],
    "module_name": "cosmos.distribution.v1beta1",
    "name": "DelegationRewards",
    "request_schema": {
      "$ref": "#/definitions/QueryDelegationRewardsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryDelegationRewardsRequest": {
          "additionalProperties": false,
          "description": "QueryDelegationRewardsRequest is the request type for the Query/DelegationRewards RPC method.",
          "properties": {
            "delegator_address": {
              "description": "delegator_address defines the delegator address to query for.",
              "type": "string"
            },
            "validator_address": {
              "description": "validator_address defines the validator address to query for.",
              "type": "string"
            }
          },
          "title": "Query Delegation Rewards Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}",
    "service_name": "Query"
  },
  "cosmos.distribution.v1beta1/QueryDelegationTotalRewards": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "delegator_address"
        ]
      }
    ],
    "module_name": "cosmos.distribution.v1beta1",
    "name": "DelegationTotalRewards",
    "request_schema": {
      "$ref": "#/definitions/QueryDelegationTotalRewardsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryDelegationTotalRewardsRequest": {
          "additionalProperties": false,
          "description": "QueryDelegationTotalRewardsRequest is the request type for the Query/DelegationTotalRewards RPC method.",
          "properties": {
            "delegator_address": {
              "description": "delegator_address defines the delegator address to query for.",
              "type": "string"
            }
          },
          "title": "Query Delegation Total Rewards Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards",
    "service_name": "Query"
  },
  "cosmos.distribution.v1beta1/QueryDelegatorValidators": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "delegator_address"
        ]
      }
    ],
    "module_name": "cosmos.distribution.v1beta1",
    "name": "DelegatorValidators",
    "request_schema": {
      "$ref": "#/definitions/QueryDelegatorValidatorsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryDelegatorValidatorsRequest": {
          "additionalProperties": false,
          "description": "QueryDelegatorValidatorsRequest is the request type for the Query/DelegatorValidators RPC method.",
          "properties": {
            "delegator_address": {
              "description": "delegator_address defines the delegator address to query for.",
              "type": "string"
            }
          },
          "title": "Query Delegator Validators Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/distribution/v1beta1/delegators/{delegator_address}/validators",
    "service_name": "Query"
  },
  "cosmos.distribution.v1beta1/QueryDelegatorWithdrawAddress": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "delegator_address"
        ]
      }
    ],
    "module_name": "cosmos.distribution.v1beta1",
    "name": "DelegatorWithdrawAddress",
    "request_schema": {
      "$ref": "#/definitions/QueryDelegatorWithdrawAddressRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryDelegatorWithdrawAddressRequest": {
          "additionalProperties": false,
          "description": "QueryDelegatorWithdrawAddressRequest is the request type for the Query/DelegatorWithdrawAddress RPC method.",
          "properties": {
            "delegator_address": {
              "description": "delegator_address defines the delegator address to query for.",
              "type": "string"
            }
          },
          "title": "Query Delegator Withdraw Address Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address",
    "service_name": "Query"
  },
  "cosmos.distribution.v1beta1/QueryParams": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "cosmos.distribution.v1beta1",
    "name": "Params",
    "request_schema": {
      "$ref": "#/definitions/QueryParamsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryParamsRequest": {
          "additionalProperties": false,
          "description": "QueryParamsRequest is the request type for the Query/Params RPC method.",
          "title": "Query Params Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/distribution/v1beta1/params",
    "service_name": "Query"
  },
  "cosmos.distribution.v1beta1/QueryValidatorCommission": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "validator_address"
        ]
      }
    ],
    "module_name": "cosmos.distribution.v1beta1",
    "name": "ValidatorCommission",
    "request_schema": {
      "$ref": "#/definitions/QueryValidatorCommissionRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryValidatorCommissionRequest": {
          "additionalProperties": false,
          "description": "QueryValidatorCommissionRequest is the request type for the Query/ValidatorCommission RPC method",
          "properties": {
            "validator_address": {
              "description": "validator_address defines the validator address to query for.",
              "type": "string"
            }
          },
          "title": "Query Validator Commission Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/distribution/v1beta1/validators/{validator_address}/commission",
    "service_name": "Query"
  },
  "cosmos.distribution.v1beta1/QueryValidatorOutstandingRewards": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "validator_address"
        ]
      }
    ],
    "module_name": "cosmos.distribution.v1beta1",
    "name": "ValidatorOutstandingRewards",
    "request_schema": {
      "$ref": "#/definitions/QueryValidatorOutstandingRewardsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryValidatorOutstandingRewardsRequest": {
          "additionalProperties": false,
          "description": "QueryValidatorOutstandingRewardsRequest is the request type for the Query/ValidatorOutstandingRewards RPC method.",
          "properties": {
            "validator_address": {
              "description": "validator_address defines the validator address to query for.",
              "type": "string"
            }
          },
          "title": "Query Validator Outstanding Rewards Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards",
    "service_name": "Query"
  },
  "cosmos.distribution.v1beta1/QueryValidatorSlashes": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "validator_address"
        ]
      }
    ],
    "module_name": "cosmos.distribution.v1beta1",
    "name": "ValidatorSlashes",
    "request_schema": {
      "$ref": "#/definitions/QueryValidatorSlashesRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryValidatorSlashesRequest": {
          "additionalProperties": false,
          "description": "QueryValidatorSlashesRequest is the request type for the Query/ValidatorSlashes RPC method",
          "properties": {
            "ending_height": {
              "description": "starting_height defines the optional ending height to query the slashes.",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            },
            "starting_height": {
              "description": "starting_height defines the optional starting height to query the slashes.",
              "type": "string"
            },
            "validator_address": {
              "description": "validator_address defines the validator address to query for.",
              "type": "string"
            }
          },
          "title": "Query Validator Slashes Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/distribution/v1beta1/validators/{validator_address}/slashes",
    "service_name": "Query"
  },
  "cosmos.distribution.v1beta1/sendMsgFundCommunityPool": {
    "http_rules": null,
    "module_name": "cosmos.distribution.v1beta1",
    "name": "FundCommunityPool",
    "request_schema": {
      "$ref": "#/definitions/MsgFundCommunityPool",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgFundCommunityPool": {
          "additionalProperties": false,
          "description": "MsgFundCommunityPool allows an account to directly fund the community pool.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "depositor": {
              "type": "string"
            }
          },
          "title": "Msg Fund Community Pool",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.distribution.v1beta1/sendMsgSetWithdrawAddress": {
    "http_rules": null,
    "module_name": "cosmos.distribution.v1beta1",
    "name": "SetWithdrawAddress",
    "request_schema": {
      "$ref": "#/definitions/MsgSetWithdrawAddress",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgSetWithdrawAddress": {
          "additionalProperties": false,
          "description": "MsgSetWithdrawAddress sets the withdraw address for a delegator (or validator self-delegation).",
          "properties": {
            "delegator_address": {
              "type": "string"
            },
            "withdraw_address": {
              "type": "string"
            }
          },
          "title": "Msg Set Withdraw Address",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.distribution.v1beta1/sendMsgWithdrawDelegatorReward": {
    "http_rules": null,
    "module_name": "cosmos.distribution.v1beta1",
    "name": "WithdrawDelegatorReward",
    "request_schema": {
      "$ref": "#/definitions/MsgWithdrawDelegatorReward",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgWithdrawDelegatorReward": {
          "additionalProperties": false,
          "description": "MsgWithdrawDelegatorReward represents delegation withdrawal to a delegator from a single validator.",
          "properties": {
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Withdraw Delegator Reward",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.distribution.v1beta1/sendMsgWithdrawValidatorCommission": {
    "http_rules": null,
    "module_name": "cosmos.distribution.v1beta1",
    "name": "WithdrawValidatorCommission",
    "request_schema": {
      "$ref": "#/definitions/MsgWithdrawValidatorCommission",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgWithdrawValidatorCommission": {
          "additionalProperties": false,
          "description": "MsgWithdrawValidatorCommission withdraws the full commission to the validator address.",
          "properties": {
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Withdraw Validator Commission",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.feegrant.v1beta1/QueryAllowance": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "granter",
          "grantee"
        ]
      }
    ],
    "module_name": "cosmos.feegrant.v1beta1",
    "name": "Allowance",
    "request_schema": {
      "$ref": "#/definitions/QueryAllowanceRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryAllowanceRequest": {
          "additionalProperties": false,
          "description": "QueryAllowanceRequest is the request type for the Query/Allowance RPC method.",
          "properties": {
            "grantee": {
              "description": "grantee is the address of the user being granted an allowance of another user's funds.",
              "type": "string"
            },
            "granter": {
              "description": "granter is the address of the user granting an allowance of their funds.",
              "type": "string"
            }
          },
          "title": "Query Allowance Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}",
    "service_name": "Query"
  },
  "cosmos.feegrant.v1beta1/QueryAllowances": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "grantee"
        ]
      }
    ],
    "module_name": "cosmos.feegrant.v1beta1",
    "name": "Allowances",
    "request_schema": {
      "$ref": "#/definitions/QueryAllowancesRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryAllowancesRequest": {
          "additionalProperties": false,
          "description": "QueryAllowancesRequest is the request type for the Query/Allowances RPC method.",
          "properties": {
            "grantee": {
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an pagination for the request."
            }
          },
          "title": "Query Allowances Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/feegrant/v1beta1/allowances/{grantee}",
    "service_name": "Query"
  },
  "cosmos.feegrant.v1beta1/QueryAllowancesByGranter": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "granter"
        ]
      }
    ],
    "module_name": "cosmos.feegrant.v1beta1",
    "name": "AllowancesByGranter",
    "request_schema": {
      "$ref": "#/definitions/QueryAllowancesByGranterRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryAllowancesByGranterRequest": {
          "additionalProperties": false,
          "description": "QueryAllowancesByGranterRequest is the request type for the Query/AllowancesByGranter RPC method. Since: cosmos-sdk 0.46",
          "properties": {
            "granter": {
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an pagination for the request."
            }
          },
          "title": "Query Allowances By Granter Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/feegrant/v1beta1/issued/{granter}",
    "service_name": "Query"
  },
  "cosmos.feegrant.v1beta1/sendMsgGrantAllowance": {
    "http_rules": null,
    "module_name": "cosmos.feegrant.v1beta1",
    "name": "GrantAllowance",
    "request_schema": {
      "$ref": "#/definitions/MsgGrantAllowance",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgAccept": {
          "additionalProperties": false,
          "description": "Accept the name that was offered to you",
          "properties": {
            "name": {
              "description": "The name to accept",
              "type": "string"
            },
            "new_owner": {
              "description": "The owner address of the name",
              "type": "string"
            }
          },
          "title": "Msg Accept",
          "type": "object"
        },
        "MsgAcknowledgement": {
          "additionalProperties": false,
          "description": "MsgAcknowledgement receives incoming IBC acknowledgement",
          "properties": {
            "acknowledgement": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "packet": {
              "$ref": "#/definitions/ibc.core.channel.v1.Packet",
              "additionalProperties": false
            },
            "proof_acked": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Acknowledgement",
          "type": "object"
        },
        "MsgBeginRedelegate": {
          "additionalProperties": false,
          "description": "MsgBeginRedelegate defines a SDK message for performing a redelegation of coins from a delegator and source validator to a destination validator.",
          "properties": {
            "amount": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false
            },
            "delegator_address": {
              "type": "string"
            },
            "validator_dst_address": {
              "type": "string"
            },
            "validator_src_address": {
              "type": "string"
            }
          },
          "title": "Msg Begin Redelegate",
          "type": "object"
        },
        "MsgBurnCoins": {
          "additionalProperties": false,
          "properties": {
            "amount": {
              "description": "The amount of coins to burn, the owner must have enough coins to burn",
              "type": "string"
            },
            "owner": {
              "description": "The owner of the Dys name",
              "type": "string"
            }
          },
          "title": "Msg Burn Coins",
          "type": "object"
        },
        "MsgBurnNft": {
          "additionalProperties": false,
          "description": "Burn an NFT of the given class ID and NFT ID.",
          "properties": {
            "class_id": {
              "description": "the NFT Class ID",
              "type": "string"
            },
            "class_owner": {
              "description": "The owner of the NFT Class",
              "type": "string"
            },
            "id": {
              "description": "The ID of this NFT to burn. The owner must currently own this NFT to burn it.",
              "type": "string"
            }
          },
          "title": "Msg Burn Nft",
          "type": "object"
        },
        "MsgBuy": {
          "additionalProperties": false,
          "description": "All names have a listed price, this message allows you to buy the name at the listed price.",
          "properties": {
            "buyer": {
              "description": "The address of the buyer",
              "type": "string"
            },
            "name": {
              "description": "The name to buy",
              "type": "string"
            },
            "price": {
              "description": "Confirm the  price of the name is the same as the listed price.",
              "type": "string"
            }
          },
          "title": "Msg Buy",
          "type": "object"
        },
        "MsgCancelUnbondingDelegation": {
          "additionalProperties": false,
          "description": "MsgCancelUnbondingDelegation defines the SDK message for performing a cancel unbonding delegation for delegator Since: cosmos-sdk 0.46",
          "properties": {
            "amount": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false,
              "description": "amount is always less than or equal to unbonding delegation entry balance"
            },
            "creation_height": {
              "description": "creation_height is the height which the unbonding took place.",
              "type": "string"
            },
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Cancel Unbonding Delegation",
          "type": "object"
        },
        "MsgCancelUpgrade": {
          "additionalProperties": false,
          "description": "MsgCancelUpgrade is the Msg/CancelUpgrade request type. Since: cosmos-sdk 0.46",
          "properties": {
            "authority": {
              "description": "authority is the address of the governance account.",
              "type": "string"
            }
          },
          "title": "Msg Cancel Upgrade",
          "type": "object"
        },
        "MsgChannelCloseConfirm": {
          "additionalProperties": false,
          "description": "MsgChannelCloseConfirm defines a msg sent by a Relayer to Chain B to acknowledge the change of channel state to CLOSED on Chain A.",
          "properties": {
            "channel_id": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_init": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Close Confirm",
          "type": "object"
        },
        "MsgChannelCloseInit": {
          "additionalProperties": false,
          "description": "MsgChannelCloseInit defines a msg sent by a Relayer to Chain A to close a channel with Chain B.",
          "properties": {
            "channel_id": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Close Init",
          "type": "object"
        },
        "MsgChannelOpenAck": {
          "additionalProperties": false,
          "description": "MsgChannelOpenAck defines a msg sent by a Relayer to Chain A to acknowledge the change of channel state to TRYOPEN on Chain B.",
          "properties": {
            "channel_id": {
              "type": "string"
            },
            "counterparty_channel_id": {
              "type": "string"
            },
            "counterparty_version": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_try": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Open Ack",
          "type": "object"
        },
        "MsgChannelOpenConfirm": {
          "additionalProperties": false,
          "description": "MsgChannelOpenConfirm defines a msg sent by a Relayer to Chain B to acknowledge the change of channel state to OPEN on Chain A.",
          "properties": {
            "channel_id": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            },
            "proof_ack": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Open Confirm",
          "type": "object"
        },
        "MsgChannelOpenInit": {
          "additionalProperties": false,
          "description": "MsgChannelOpenInit defines an sdk.Msg to initialize a channel handshake. It is called by a relayer on Chain A.",
          "properties": {
            "channel": {
              "$ref": "#/definitions/ibc.core.channel.v1.Channel",
              "additionalProperties": false
            },
            "port_id": {
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Open Init",
          "type": "object"
        },
        "MsgChannelOpenTry": {
          "additionalProperties": false,
          "description": "MsgChannelOpenInit defines a msg sent by a Relayer to try to open a channel on Chain B. The version field within the Channel field has been deprecated. Its value will be ignored by core IBC.",
          "properties": {
            "channel": {
              "$ref": "#/definitions/ibc.core.channel.v1.Channel",
              "additionalProperties": false,
              "description": "NOTE: the version field within the channel has been deprecated. Its value will be ignored by core IBC."
            },
            "counterparty_version": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            },
            "previous_channel_id": {
              "description": "Deprecated: this field is unused. Crossing hello's are no longer supported in core IBC.",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_init": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Open Try",
          "type": "object"
        },
        "MsgConnectionOpenAck": {
          "additionalProperties": false,
          "description": "MsgConnectionOpenAck defines a msg sent by a Relayer to Chain A to acknowledge the change of connection state to TRYOPEN on Chain B.",
          "properties": {
            "client_state": {
              "additionalProperties": false,
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "connection_id": {
              "type": "string"
            },
            "consensus_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "counterparty_connection_id": {
              "type": "string"
            },
            "proof_client": {
              "binaryEncoding": "base64",
              "description": "proof of client state included in message",
              "format": "binary",
              "type": "string"
            },
            "proof_consensus": {
              "binaryEncoding": "base64",
              "description": "proof of client consensus state",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_try": {
              "binaryEncoding": "base64",
              "description": "proof of the initialization the connection on Chain B: `UNITIALIZED -> TRYOPEN`",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            },
            "version": {
              "$ref": "#/definitions/ibc.core.connection.v1.Version",
              "additionalProperties": false
            }
          },
          "title": "Msg Connection Open Ack",
          "type": "object"
        },
        "MsgConnectionOpenConfirm": {
          "additionalProperties": false,
          "description": "MsgConnectionOpenConfirm defines a msg sent by a Relayer to Chain B to acknowledge the change of connection state to OPEN on Chain A.",
          "properties": {
            "connection_id": {
              "type": "string"
            },
            "proof_ack": {
              "binaryEncoding": "base64",
              "description": "proof for the change of the connection state on Chain A: `INIT -> OPEN`",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Connection Open Confirm",
          "type": "object"
        },
        "MsgConnectionOpenInit": {
          "additionalProperties": false,
          "description": "MsgConnectionOpenInit defines the msg sent by an account on Chain A to initialize a connection with Chain B.",
          "properties": {
            "client_id": {
              "type": "string"
            },
            "counterparty": {
              "$ref": "#/definitions/ibc.core.connection.v1.Counterparty",
              "additionalProperties": false
            },
            "delay_period": {
              "type": "string"
            },
            "signer": {
              "type": "string"
            },
            "version": {
              "$ref": "#/definitions/ibc.core.connection.v1.Version",
              "additionalProperties": false
            }
          },
          "title": "Msg Connection Open Init",
          "type": "object"
        },
        "MsgConnectionOpenTry": {
          "additionalProperties": false,
          "description": "MsgConnectionOpenTry defines a msg sent by a Relayer to try to open a connection on Chain B.",
          "properties": {
            "client_id": {
              "type": "string"
            },
            "client_state": {
              "additionalProperties": false,
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "consensus_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "counterparty": {
              "$ref": "#/definitions/ibc.core.connection.v1.Counterparty",
              "additionalProperties": false
            },
            "counterparty_versions": {
              "items": {
                "$ref": "#/definitions/ibc.core.connection.v1.Version"
              },
              "type": "array"
            },
            "delay_period": {
              "type": "string"
            },
            "previous_connection_id": {
              "description": "Deprecated: this field is unused. Crossing hellos are no longer supported in core IBC.",
              "type": "string"
            },
            "proof_client": {
              "binaryEncoding": "base64",
              "description": "proof of client state included in message",
              "format": "binary",
              "type": "string"
            },
            "proof_consensus": {
              "binaryEncoding": "base64",
              "description": "proof of client consensus state",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_init": {
              "binaryEncoding": "base64",
              "description": "proof of the initialization the connection on Chain A: `UNITIALIZED -> INIT`",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Connection Open Try",
          "type": "object"
        },
        "MsgCreateClient": {
          "additionalProperties": false,
          "description": "MsgCreateClient defines a message to create an IBC client",
          "properties": {
            "client_state": {
              "additionalProperties": false,
              "description": "light client state",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "consensus_state": {
              "additionalProperties": false,
              "description": "consensus state associated with the client that corresponds to a given height.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "signer": {
              "description": "signer address",
              "type": "string"
            }
          },
          "title": "Msg Create Client",
          "type": "object"
        },
        "MsgCreateGroup": {
          "additionalProperties": false,
          "description": "Groups  MsgCreateGroup is the Msg/CreateGroup request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "members": {
              "description": "members defines the group members.",
              "items": {
                "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
              },
              "type": "array"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata to attached to the group.",
              "type": "string"
            }
          },
          "title": "Groups",
          "type": "object"
        },
        "MsgCreateGroupPolicy": {
          "additionalProperties": false,
          "description": "Group Policies  MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "decision_policy": {
              "additionalProperties": false,
              "description": "decision_policy specifies the group policy's decision policy.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata attached to the group policy.",
              "type": "string"
            }
          },
          "title": "Group Policies",
          "type": "object"
        },
        "MsgCreateGroupWithPolicy": {
          "additionalProperties": false,
          "description": "MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group and group policy admin.",
              "type": "string"
            },
            "decision_policy": {
              "additionalProperties": false,
              "description": "decision_policy specifies the group policy's decision policy.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "group_metadata": {
              "description": "group_metadata is any arbitrary metadata attached to the group.",
              "type": "string"
            },
            "group_policy_as_admin": {
              "description": "group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group and group policy admin.",
              "type": "boolean"
            },
            "group_policy_metadata": {
              "description": "group_policy_metadata is any arbitrary metadata attached to the group policy.",
              "type": "string"
            },
            "members": {
              "description": "members defines the group members.",
              "items": {
                "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
              },
              "type": "array"
            }
          },
          "title": "Msg Create Group With Policy",
          "type": "object"
        },
        "MsgCreatePeriodicVestingAccount": {
          "additionalProperties": false,
          "description": "MsgCreateVestingAccount defines a message that enables creating a vesting account. Since: cosmos-sdk 0.46",
          "properties": {
            "from_address": {
              "type": "string"
            },
            "start_time": {
              "type": "string"
            },
            "to_address": {
              "type": "string"
            },
            "vesting_periods": {
              "items": {
                "$ref": "#/definitions/cosmos.vesting.v1beta1.Period"
              },
              "type": "array"
            }
          },
          "title": "Msg Create Periodic Vesting Account",
          "type": "object"
        },
        "MsgCreatePermanentLockedAccount": {
          "additionalProperties": false,
          "description": "MsgCreatePermanentLockedAccount defines a message that enables creating a permanent locked account. Since: cosmos-sdk 0.46",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "from_address": {
              "type": "string"
            },
            "to_address": {
              "type": "string"
            }
          },
          "title": "Msg Create Permanent Locked Account",
          "type": "object"
        },
        "MsgCreateScheduledRun": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            },
            "gas": {
              "type": "string"
            },
            "height": {
              "type": "string"
            },
            "msg": {
              "$ref": "#/definitions/dyson.MsgRun",
              "additionalProperties": false
            }
          },
          "title": "Msg Create Scheduled Run",
          "type": "object"
        },
        "MsgCreateStorage": {
          "additionalProperties": false,
          "description": "Create a new storage of arbitrary text",
          "properties": {
            "creator": {
              "description": "The address signing this transaction",
              "type": "string"
            },
            "data": {
              "description": "data to store at this index",
              "type": "string"
            },
            "force": {
              "description": "If true, force will always store the data at this address regardless of already existing storage",
              "type": "boolean"
            },
            "index": {
              "description": "Name of the Storage, must be prefixed with the creators address (for example: \"dys..1a3/some_name\")",
              "type": "string"
            }
          },
          "title": "Msg Create Storage",
          "type": "object"
        },
        "MsgCreateValidator": {
          "additionalProperties": false,
          "description": "MsgCreateValidator defines a SDK message for creating a new validator.",
          "properties": {
            "commission": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.CommissionRates",
              "additionalProperties": false
            },
            "delegator_address": {
              "type": "string"
            },
            "description": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.Description",
              "additionalProperties": false
            },
            "min_self_delegation": {
              "type": "string"
            },
            "pubkey": {
              "additionalProperties": false,
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "validator_address": {
              "type": "string"
            },
            "value": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false
            }
          },
          "title": "Msg Create Validator",
          "type": "object"
        },
        "MsgCreateVestingAccount": {
          "additionalProperties": false,
          "description": "MsgCreateVestingAccount defines a message that enables creating a vesting account.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "delayed": {
              "type": "boolean"
            },
            "end_time": {
              "type": "string"
            },
            "from_address": {
              "type": "string"
            },
            "to_address": {
              "type": "string"
            }
          },
          "title": "Msg Create Vesting Account",
          "type": "object"
        },
        "MsgDelegate": {
          "additionalProperties": false,
          "description": "MsgDelegate defines a SDK message for performing a delegation of coins from a delegator to a validator.",
          "properties": {
            "amount": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false
            },
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Delegate",
          "type": "object"
        },
        "MsgDeleteName": {
          "additionalProperties": false,
          "description": "Delete the Dyson Protocol name",
          "properties": {
            "name": {
              "description": "The name to delete",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            }
          },
          "title": "Msg Delete Name",
          "type": "object"
        },
        "MsgDeleteScheduledRun": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            },
            "index": {
              "type": "string"
            }
          },
          "title": "Msg Delete Scheduled Run",
          "type": "object"
        },
        "MsgDeleteScript": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            }
          },
          "title": "Msg Delete Script",
          "type": "object"
        },
        "MsgDeleteStorage": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            },
            "index": {
              "type": "string"
            }
          },
          "title": "Msg Delete Storage",
          "type": "object"
        },
        "MsgDeployAutonomousScript": {
          "additionalProperties": false,
          "description": "Deploy an Autonomous Script at a new address",
          "properties": {
            "code": {
              "format": "python",
              "type": "string"
            },
            "creator": {
              "type": "string"
            }
          },
          "title": "Msg Deploy Autonomous Script",
          "type": "object"
        },
        "MsgDeposit": {
          "additionalProperties": false,
          "description": "MsgDeposit defines a message to submit a deposit to an existing proposal.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "depositor": {
              "type": "string"
            },
            "proposal_id": {
              "type": "string"
            }
          },
          "title": "Msg Deposit",
          "type": "object"
        },
        "MsgEditValidator": {
          "additionalProperties": false,
          "description": "MsgEditValidator defines a SDK message for editing an existing validator.",
          "properties": {
            "commission_rate": {
              "description": "We pass a reference to the new commission rate and min self delegation as it's not mandatory to update. If not updated, the deserialized rate will be zero with no way to distinguish if an update was intended. REF: #2373",
              "type": "string"
            },
            "description": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.Description",
              "additionalProperties": false
            },
            "min_self_delegation": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Edit Validator",
          "type": "object"
        },
        "MsgExec": {
          "additionalProperties": false,
          "description": "MsgExec is the Msg/Exec request type.",
          "properties": {
            "executor": {
              "description": "executor is the account address used to execute the proposal.",
              "type": "string"
            },
            "proposal_id": {
              "description": "proposal is the unique ID of the proposal.",
              "type": "string"
            }
          },
          "title": "Msg Exec",
          "type": "object"
        },
        "MsgExecLegacyContent": {
          "additionalProperties": false,
          "description": "MsgExecLegacyContent is used to wrap the legacy content field into a message. This ensures backwards compatibility with v1beta1.MsgSubmitProposal.",
          "properties": {
            "authority": {
              "description": "authority must be the gov module address.",
              "type": "string"
            },
            "content": {
              "additionalProperties": false,
              "description": "content is the proposal's content.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "title": "Msg Exec Legacy Content",
          "type": "object"
        },
        "MsgFundCommunityPool": {
          "additionalProperties": false,
          "description": "MsgFundCommunityPool allows an account to directly fund the community pool.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "depositor": {
              "type": "string"
            }
          },
          "title": "Msg Fund Community Pool",
          "type": "object"
        },
        "MsgGrant": {
          "additionalProperties": false,
          "description": "MsgGrant is a request type for Grant method. It declares authorization to the grantee on behalf of the granter with the provided expiration time.",
          "properties": {
            "grant": {
              "$ref": "#/definitions/cosmos.authz.v1beta1.Grant",
              "additionalProperties": false
            },
            "grantee": {
              "type": "string"
            },
            "granter": {
              "type": "string"
            }
          },
          "title": "Msg Grant",
          "type": "object"
        },
        "MsgGrantAllowance": {
          "additionalProperties": false,
          "description": "MsgGrantAllowance adds permission for Grantee to spend up to Allowance of fees from the account of Granter.",
          "properties": {
            "allowance": {
              "oneOf": [
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgExec"
                    },
                    "type_url": {
                      "default": "/cosmos.authz.v1beta1.MsgExec",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.authz.v1beta1.MsgExec"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.authz.v1beta1.MsgExec",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgGrant"
                    },
                    "type_url": {
                      "default": "/cosmos.authz.v1beta1.MsgGrant",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.authz.v1beta1.MsgGrant"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.authz.v1beta1.MsgGrant",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgRevoke"
                    },
                    "type_url": {
                      "default": "/cosmos.authz.v1beta1.MsgRevoke",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.authz.v1beta1.MsgRevoke"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.authz.v1beta1.MsgRevoke",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgMultiSend"
                    },
                    "type_url": {
                      "default": "/cosmos.bank.v1beta1.MsgMultiSend",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.bank.v1beta1.MsgMultiSend"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.bank.v1beta1.MsgMultiSend",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgSend"
                    },
                    "type_url": {
                      "default": "/cosmos.bank.v1beta1.MsgSend",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.bank.v1beta1.MsgSend"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.bank.v1beta1.MsgSend",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgVerifyInvariant"
                    },
                    "type_url": {
                      "default": "/cosmos.crisis.v1beta1.MsgVerifyInvariant",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.crisis.v1beta1.MsgVerifyInvariant"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.crisis.v1beta1.MsgVerifyInvariant",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgFundCommunityPool"
                    },
                    "type_url": {
                      "default": "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.distribution.v1beta1.MsgFundCommunityPool"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.distribution.v1beta1.MsgFundCommunityPool",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgSetWithdrawAddress"
                    },
                    "type_url": {
                      "default": "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgWithdrawDelegatorReward"
                    },
                    "type_url": {
                      "default": "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgWithdrawValidatorCommission"
                    },
                    "type_url": {
                      "default": "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgSubmitEvidence"
                    },
                    "type_url": {
                      "default": "/cosmos.evidence.v1beta1.MsgSubmitEvidence",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.evidence.v1beta1.MsgSubmitEvidence"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.evidence.v1beta1.MsgSubmitEvidence",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgGrantAllowance"
                    },
                    "type_url": {
                      "default": "/cosmos.feegrant.v1beta1.MsgGrantAllowance",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.feegrant.v1beta1.MsgGrantAllowance"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.feegrant.v1beta1.MsgGrantAllowance",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgRevokeAllowance"
                    },
                    "type_url": {
                      "default": "/cosmos.feegrant.v1beta1.MsgRevokeAllowance",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.feegrant.v1beta1.MsgRevokeAllowance"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.feegrant.v1beta1.MsgRevokeAllowance",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgDeposit"
                    },
                    "type_url": {
                      "default": "/cosmos.gov.v1.MsgDeposit",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.gov.v1.MsgDeposit"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.gov.v1.MsgDeposit",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgExecLegacyContent"
                    },
                    "type_url": {
                      "default": "/cosmos.gov.v1.MsgExecLegacyContent",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.gov.v1.MsgExecLegacyContent"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.gov.v1.MsgExecLegacyContent",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgSubmitProposal"
                    },
                    "type_url": {
                      "default": "/cosmos.gov.v1.MsgSubmitProposal",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.gov.v1.MsgSubmitProposal"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.gov.v1.MsgSubmitProposal",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgVote"
                    },
                    "type_url": {
                      "default": "/cosmos.gov.v1.MsgVote",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.gov.v1.MsgVote"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.gov.v1.MsgVote",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgVoteWeighted"
                    },
                    "type_url": {
                      "default": "/cosmos.gov.v1.MsgVoteWeighted",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.gov.v1.MsgVoteWeighted"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.gov.v1.MsgVoteWeighted",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgDeposit"
                    },
                    "type_url": {
                      "default": "/cosmos.gov.v1beta1.MsgDeposit",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.gov.v1beta1.MsgDeposit"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.gov.v1beta1.MsgDeposit",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgSubmitProposal"
                    },
                    "type_url": {
                      "default": "/cosmos.gov.v1beta1.MsgSubmitProposal",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.gov.v1beta1.MsgSubmitProposal"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.gov.v1beta1.MsgSubmitProposal",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgVote"
                    },
                    "type_url": {
                      "default": "/cosmos.gov.v1beta1.MsgVote",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.gov.v1beta1.MsgVote"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.gov.v1beta1.MsgVote",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgVoteWeighted"
                    },
                    "type_url": {
                      "default": "/cosmos.gov.v1beta1.MsgVoteWeighted",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.gov.v1beta1.MsgVoteWeighted"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.gov.v1beta1.MsgVoteWeighted",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgCreateGroup"
                    },
                    "type_url": {
                      "default": "/cosmos.group.v1.MsgCreateGroup",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.group.v1.MsgCreateGroup"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.group.v1.MsgCreateGroup",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgCreateGroupPolicy"
                    },
                    "type_url": {
                      "default": "/cosmos.group.v1.MsgCreateGroupPolicy",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.group.v1.MsgCreateGroupPolicy"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.group.v1.MsgCreateGroupPolicy",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgCreateGroupWithPolicy"
                    },
                    "type_url": {
                      "default": "/cosmos.group.v1.MsgCreateGroupWithPolicy",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.group.v1.MsgCreateGroupWithPolicy"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.group.v1.MsgCreateGroupWithPolicy",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgExec"
                    },
                    "type_url": {
                      "default": "/cosmos.group.v1.MsgExec",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.group.v1.MsgExec"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.group.v1.MsgExec",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgLeaveGroup"
                    },
                    "type_url": {
                      "default": "/cosmos.group.v1.MsgLeaveGroup",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.group.v1.MsgLeaveGroup"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.group.v1.MsgLeaveGroup",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgSubmitProposal"
                    },
                    "type_url": {
                      "default": "/cosmos.group.v1.MsgSubmitProposal",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.group.v1.MsgSubmitProposal"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.group.v1.MsgSubmitProposal",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgUpdateGroupAdmin"
                    },
                    "type_url": {
                      "default": "/cosmos.group.v1.MsgUpdateGroupAdmin",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.group.v1.MsgUpdateGroupAdmin"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.group.v1.MsgUpdateGroupAdmin",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgUpdateGroupMembers"
                    },
                    "type_url": {
                      "default": "/cosmos.group.v1.MsgUpdateGroupMembers",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.group.v1.MsgUpdateGroupMembers"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.group.v1.MsgUpdateGroupMembers",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgUpdateGroupMetadata"
                    },
                    "type_url": {
                      "default": "/cosmos.group.v1.MsgUpdateGroupMetadata",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.group.v1.MsgUpdateGroupMetadata"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.group.v1.MsgUpdateGroupMetadata",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgUpdateGroupPolicyAdmin"
                    },
                    "type_url": {
                      "default": "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgUpdateGroupPolicyDecisionPolicy"
                    },
                    "type_url": {
                      "default": "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgUpdateGroupPolicyMetadata"
                    },
                    "type_url": {
                      "default": "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgVote"
                    },
                    "type_url": {
                      "default": "/cosmos.group.v1.MsgVote",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.group.v1.MsgVote"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.group.v1.MsgVote",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgWithdrawProposal"
                    },
                    "type_url": {
                      "default": "/cosmos.group.v1.MsgWithdrawProposal",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.group.v1.MsgWithdrawProposal"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.group.v1.MsgWithdrawProposal",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgSend"
                    },
                    "type_url": {
                      "default": "/cosmos.nft.v1beta1.MsgSend",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.nft.v1beta1.MsgSend"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.nft.v1beta1.MsgSend",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgUnjail"
                    },
                    "type_url": {
                      "default": "/cosmos.slashing.v1beta1.MsgUnjail",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.slashing.v1beta1.MsgUnjail"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.slashing.v1beta1.MsgUnjail",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgBeginRedelegate"
                    },
                    "type_url": {
                      "default": "/cosmos.staking.v1beta1.MsgBeginRedelegate",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.staking.v1beta1.MsgBeginRedelegate"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.staking.v1beta1.MsgBeginRedelegate",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgCancelUnbondingDelegation"
                    },
                    "type_url": {
                      "default": "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgCreateValidator"
                    },
                    "type_url": {
                      "default": "/cosmos.staking.v1beta1.MsgCreateValidator",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.staking.v1beta1.MsgCreateValidator"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.staking.v1beta1.MsgCreateValidator",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgDelegate"
                    },
                    "type_url": {
                      "default": "/cosmos.staking.v1beta1.MsgDelegate",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.staking.v1beta1.MsgDelegate"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.staking.v1beta1.MsgDelegate",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgEditValidator"
                    },
                    "type_url": {
                      "default": "/cosmos.staking.v1beta1.MsgEditValidator",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.staking.v1beta1.MsgEditValidator"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.staking.v1beta1.MsgEditValidator",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgUndelegate"
                    },
                    "type_url": {
                      "default": "/cosmos.staking.v1beta1.MsgUndelegate",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.staking.v1beta1.MsgUndelegate"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.staking.v1beta1.MsgUndelegate",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgCancelUpgrade"
                    },
                    "type_url": {
                      "default": "/cosmos.upgrade.v1beta1.MsgCancelUpgrade",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.upgrade.v1beta1.MsgCancelUpgrade"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.upgrade.v1beta1.MsgCancelUpgrade",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgSoftwareUpgrade"
                    },
                    "type_url": {
                      "default": "/cosmos.upgrade.v1beta1.MsgSoftwareUpgrade",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.upgrade.v1beta1.MsgSoftwareUpgrade"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.upgrade.v1beta1.MsgSoftwareUpgrade",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgCreatePeriodicVestingAccount"
                    },
                    "type_url": {
                      "default": "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgCreatePermanentLockedAccount"
                    },
                    "type_url": {
                      "default": "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgCreateVestingAccount"
                    },
                    "type_url": {
                      "default": "/cosmos.vesting.v1beta1.MsgCreateVestingAccount",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.vesting.v1beta1.MsgCreateVestingAccount"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.vesting.v1beta1.MsgCreateVestingAccount",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgCreateScheduledRun"
                    },
                    "type_url": {
                      "default": "/dyson.MsgCreateScheduledRun",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/dyson.MsgCreateScheduledRun"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "dyson.MsgCreateScheduledRun",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgCreateStorage"
                    },
                    "type_url": {
                      "default": "/dyson.MsgCreateStorage",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/dyson.MsgCreateStorage"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "dyson.MsgCreateStorage",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgDeleteScheduledRun"
                    },
                    "type_url": {
                      "default": "/dyson.MsgDeleteScheduledRun",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/dyson.MsgDeleteScheduledRun"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "dyson.MsgDeleteScheduledRun",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgDeleteScript"
                    },
                    "type_url": {
                      "default": "/dyson.MsgDeleteScript",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/dyson.MsgDeleteScript"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "dyson.MsgDeleteScript",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgDeleteStorage"
                    },
                    "type_url": {
                      "default": "/dyson.MsgDeleteStorage",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/dyson.MsgDeleteStorage"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "dyson.MsgDeleteStorage",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgDeployAutonomousScript"
                    },
                    "type_url": {
                      "default": "/dyson.MsgDeployAutonomousScript",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/dyson.MsgDeployAutonomousScript"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "dyson.MsgDeployAutonomousScript",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgRun"
                    },
                    "type_url": {
                      "default": "/dyson.MsgRun",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/dyson.MsgRun"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "dyson.MsgRun",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgUpdateScheduledRun"
                    },
                    "type_url": {
                      "default": "/dyson.MsgUpdateScheduledRun",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/dyson.MsgUpdateScheduledRun"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "dyson.MsgUpdateScheduledRun",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgUpdateScript"
                    },
                    "type_url": {
                      "default": "/dyson.MsgUpdateScript",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/dyson.MsgUpdateScript"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "dyson.MsgUpdateScript",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgUpdateStorage"
                    },
                    "type_url": {
                      "default": "/dyson.MsgUpdateStorage",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/dyson.MsgUpdateStorage"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "dyson.MsgUpdateStorage",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgRegisterInterchainAccount"
                    },
                    "type_url": {
                      "default": "/ibc.applications.interchain_accounts.controller.v1.MsgRegisterInterchainAccount",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.applications.interchain_accounts.controller.v1.MsgRegisterInterchainAccount"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.applications.interchain_accounts.controller.v1.MsgRegisterInterchainAccount",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgSendTx"
                    },
                    "type_url": {
                      "default": "/ibc.applications.interchain_accounts.controller.v1.MsgSendTx",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.applications.interchain_accounts.controller.v1.MsgSendTx"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.applications.interchain_accounts.controller.v1.MsgSendTx",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgTransfer"
                    },
                    "type_url": {
                      "default": "/ibc.applications.transfer.v1.MsgTransfer",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.applications.transfer.v1.MsgTransfer"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.applications.transfer.v1.MsgTransfer",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgAcknowledgement"
                    },
                    "type_url": {
                      "default": "/ibc.core.channel.v1.MsgAcknowledgement",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.channel.v1.MsgAcknowledgement"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.channel.v1.MsgAcknowledgement",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgChannelCloseConfirm"
                    },
                    "type_url": {
                      "default": "/ibc.core.channel.v1.MsgChannelCloseConfirm",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.channel.v1.MsgChannelCloseConfirm"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.channel.v1.MsgChannelCloseConfirm",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgChannelCloseInit"
                    },
                    "type_url": {
                      "default": "/ibc.core.channel.v1.MsgChannelCloseInit",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.channel.v1.MsgChannelCloseInit"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.channel.v1.MsgChannelCloseInit",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgChannelOpenAck"
                    },
                    "type_url": {
                      "default": "/ibc.core.channel.v1.MsgChannelOpenAck",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.channel.v1.MsgChannelOpenAck"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.channel.v1.MsgChannelOpenAck",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgChannelOpenConfirm"
                    },
                    "type_url": {
                      "default": "/ibc.core.channel.v1.MsgChannelOpenConfirm",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.channel.v1.MsgChannelOpenConfirm"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.channel.v1.MsgChannelOpenConfirm",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgChannelOpenInit"
                    },
                    "type_url": {
                      "default": "/ibc.core.channel.v1.MsgChannelOpenInit",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.channel.v1.MsgChannelOpenInit"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.channel.v1.MsgChannelOpenInit",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgChannelOpenTry"
                    },
                    "type_url": {
                      "default": "/ibc.core.channel.v1.MsgChannelOpenTry",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.channel.v1.MsgChannelOpenTry"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.channel.v1.MsgChannelOpenTry",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgRecvPacket"
                    },
                    "type_url": {
                      "default": "/ibc.core.channel.v1.MsgRecvPacket",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.channel.v1.MsgRecvPacket"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.channel.v1.MsgRecvPacket",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgTimeout"
                    },
                    "type_url": {
                      "default": "/ibc.core.channel.v1.MsgTimeout",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.channel.v1.MsgTimeout"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.channel.v1.MsgTimeout",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgTimeoutOnClose"
                    },
                    "type_url": {
                      "default": "/ibc.core.channel.v1.MsgTimeoutOnClose",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.channel.v1.MsgTimeoutOnClose"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.channel.v1.MsgTimeoutOnClose",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgCreateClient"
                    },
                    "type_url": {
                      "default": "/ibc.core.client.v1.MsgCreateClient",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.client.v1.MsgCreateClient"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.client.v1.MsgCreateClient",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgSubmitMisbehaviour"
                    },
                    "type_url": {
                      "default": "/ibc.core.client.v1.MsgSubmitMisbehaviour",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.client.v1.MsgSubmitMisbehaviour"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.client.v1.MsgSubmitMisbehaviour",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgUpdateClient"
                    },
                    "type_url": {
                      "default": "/ibc.core.client.v1.MsgUpdateClient",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.client.v1.MsgUpdateClient"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.client.v1.MsgUpdateClient",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgUpgradeClient"
                    },
                    "type_url": {
                      "default": "/ibc.core.client.v1.MsgUpgradeClient",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.client.v1.MsgUpgradeClient"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.client.v1.MsgUpgradeClient",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgConnectionOpenAck"
                    },
                    "type_url": {
                      "default": "/ibc.core.connection.v1.MsgConnectionOpenAck",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.connection.v1.MsgConnectionOpenAck"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.connection.v1.MsgConnectionOpenAck",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgConnectionOpenConfirm"
                    },
                    "type_url": {
                      "default": "/ibc.core.connection.v1.MsgConnectionOpenConfirm",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.connection.v1.MsgConnectionOpenConfirm"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.connection.v1.MsgConnectionOpenConfirm",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgConnectionOpenInit"
                    },
                    "type_url": {
                      "default": "/ibc.core.connection.v1.MsgConnectionOpenInit",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.connection.v1.MsgConnectionOpenInit"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.connection.v1.MsgConnectionOpenInit",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgConnectionOpenTry"
                    },
                    "type_url": {
                      "default": "/ibc.core.connection.v1.MsgConnectionOpenTry",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.connection.v1.MsgConnectionOpenTry"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.connection.v1.MsgConnectionOpenTry",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgAccept"
                    },
                    "type_url": {
                      "default": "/names.MsgAccept",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/names.MsgAccept"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "names.MsgAccept",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgBurnCoins"
                    },
                    "type_url": {
                      "default": "/names.MsgBurnCoins",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/names.MsgBurnCoins"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "names.MsgBurnCoins",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgBurnNft"
                    },
                    "type_url": {
                      "default": "/names.MsgBurnNft",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/names.MsgBurnNft"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "names.MsgBurnNft",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgBuy"
                    },
                    "type_url": {
                      "default": "/names.MsgBuy",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/names.MsgBuy"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "names.MsgBuy",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgDeleteName"
                    },
                    "type_url": {
                      "default": "/names.MsgDeleteName",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/names.MsgDeleteName"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "names.MsgDeleteName",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgMintCoins"
                    },
                    "type_url": {
                      "default": "/names.MsgMintCoins",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/names.MsgMintCoins"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "names.MsgMintCoins",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgMintNft"
                    },
                    "type_url": {
                      "default": "/names.MsgMintNft",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/names.MsgMintNft"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "names.MsgMintNft",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgOfferTo"
                    },
                    "type_url": {
                      "default": "/names.MsgOfferTo",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/names.MsgOfferTo"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "names.MsgOfferTo",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgRegister"
                    },
                    "type_url": {
                      "default": "/names.MsgRegister",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/names.MsgRegister"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "names.MsgRegister",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgReveal"
                    },
                    "type_url": {
                      "default": "/names.MsgReveal",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/names.MsgReveal"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "names.MsgReveal",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgSetNftClass"
                    },
                    "type_url": {
                      "default": "/names.MsgSetNftClass",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/names.MsgSetNftClass"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "names.MsgSetNftClass",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgSetPriceAndExtend"
                    },
                    "type_url": {
                      "default": "/names.MsgSetPriceAndExtend",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/names.MsgSetPriceAndExtend"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "names.MsgSetPriceAndExtend",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgUpdateName"
                    },
                    "type_url": {
                      "default": "/names.MsgUpdateName",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/names.MsgUpdateName"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "names.MsgUpdateName",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/MsgUpdateNft"
                    },
                    "type_url": {
                      "default": "/names.MsgUpdateNft",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/names.MsgUpdateNft"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "names.MsgUpdateNft",
                  "type": "object"
                }
              ]
            },
            "grantee": {
              "description": "grantee is the address of the user being granted an allowance of another user's funds.",
              "type": "string"
            },
            "granter": {
              "description": "granter is the address of the user granting an allowance of their funds.",
              "type": "string"
            }
          },
          "title": "Msg Grant Allowance",
          "type": "object"
        },
        "MsgLeaveGroup": {
          "additionalProperties": false,
          "description": "MsgLeaveGroup is the Msg/LeaveGroup request type.",
          "properties": {
            "address": {
              "description": "address is the account address of the group member.",
              "type": "string"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            }
          },
          "title": "Msg Leave Group",
          "type": "object"
        },
        "MsgMintCoins": {
          "additionalProperties": false,
          "description": "Mint coins with a denom of a name or subname. For example if you own the name \"example.dys\" you can mint coins with the denom \"example.dys\" or \"subname.example.dys\"",
          "properties": {
            "amount": {
              "description": "The amount of coins to mint in the format \"[amount] [denom]\".   Each coin costs 1 gas.",
              "type": "string"
            },
            "owner": {
              "description": "The owner of the Dys name",
              "type": "string"
            }
          },
          "title": "Msg Mint Coins",
          "type": "object"
        },
        "MsgMintNft": {
          "additionalProperties": false,
          "description": "Mint an NFT with the given class ID and NFT ID. The NFT ID is unique to the class ID.",
          "properties": {
            "class_id": {
              "description": "the NFT Class ID",
              "type": "string"
            },
            "class_owner": {
              "description": "The owner of the Dys name",
              "type": "string"
            },
            "id": {
              "description": "The ID of this NFT, must be unique to the class ID",
              "type": "string"
            },
            "uri": {
              "description": "The URI of the NFT (optional)",
              "type": "string"
            },
            "uri_hash": {
              "description": "The URI hash of the NFT (optional)",
              "type": "string"
            }
          },
          "title": "Msg Mint Nft",
          "type": "object"
        },
        "MsgMultiSend": {
          "additionalProperties": false,
          "description": "MsgMultiSend represents an arbitrary multi-in, multi-out send message.",
          "properties": {
            "inputs": {
              "items": {
                "$ref": "#/definitions/cosmos.bank.v1beta1.Input"
              },
              "type": "array"
            },
            "outputs": {
              "items": {
                "$ref": "#/definitions/cosmos.bank.v1beta1.Output"
              },
              "type": "array"
            }
          },
          "title": "Msg Multi Send",
          "type": "object"
        },
        "MsgOfferTo": {
          "additionalProperties": false,
          "description": "Offer the name to a new owner",
          "properties": {
            "name": {
              "description": "The name to offer",
              "type": "string"
            },
            "new_owner": {
              "description": "The address to offer the name to. They can take ownership of the name with the Accept message",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            }
          },
          "title": "Msg Offer To",
          "type": "object"
        },
        "MsgRecvPacket": {
          "additionalProperties": false,
          "description": "MsgRecvPacket receives incoming IBC packet",
          "properties": {
            "packet": {
              "$ref": "#/definitions/ibc.core.channel.v1.Packet",
              "additionalProperties": false
            },
            "proof_commitment": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Recv Packet",
          "type": "object"
        },
        "MsgRegister": {
          "additionalProperties": false,
          "properties": {
            "auto_renew": {
              "description": "Should the name be automatically renewed",
              "type": "boolean"
            },
            "commit": {
              "description": "The Shake256(owner+name+salt) hexdigest",
              "type": "string"
            },
            "owner": {
              "description": "Address of the owner",
              "type": "string"
            },
            "price": {
              "description": "The price that this name is valued at and can be purchased for example 100dys. The yearly fee (31,536,000 blocks) is 1% of this price.",
              "type": "string"
            }
          },
          "title": "Msg Register",
          "type": "object"
        },
        "MsgRegisterInterchainAccount": {
          "additionalProperties": false,
          "description": "MsgRegisterInterchainAccount defines the payload for Msg/MsgRegisterInterchainAccount",
          "properties": {
            "connection_id": {
              "type": "string"
            },
            "owner": {
              "type": "string"
            },
            "version": {
              "type": "string"
            }
          },
          "title": "Msg Register Interchain Account",
          "type": "object"
        },
        "MsgReveal": {
          "additionalProperties": false,
          "description": "Reveal the name that was committed to with the Register message",
          "properties": {
            "name": {
              "description": "The name to reveal",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            },
            "salt": {
              "description": "The salt that was used to commit to the name",
              "type": "string"
            }
          },
          "title": "Msg Reveal",
          "type": "object"
        },
        "MsgRevoke": {
          "additionalProperties": false,
          "description": "MsgRevoke revokes any authorization with the provided sdk.Msg type on the granter's account with that has been granted to the grantee.",
          "properties": {
            "grantee": {
              "type": "string"
            },
            "granter": {
              "type": "string"
            },
            "msg_type_url": {
              "type": "string"
            }
          },
          "title": "Msg Revoke",
          "type": "object"
        },
        "MsgRevokeAllowance": {
          "additionalProperties": false,
          "description": "MsgRevokeAllowance removes any existing Allowance from Granter to Grantee.",
          "properties": {
            "grantee": {
              "description": "grantee is the address of the user being granted an allowance of another user's funds.",
              "type": "string"
            },
            "granter": {
              "description": "granter is the address of the user granting an allowance of their funds.",
              "type": "string"
            }
          },
          "title": "Msg Revoke Allowance",
          "type": "object"
        },
        "MsgRun": {
          "additionalProperties": false,
          "description": "MsgRun runs a script at a specific address",
          "properties": {
            "address": {
              "description": "Dys address of the script to call",
              "type": "string"
            },
            "args": {
              "description": "Optional args to call the function with",
              "type": "string"
            },
            "coins": {
              "description": "Optional comma seperated list of coins to send the script (for example \"123dys,456token\") this entire amount will be sent to the script",
              "type": "string"
            },
            "creator": {
              "description": "The account sending this transaction",
              "type": "string"
            },
            "extra_lines": {
              "description": "Optional extra source code to append to the end of the script before running. Only available to the script address itself.",
              "type": "string"
            },
            "function_name": {
              "description": "Optional function to call",
              "type": "string"
            },
            "kwargs": {
              "description": "Optional kwargs to run",
              "type": "string"
            },
            "nfts": {
              "description": "Optional NFTs to send the script, formatted [class_id]/[id], [class_id]/[id] (for example \"example.dys/123, example.dys/456\")",
              "type": "string"
            }
          },
          "title": "Msg Run",
          "type": "object"
        },
        "MsgSend": {
          "additionalProperties": false,
          "description": "MsgSend represents a message to send a nft from one account to another account.",
          "properties": {
            "class_id": {
              "description": "class_id defines the unique identifier of the nft classification, similar to the contract address of ERC721",
              "type": "string"
            },
            "id": {
              "description": "id defines the unique identification of nft",
              "type": "string"
            },
            "receiver": {
              "description": "receiver is the receiver address of nft",
              "type": "string"
            },
            "sender": {
              "description": "sender is the address of the owner of nft",
              "type": "string"
            }
          },
          "title": "Msg Send",
          "type": "object"
        },
        "MsgSendTx": {
          "additionalProperties": false,
          "description": "MsgSendTx defines the payload for Msg/SendTx",
          "properties": {
            "connection_id": {
              "type": "string"
            },
            "owner": {
              "type": "string"
            },
            "packet_data": {
              "$ref": "#/definitions/ibc.applications.interchain_accounts.v1.InterchainAccountPacketData",
              "additionalProperties": false
            },
            "relative_timeout": {
              "description": "Relative timeout timestamp provided will be added to the current block time during transaction execution. The timeout timestamp must be non-zero.",
              "type": "string"
            }
          },
          "title": "Msg Send Tx",
          "type": "object"
        },
        "MsgSetNftClass": {
          "additionalProperties": false,
          "description": "Create or update an NFT class. The NFT class is identified by the Dys name of the class ID.",
          "properties": {
            "description": {
              "description": "The  description of the NFT class (optional)",
              "type": "string"
            },
            "id": {
              "description": "the ID is the Dys name or subname of the NFT class. For example if you own the name \"example.dys\" you can create an NFT class with the ID \"example.dys\" or \"subname.example.dys\"",
              "type": "string"
            },
            "name": {
              "description": "More descriptive name of the NFT class (optional)",
              "type": "string"
            },
            "owner": {
              "description": "The owner of the Dys name of the NFT class ID",
              "type": "string"
            },
            "symbol": {
              "description": "The symbol of the NFT class (optional)",
              "type": "string"
            },
            "uri": {
              "description": "The URI of the NFT class (optional)",
              "type": "string"
            },
            "uri_hash": {
              "description": "The URI hash of the NFT class (optional)",
              "type": "string"
            }
          },
          "title": "Msg Set Nft Class",
          "type": "object"
        },
        "MsgSetPriceAndExtend": {
          "additionalProperties": false,
          "description": "Set the price of the name and extend the expiration height",
          "properties": {
            "name": {
              "description": "The name to set the price for",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            },
            "price": {
              "description": "The new price that this name is valued at and can be purchased for example 100dys. The fee is 1% of this price and will be paid by the owner now. The expiration height is extended by 31,536,000 blocks.",
              "type": "string"
            }
          },
          "title": "Msg Set Price And Extend",
          "type": "object"
        },
        "MsgSetWithdrawAddress": {
          "additionalProperties": false,
          "description": "MsgSetWithdrawAddress sets the withdraw address for a delegator (or validator self-delegation).",
          "properties": {
            "delegator_address": {
              "type": "string"
            },
            "withdraw_address": {
              "type": "string"
            }
          },
          "title": "Msg Set Withdraw Address",
          "type": "object"
        },
        "MsgSoftwareUpgrade": {
          "additionalProperties": false,
          "description": "MsgSoftwareUpgrade is the Msg/SoftwareUpgrade request type. Since: cosmos-sdk 0.46",
          "properties": {
            "authority": {
              "description": "authority is the address of the governance account.",
              "type": "string"
            },
            "plan": {
              "$ref": "#/definitions/cosmos.upgrade.v1beta1.Plan",
              "additionalProperties": false,
              "description": "plan is the upgrade plan."
            }
          },
          "title": "Msg Software Upgrade",
          "type": "object"
        },
        "MsgSubmitEvidence": {
          "additionalProperties": false,
          "description": "MsgSubmitEvidence represents a message that supports submitting arbitrary Evidence of misbehavior such as equivocation or counterfactual signing.",
          "properties": {
            "evidence": {
              "additionalProperties": false,
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "submitter": {
              "type": "string"
            }
          },
          "title": "Msg Submit Evidence",
          "type": "object"
        },
        "MsgSubmitMisbehaviour": {
          "additionalProperties": false,
          "description": "MsgSubmitMisbehaviour defines an sdk.Msg type that submits Evidence for light client misbehaviour.",
          "properties": {
            "client_id": {
              "description": "client unique identifier",
              "type": "string"
            },
            "misbehaviour": {
              "additionalProperties": false,
              "description": "misbehaviour used for freezing the light client",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "signer": {
              "description": "signer address",
              "type": "string"
            }
          },
          "title": "Msg Submit Misbehaviour",
          "type": "object"
        },
        "MsgSubmitProposal": {
          "additionalProperties": false,
          "description": "MsgSubmitProposal is the Msg/SubmitProposal request type.",
          "properties": {
            "exec": {
              "description": "Proposals and Voting  Exec defines modes of execution of a proposal on creation or on new vote.",
              "enum": [
                "EXEC_UNSPECIFIED",
                0,
                "EXEC_TRY",
                1
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Proposals and Voting"
            },
            "group_policy_address": {
              "description": "group_policy_address is the account address of group policy.",
              "type": "string"
            },
            "messages": {
              "description": "messages is a list of `sdk.Msg`s that will be executed if the proposal passes.",
              "items": {
                "additionalProperties": false,
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message. Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type. Example 1: Pack and unpack a message in C++.     Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     } Example 2: Pack and unpack a message in Java.     Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }  Example 3: Pack and unpack a message in Python.     foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...  Example 4: Pack and unpack a message in Go      foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      } The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\". JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:     package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }     {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     } If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):     {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }",
                "properties": {
                  "type_url": {
                    "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                    "type": "string"
                  },
                  "value": {
                    "binaryEncoding": "base64",
                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                    "format": "binary",
                    "type": "string"
                  }
                },
                "title": "Any",
                "type": "object"
              },
              "type": "array"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata to attached to the proposal.",
              "type": "string"
            },
            "proposers": {
              "description": "proposers are the account addresses of the proposers. Proposers signatures will be counted as yes votes.",
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          },
          "title": "Msg Submit Proposal",
          "type": "object"
        },
        "MsgTimeout": {
          "additionalProperties": false,
          "description": "MsgTimeout receives timed-out packet",
          "properties": {
            "next_sequence_recv": {
              "type": "string"
            },
            "packet": {
              "$ref": "#/definitions/ibc.core.channel.v1.Packet",
              "additionalProperties": false
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_unreceived": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Timeout",
          "type": "object"
        },
        "MsgTimeoutOnClose": {
          "additionalProperties": false,
          "description": "MsgTimeoutOnClose timed-out packet upon counterparty channel closure.",
          "properties": {
            "next_sequence_recv": {
              "type": "string"
            },
            "packet": {
              "$ref": "#/definitions/ibc.core.channel.v1.Packet",
              "additionalProperties": false
            },
            "proof_close": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_unreceived": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Timeout On Close",
          "type": "object"
        },
        "MsgTransfer": {
          "additionalProperties": false,
          "description": "MsgTransfer defines a msg to transfer fungible tokens (i.e Coins) between ICS20 enabled chains. See ICS Spec here: https://github.com/cosmos/ibc/tree/master/spec/app/ics-020-fungible-token-transfer#data-structures",
          "properties": {
            "memo": {
              "description": "optional memo",
              "type": "string"
            },
            "receiver": {
              "description": "the recipient address on the destination chain",
              "type": "string"
            },
            "sender": {
              "description": "the sender address",
              "type": "string"
            },
            "source_channel": {
              "description": "the channel by which the packet will be sent",
              "type": "string"
            },
            "source_port": {
              "description": "the port on which the packet will be sent",
              "type": "string"
            },
            "timeout_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false,
              "description": "Timeout height relative to the current block height. The timeout is disabled when set to 0."
            },
            "timeout_timestamp": {
              "description": "Timeout timestamp in absolute nanoseconds since unix epoch. The timeout is disabled when set to 0.",
              "type": "string"
            },
            "token": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false,
              "description": "the tokens to be transferred"
            }
          },
          "title": "Msg Transfer",
          "type": "object"
        },
        "MsgUndelegate": {
          "additionalProperties": false,
          "description": "MsgUndelegate defines a SDK message for performing an undelegation from a delegate and a validator.",
          "properties": {
            "amount": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false
            },
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Undelegate",
          "type": "object"
        },
        "MsgUnjail": {
          "additionalProperties": false,
          "description": "MsgUnjail defines the Msg/Unjail request type",
          "properties": {
            "validator_addr": {
              "type": "string"
            }
          },
          "title": "Msg Unjail",
          "type": "object"
        },
        "MsgUpdateClient": {
          "additionalProperties": false,
          "description": "MsgUpdateClient defines an sdk.Msg to update a IBC client state using the given header.",
          "properties": {
            "client_id": {
              "description": "client unique identifier",
              "type": "string"
            },
            "header": {
              "additionalProperties": false,
              "description": "header to update the light client",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "signer": {
              "description": "signer address",
              "type": "string"
            }
          },
          "title": "Msg Update Client",
          "type": "object"
        },
        "MsgUpdateGroupAdmin": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.",
          "properties": {
            "admin": {
              "description": "admin is the current account address of the group admin.",
              "type": "string"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "new_admin": {
              "description": "new_admin is the group new admin account address.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Admin",
          "type": "object"
        },
        "MsgUpdateGroupMembers": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "member_updates": {
              "description": "member_updates is the list of members to update, set weight to 0 to remove a member.",
              "items": {
                "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
              },
              "type": "array"
            }
          },
          "title": "Msg Update Group Members",
          "type": "object"
        },
        "MsgUpdateGroupMetadata": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is the updated group's metadata.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Metadata",
          "type": "object"
        },
        "MsgUpdateGroupPolicyAdmin": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "group_policy_address": {
              "description": "group_policy_address is the account address of the group policy.",
              "type": "string"
            },
            "new_admin": {
              "description": "new_admin is the new group policy admin.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Policy Admin",
          "type": "object"
        },
        "MsgUpdateGroupPolicyDecisionPolicy": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "decision_policy": {
              "additionalProperties": false,
              "description": "decision_policy is the updated group policy's decision policy.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "group_policy_address": {
              "description": "group_policy_address is the account address of group policy.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Policy Decision Policy",
          "type": "object"
        },
        "MsgUpdateGroupPolicyMetadata": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "group_policy_address": {
              "description": "group_policy_address is the account address of group policy.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is the updated group policy metadata.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Policy Metadata",
          "type": "object"
        },
        "MsgUpdateName": {
          "additionalProperties": false,
          "description": "Update the details of the Dyson Protocol name",
          "properties": {
            "authorized": {
              "description": "The address that this name is OfferedTo, they can take ownership of the name with the Accept message",
              "type": "string"
            },
            "auto_renew": {
              "description": "Will the name be automatically renewed at the expiration height. The expiration height is extended by 31,536,000 blocks (about 1 year). The fee is 1% of the price and is paid by the owner at the time of the renewal.",
              "type": "boolean"
            },
            "destination": {
              "description": "The new destination address for the name",
              "type": "string"
            },
            "name": {
              "description": "The name to update",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            }
          },
          "title": "Msg Update Name",
          "type": "object"
        },
        "MsgUpdateNft": {
          "additionalProperties": false,
          "description": "Update the details of an NFT",
          "properties": {
            "class_id": {
              "description": "the NFT Class ID",
              "type": "string"
            },
            "class_owner": {
              "description": "The owner of the NFT Class",
              "type": "string"
            },
            "id": {
              "description": "The ID of this NFT to update",
              "type": "string"
            },
            "uri": {
              "description": "The URI of the NFT (optional)",
              "type": "string"
            },
            "uri_hash": {
              "description": "The URI hash of the NFT (optional)",
              "type": "string"
            }
          },
          "title": "Msg Update Nft",
          "type": "object"
        },
        "MsgUpdateScheduledRun": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            },
            "index": {
              "type": "string"
            },
            "msg": {
              "$ref": "#/definitions/dyson.MsgRun",
              "additionalProperties": false
            }
          },
          "title": "Msg Update Scheduled Run",
          "type": "object"
        },
        "MsgUpdateScript": {
          "additionalProperties": false,
          "properties": {
            "code": {
              "format": "python",
              "type": "string"
            },
            "creator": {
              "type": "string"
            }
          },
          "title": "Msg Update Script",
          "type": "object"
        },
        "MsgUpdateStorage": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "description": "The address signing this transaction",
              "type": "string"
            },
            "data": {
              "description": "data to store at this index",
              "type": "string"
            },
            "force": {
              "description": "If true, force will always store the data at this address regardless of already existing storage",
              "type": "boolean"
            },
            "index": {
              "description": "Name of the Storage, must be prefixed with the creators address (for example: \"dys..1a3/some_name\")",
              "type": "string"
            }
          },
          "title": "Msg Update Storage",
          "type": "object"
        },
        "MsgUpgradeClient": {
          "additionalProperties": false,
          "description": "MsgUpgradeClient defines an sdk.Msg to upgrade an IBC client to a new client state",
          "properties": {
            "client_id": {
              "description": "client unique identifier",
              "type": "string"
            },
            "client_state": {
              "additionalProperties": false,
              "description": "upgraded client state",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "consensus_state": {
              "additionalProperties": false,
              "description": "upgraded consensus state, only contains enough information to serve as a basis of trust in update logic",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "proof_upgrade_client": {
              "binaryEncoding": "base64",
              "description": "proof that old chain committed to new client",
              "format": "binary",
              "type": "string"
            },
            "proof_upgrade_consensus_state": {
              "binaryEncoding": "base64",
              "description": "proof that old chain committed to new consensus state",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "description": "signer address",
              "type": "string"
            }
          },
          "title": "Msg Upgrade Client",
          "type": "object"
        },
        "MsgVerifyInvariant": {
          "additionalProperties": false,
          "description": "MsgVerifyInvariant represents a message to verify a particular invariance.",
          "properties": {
            "invariant_module_name": {
              "type": "string"
            },
            "invariant_route": {
              "type": "string"
            },
            "sender": {
              "type": "string"
            }
          },
          "title": "Msg Verify Invariant",
          "type": "object"
        },
        "MsgVote": {
          "additionalProperties": false,
          "description": "MsgVote is the Msg/Vote request type.",
          "properties": {
            "exec": {
              "description": "Proposals and Voting  Exec defines modes of execution of a proposal on creation or on new vote.",
              "enum": [
                "EXEC_UNSPECIFIED",
                0,
                "EXEC_TRY",
                1
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Proposals and Voting"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata to attached to the vote.",
              "type": "string"
            },
            "option": {
              "description": "VoteOption enumerates the valid vote options for a given proposal.",
              "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                0,
                "VOTE_OPTION_YES",
                1,
                "VOTE_OPTION_ABSTAIN",
                2,
                "VOTE_OPTION_NO",
                3,
                "VOTE_OPTION_NO_WITH_VETO",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Vote Option"
            },
            "proposal_id": {
              "description": "proposal is the unique ID of the proposal.",
              "type": "string"
            },
            "voter": {
              "description": "voter is the voter account address.",
              "type": "string"
            }
          },
          "title": "Msg Vote",
          "type": "object"
        },
        "MsgVoteWeighted": {
          "additionalProperties": false,
          "description": "MsgVoteWeighted defines a message to cast a vote. Since: cosmos-sdk 0.43",
          "properties": {
            "options": {
              "items": {
                "$ref": "#/definitions/cosmos.gov.v1beta1.WeightedVoteOption"
              },
              "type": "array"
            },
            "proposal_id": {
              "type": "string"
            },
            "voter": {
              "type": "string"
            }
          },
          "title": "Msg Vote Weighted",
          "type": "object"
        },
        "MsgWithdrawDelegatorReward": {
          "additionalProperties": false,
          "description": "MsgWithdrawDelegatorReward represents delegation withdrawal to a delegator from a single validator.",
          "properties": {
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Withdraw Delegator Reward",
          "type": "object"
        },
        "MsgWithdrawProposal": {
          "additionalProperties": false,
          "description": "MsgWithdrawProposal is the Msg/WithdrawProposal request type.",
          "properties": {
            "address": {
              "description": "address is the admin of the group policy or one of the proposer of the proposal.",
              "type": "string"
            },
            "proposal_id": {
              "description": "proposal is the unique ID of the proposal.",
              "type": "string"
            }
          },
          "title": "Msg Withdraw Proposal",
          "type": "object"
        },
        "MsgWithdrawValidatorCommission": {
          "additionalProperties": false,
          "description": "MsgWithdrawValidatorCommission withdraws the full commission to the validator address.",
          "properties": {
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Withdraw Validator Commission",
          "type": "object"
        },
        "cosmos.authz.v1beta1.Grant": {
          "additionalProperties": false,
          "description": "Grant gives permissions to execute the provide method with expiration time.",
          "properties": {
            "authorization": {
              "additionalProperties": false,
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "expiration": {
              "description": "time when the grant will expire and will be pruned. If null, then the grant doesn't have a time expiration (other conditions  in `authorization` may apply to invalidate the grant)",
              "format": "date-time",
              "type": "string"
            }
          },
          "title": "Grant",
          "type": "object"
        },
        "cosmos.bank.v1beta1.Input": {
          "additionalProperties": false,
          "description": "Input models transaction input.",
          "properties": {
            "address": {
              "type": "string"
            },
            "coins": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            }
          },
          "title": "Input",
          "type": "object"
        },
        "cosmos.bank.v1beta1.Output": {
          "additionalProperties": false,
          "description": "Output models transaction outputs.",
          "properties": {
            "address": {
              "type": "string"
            },
            "coins": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            }
          },
          "title": "Output",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        },
        "cosmos.gov.v1.WeightedVoteOption": {
          "additionalProperties": false,
          "description": "WeightedVoteOption defines a unit of vote for vote split.",
          "properties": {
            "option": {
              "description": "VoteOption enumerates the valid vote options for a given governance proposal.",
              "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                0,
                "VOTE_OPTION_YES",
                1,
                "VOTE_OPTION_ABSTAIN",
                2,
                "VOTE_OPTION_NO",
                3,
                "VOTE_OPTION_NO_WITH_VETO",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Vote Option"
            },
            "weight": {
              "type": "string"
            }
          },
          "title": "Weighted Vote Option",
          "type": "object"
        },
        "cosmos.gov.v1beta1.WeightedVoteOption": {
          "additionalProperties": false,
          "description": "WeightedVoteOption defines a unit of vote for vote split. Since: cosmos-sdk 0.43",
          "properties": {
            "option": {
              "description": "VoteOption enumerates the valid vote options for a given governance proposal.",
              "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                0,
                "VOTE_OPTION_YES",
                1,
                "VOTE_OPTION_ABSTAIN",
                2,
                "VOTE_OPTION_NO",
                3,
                "VOTE_OPTION_NO_WITH_VETO",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Vote Option"
            },
            "weight": {
              "type": "string"
            }
          },
          "title": "Weighted Vote Option",
          "type": "object"
        },
        "cosmos.group.v1.MemberRequest": {
          "additionalProperties": false,
          "description": "MemberRequest represents a group member to be used in Msg server requests. Contrary to `Member`, it doesn't have any `added_at` field since this field cannot be set as part of requests.",
          "properties": {
            "address": {
              "description": "address is the member's account address.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata attached to the member.",
              "type": "string"
            },
            "weight": {
              "description": "weight is the member's voting weight that should be greater than 0.",
              "type": "string"
            }
          },
          "title": "Member Request",
          "type": "object"
        },
        "cosmos.staking.v1beta1.CommissionRates": {
          "additionalProperties": false,
          "description": "CommissionRates defines the initial commission rates to be used for creating a validator.",
          "properties": {
            "max_change_rate": {
              "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction.",
              "type": "string"
            },
            "max_rate": {
              "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction.",
              "type": "string"
            },
            "rate": {
              "description": "rate is the commission rate charged to delegators, as a fraction.",
              "type": "string"
            }
          },
          "title": "Commission Rates",
          "type": "object"
        },
        "cosmos.staking.v1beta1.Description": {
          "additionalProperties": false,
          "description": "Description defines a validator description.",
          "properties": {
            "details": {
              "description": "details define other optional details.",
              "type": "string"
            },
            "identity": {
              "description": "identity defines an optional identity signature (ex. UPort or Keybase).",
              "type": "string"
            },
            "moniker": {
              "description": "moniker defines a human-readable name for the validator.",
              "type": "string"
            },
            "security_contact": {
              "description": "security_contact defines an optional email for security contact.",
              "type": "string"
            },
            "website": {
              "description": "website defines an optional website link.",
              "type": "string"
            }
          },
          "title": "Description",
          "type": "object"
        },
        "cosmos.upgrade.v1beta1.Plan": {
          "additionalProperties": false,
          "description": "Plan specifies information about a planned upgrade and when it should occur.",
          "properties": {
            "height": {
              "description": "The height at which the upgrade must be performed. Only used if Time is not set.",
              "type": "string"
            },
            "info": {
              "description": "Any application specific upgrade info to be included on-chain such as a git commit that validators could automatically upgrade to",
              "type": "string"
            },
            "name": {
              "description": "Sets the name for the upgrade. This name will be used by the upgraded version of the software to apply any special \"on-upgrade\" commands during the first BeginBlock method after the upgrade is applied. It is also used to detect whether a software version can handle a given upgrade. If no upgrade handler with this name has been set in the software, it will be assumed that the software is out-of-date when the upgrade Time or Height is reached and the software will exit.",
              "type": "string"
            },
            "time": {
              "description": "Deprecated: Time based upgrades have been deprecated. Time based upgrade logic has been removed from the SDK. If this field is not empty, an error will be thrown.",
              "format": "date-time",
              "type": "string"
            },
            "upgraded_client_state": {
              "additionalProperties": false,
              "description": "Deprecated: UpgradedClientState field has been deprecated. IBC upgrade logic has been moved to the IBC module in the sub module 02-client. If this field is not empty, an error will be thrown.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "title": "Plan",
          "type": "object"
        },
        "cosmos.vesting.v1beta1.Period": {
          "additionalProperties": false,
          "description": "Period defines a length of time and amount of coins that will vest.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "length": {
              "type": "string"
            }
          },
          "title": "Period",
          "type": "object"
        },
        "dyson.MsgRun": {
          "additionalProperties": false,
          "description": "MsgRun runs a script at a specific address",
          "properties": {
            "address": {
              "description": "Dys address of the script to call",
              "type": "string"
            },
            "args": {
              "description": "Optional args to call the function with",
              "type": "string"
            },
            "coins": {
              "description": "Optional comma seperated list of coins to send the script (for example \"123dys,456token\") this entire amount will be sent to the script",
              "type": "string"
            },
            "creator": {
              "description": "The account sending this transaction",
              "type": "string"
            },
            "extra_lines": {
              "description": "Optional extra source code to append to the end of the script before running. Only available to the script address itself.",
              "type": "string"
            },
            "function_name": {
              "description": "Optional function to call",
              "type": "string"
            },
            "kwargs": {
              "description": "Optional kwargs to run",
              "type": "string"
            },
            "nfts": {
              "description": "Optional NFTs to send the script, formatted [class_id]/[id], [class_id]/[id] (for example \"example.dys/123, example.dys/456\")",
              "type": "string"
            }
          },
          "title": "Msg Run",
          "type": "object"
        },
        "ibc.applications.interchain_accounts.v1.InterchainAccountPacketData": {
          "additionalProperties": false,
          "description": "InterchainAccountPacketData is comprised of a raw transaction, type of transaction and optional memo field.",
          "properties": {
            "data": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "memo": {
              "type": "string"
            },
            "type": {
              "description": "Type defines a classification of message issued from a controller chain to its associated interchain accounts host",
              "enum": [
                "TYPE_UNSPECIFIED",
                0,
                "TYPE_EXECUTE_TX",
                1
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Type"
            }
          },
          "title": "Interchain Account Packet Data",
          "type": "object"
        },
        "ibc.core.channel.v1.Channel": {
          "additionalProperties": false,
          "description": "Channel defines pipeline for exactly-once packet delivery between specific modules on separate blockchains, which has at least one end capable of sending packets and one end capable of receiving packets.",
          "properties": {
            "connection_hops": {
              "description": "list of connection identifiers, in order, along which packets sent on this channel will travel",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "counterparty": {
              "$ref": "#/definitions/ibc.core.channel.v1.Counterparty",
              "additionalProperties": false,
              "description": "counterparty channel end"
            },
            "ordering": {
              "description": "Order defines if a channel is ORDERED or UNORDERED",
              "enum": [
                "ORDER_NONE_UNSPECIFIED",
                0,
                "ORDER_UNORDERED",
                1,
                "ORDER_ORDERED",
                2
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Order"
            },
            "state": {
              "description": "State defines if a channel is in one of the following states: CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.",
              "enum": [
                "STATE_UNINITIALIZED_UNSPECIFIED",
                0,
                "STATE_INIT",
                1,
                "STATE_TRYOPEN",
                2,
                "STATE_OPEN",
                3,
                "STATE_CLOSED",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "State"
            },
            "version": {
              "description": "opaque channel version, which is agreed upon during the handshake",
              "type": "string"
            }
          },
          "title": "Channel",
          "type": "object"
        },
        "ibc.core.channel.v1.Counterparty": {
          "additionalProperties": false,
          "description": "Counterparty defines a channel end counterparty",
          "properties": {
            "channel_id": {
              "description": "channel end on the counterparty chain",
              "type": "string"
            },
            "port_id": {
              "description": "port on the counterparty chain which owns the other end of the channel.",
              "type": "string"
            }
          },
          "title": "Counterparty",
          "type": "object"
        },
        "ibc.core.channel.v1.Packet": {
          "additionalProperties": false,
          "description": "Packet defines a type that carries data across different chains through IBC",
          "properties": {
            "data": {
              "binaryEncoding": "base64",
              "description": "actual opaque bytes transferred directly to the application module",
              "format": "binary",
              "type": "string"
            },
            "destination_channel": {
              "description": "identifies the channel end on the receiving chain.",
              "type": "string"
            },
            "destination_port": {
              "description": "identifies the port on the receiving chain.",
              "type": "string"
            },
            "sequence": {
              "description": "number corresponds to the order of sends and receives, where a Packet with an earlier sequence number must be sent and received before a Packet with a later sequence number.",
              "type": "string"
            },
            "source_channel": {
              "description": "identifies the channel end on the sending chain.",
              "type": "string"
            },
            "source_port": {
              "description": "identifies the port on the sending chain.",
              "type": "string"
            },
            "timeout_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false,
              "description": "block height after which the packet times out"
            },
            "timeout_timestamp": {
              "description": "block timestamp (in nanoseconds) after which the packet times out",
              "type": "string"
            }
          },
          "title": "Packet",
          "type": "object"
        },
        "ibc.core.client.v1.Height": {
          "additionalProperties": false,
          "description": "Height is a monotonically increasing data type that can be compared against another Height for the purposes of updating and freezing clients Normally the RevisionHeight is incremented at each height while keeping RevisionNumber the same. However some consensus algorithms may choose to reset the height in certain conditions e.g. hard forks, state-machine breaking changes In these cases, the RevisionNumber is incremented so that height continues to be monitonically increasing even as the RevisionHeight gets reset",
          "properties": {
            "revision_height": {
              "description": "the height within the given revision",
              "type": "string"
            },
            "revision_number": {
              "description": "the revision that the client is currently on",
              "type": "string"
            }
          },
          "title": "Height",
          "type": "object"
        },
        "ibc.core.commitment.v1.MerklePrefix": {
          "additionalProperties": false,
          "description": "MerklePrefix is merkle path prefixed to the key. The constructed key from the Path and the key will be append(Path.KeyPath, append(Path.KeyPrefix, key...))",
          "properties": {
            "key_prefix": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            }
          },
          "title": "Merkle Prefix",
          "type": "object"
        },
        "ibc.core.connection.v1.Counterparty": {
          "additionalProperties": false,
          "description": "Counterparty defines the counterparty chain associated with a connection end.",
          "properties": {
            "client_id": {
              "description": "identifies the client on the counterparty chain associated with a given connection.",
              "type": "string"
            },
            "connection_id": {
              "description": "identifies the connection end on the counterparty chain associated with a given connection.",
              "type": "string"
            },
            "prefix": {
              "$ref": "#/definitions/ibc.core.commitment.v1.MerklePrefix",
              "additionalProperties": false,
              "description": "commitment merkle prefix of the counterparty chain."
            }
          },
          "title": "Counterparty",
          "type": "object"
        },
        "ibc.core.connection.v1.Version": {
          "additionalProperties": false,
          "description": "Version defines the versioning scheme used to negotiate the IBC verison in the connection handshake.",
          "properties": {
            "features": {
              "description": "list of features compatible with the specified identifier",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "identifier": {
              "description": "unique version identifier",
              "type": "string"
            }
          },
          "title": "Version",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.feegrant.v1beta1/sendMsgRevokeAllowance": {
    "http_rules": null,
    "module_name": "cosmos.feegrant.v1beta1",
    "name": "RevokeAllowance",
    "request_schema": {
      "$ref": "#/definitions/MsgRevokeAllowance",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgRevokeAllowance": {
          "additionalProperties": false,
          "description": "MsgRevokeAllowance removes any existing Allowance from Granter to Grantee.",
          "properties": {
            "grantee": {
              "description": "grantee is the address of the user being granted an allowance of another user's funds.",
              "type": "string"
            },
            "granter": {
              "description": "granter is the address of the user granting an allowance of their funds.",
              "type": "string"
            }
          },
          "title": "Msg Revoke Allowance",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.gov.v1/QueryDeposit": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "proposal_id",
          "depositor"
        ]
      }
    ],
    "module_name": "cosmos.gov.v1",
    "name": "Deposit",
    "request_schema": {
      "$ref": "#/definitions/QueryDepositRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryDepositRequest": {
          "additionalProperties": false,
          "description": "QueryDepositRequest is the request type for the Query/Deposit RPC method.",
          "properties": {
            "depositor": {
              "description": "depositor defines the deposit addresses from the proposals.",
              "type": "string"
            },
            "proposal_id": {
              "description": "proposal_id defines the unique id of the proposal.",
              "type": "string"
            }
          },
          "title": "Query Deposit Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/gov/v1/proposals/{proposal_id}/deposits/{depositor}",
    "service_name": "Query"
  },
  "cosmos.gov.v1/QueryDeposits": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "proposal_id"
        ]
      }
    ],
    "module_name": "cosmos.gov.v1",
    "name": "Deposits",
    "request_schema": {
      "$ref": "#/definitions/QueryDepositsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryDepositsRequest": {
          "additionalProperties": false,
          "description": "QueryDepositsRequest is the request type for the Query/Deposits RPC method.",
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            },
            "proposal_id": {
              "description": "proposal_id defines the unique id of the proposal.",
              "type": "string"
            }
          },
          "title": "Query Deposits Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/gov/v1/proposals/{proposal_id}/deposits",
    "service_name": "Query"
  },
  "cosmos.gov.v1/QueryParams": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "params_type"
        ]
      }
    ],
    "module_name": "cosmos.gov.v1",
    "name": "Params",
    "request_schema": {
      "$ref": "#/definitions/QueryParamsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryParamsRequest": {
          "additionalProperties": false,
          "description": "QueryParamsRequest is the request type for the Query/Params RPC method.",
          "properties": {
            "params_type": {
              "description": "params_type defines which parameters to query for, can be one of \"voting\", \"tallying\" or \"deposit\".",
              "type": "string"
            }
          },
          "title": "Query Params Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/gov/v1/params/{params_type}",
    "service_name": "Query"
  },
  "cosmos.gov.v1/QueryProposal": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "proposal_id"
        ]
      }
    ],
    "module_name": "cosmos.gov.v1",
    "name": "Proposal",
    "request_schema": {
      "$ref": "#/definitions/QueryProposalRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryProposalRequest": {
          "additionalProperties": false,
          "description": "QueryProposalRequest is the request type for the Query/Proposal RPC method.",
          "properties": {
            "proposal_id": {
              "description": "proposal_id defines the unique id of the proposal.",
              "type": "string"
            }
          },
          "title": "Query Proposal Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/gov/v1/proposals/{proposal_id}",
    "service_name": "Query"
  },
  "cosmos.gov.v1/QueryProposals": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "cosmos.gov.v1",
    "name": "Proposals",
    "request_schema": {
      "$ref": "#/definitions/QueryProposalsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryProposalsRequest": {
          "additionalProperties": false,
          "description": "QueryProposalsRequest is the request type for the Query/Proposals RPC method.",
          "properties": {
            "depositor": {
              "description": "depositor defines the deposit addresses from the proposals.",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            },
            "proposal_status": {
              "description": "ProposalStatus enumerates the valid statuses of a proposal.",
              "enum": [
                "PROPOSAL_STATUS_UNSPECIFIED",
                0,
                "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                1,
                "PROPOSAL_STATUS_VOTING_PERIOD",
                2,
                "PROPOSAL_STATUS_PASSED",
                3,
                "PROPOSAL_STATUS_REJECTED",
                4,
                "PROPOSAL_STATUS_FAILED",
                5
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Proposal Status"
            },
            "voter": {
              "description": "voter defines the voter address for the proposals.",
              "type": "string"
            }
          },
          "title": "Query Proposals Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/gov/v1/proposals",
    "service_name": "Query"
  },
  "cosmos.gov.v1/QueryTallyResult": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "proposal_id"
        ]
      }
    ],
    "module_name": "cosmos.gov.v1",
    "name": "TallyResult",
    "request_schema": {
      "$ref": "#/definitions/QueryTallyResultRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryTallyResultRequest": {
          "additionalProperties": false,
          "description": "QueryTallyResultRequest is the request type for the Query/Tally RPC method.",
          "properties": {
            "proposal_id": {
              "description": "proposal_id defines the unique id of the proposal.",
              "type": "string"
            }
          },
          "title": "Query Tally Result Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/gov/v1/proposals/{proposal_id}/tally",
    "service_name": "Query"
  },
  "cosmos.gov.v1/QueryVote": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "proposal_id",
          "voter"
        ]
      }
    ],
    "module_name": "cosmos.gov.v1",
    "name": "Vote",
    "request_schema": {
      "$ref": "#/definitions/QueryVoteRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryVoteRequest": {
          "additionalProperties": false,
          "description": "QueryVoteRequest is the request type for the Query/Vote RPC method.",
          "properties": {
            "proposal_id": {
              "description": "proposal_id defines the unique id of the proposal.",
              "type": "string"
            },
            "voter": {
              "description": "voter defines the voter address for the proposals.",
              "type": "string"
            }
          },
          "title": "Query Vote Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/gov/v1/proposals/{proposal_id}/votes/{voter}",
    "service_name": "Query"
  },
  "cosmos.gov.v1/QueryVotes": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "proposal_id"
        ]
      }
    ],
    "module_name": "cosmos.gov.v1",
    "name": "Votes",
    "request_schema": {
      "$ref": "#/definitions/QueryVotesRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryVotesRequest": {
          "additionalProperties": false,
          "description": "QueryVotesRequest is the request type for the Query/Votes RPC method.",
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            },
            "proposal_id": {
              "description": "proposal_id defines the unique id of the proposal.",
              "type": "string"
            }
          },
          "title": "Query Votes Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/gov/v1/proposals/{proposal_id}/votes",
    "service_name": "Query"
  },
  "cosmos.gov.v1/sendMsgDeposit": {
    "http_rules": null,
    "module_name": "cosmos.gov.v1",
    "name": "Deposit",
    "request_schema": {
      "$ref": "#/definitions/MsgDeposit",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgDeposit": {
          "additionalProperties": false,
          "description": "MsgDeposit defines a message to submit a deposit to an existing proposal.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "depositor": {
              "type": "string"
            },
            "proposal_id": {
              "type": "string"
            }
          },
          "title": "Msg Deposit",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/gov/v1/proposals/{proposal_id}/deposits/{depositor}",
    "service_name": "Msg"
  },
  "cosmos.gov.v1/sendMsgExecLegacyContent": {
    "http_rules": null,
    "module_name": "cosmos.gov.v1",
    "name": "ExecLegacyContent",
    "request_schema": {
      "$ref": "#/definitions/MsgExecLegacyContent",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "CancelSoftwareUpgradeProposal": {
          "additionalProperties": false,
          "description": "CancelSoftwareUpgradeProposal is a gov Content type for cancelling a software upgrade. Deprecated: This legacy proposal is deprecated in favor of Msg-based gov proposals, see MsgCancelUpgrade.",
          "properties": {
            "description": {
              "type": "string"
            },
            "title": {
              "type": "string"
            }
          },
          "title": "Cancel Software Upgrade Proposal",
          "type": "object"
        },
        "ClientUpdateProposal": {
          "additionalProperties": false,
          "description": "ClientUpdateProposal is a governance proposal. If it passes, the substitute client's latest consensus state is copied over to the subject client. The proposal handler may fail if the subject and the substitute do not match in client and chain parameters (with exception to latest height, frozen height, and chain-id).",
          "properties": {
            "description": {
              "description": "the description of the proposal",
              "type": "string"
            },
            "subject_client_id": {
              "description": "the client identifier for the client to be updated if the proposal passes",
              "type": "string"
            },
            "substitute_client_id": {
              "description": "the substitute client identifier for the client standing in for the subject client",
              "type": "string"
            },
            "title": {
              "description": "the title of the update proposal",
              "type": "string"
            }
          },
          "title": "Client Update Proposal",
          "type": "object"
        },
        "CommunityPoolSpendProposal": {
          "additionalProperties": false,
          "description": "CommunityPoolSpendProposal details a proposal for use of community funds, together with how many coins are proposed to be spent, and to which recipient account.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "description": {
              "type": "string"
            },
            "recipient": {
              "type": "string"
            },
            "title": {
              "type": "string"
            }
          },
          "title": "Community Pool Spend Proposal",
          "type": "object"
        },
        "MsgExecLegacyContent": {
          "additionalProperties": false,
          "description": "MsgExecLegacyContent is used to wrap the legacy content field into a message. This ensures backwards compatibility with v1beta1.MsgSubmitProposal.",
          "properties": {
            "authority": {
              "description": "authority must be the gov module address.",
              "type": "string"
            },
            "content": {
              "oneOf": [
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/CommunityPoolSpendProposal"
                    },
                    "type_url": {
                      "default": "/cosmos.distribution.v1beta1.CommunityPoolSpendProposal",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.distribution.v1beta1.CommunityPoolSpendProposal"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.distribution.v1beta1.CommunityPoolSpendProposal",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/TextProposal"
                    },
                    "type_url": {
                      "default": "/cosmos.gov.v1beta1.TextProposal",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.gov.v1beta1.TextProposal"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.gov.v1beta1.TextProposal",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/ParameterChangeProposal"
                    },
                    "type_url": {
                      "default": "/cosmos.params.v1beta1.ParameterChangeProposal",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.params.v1beta1.ParameterChangeProposal"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.params.v1beta1.ParameterChangeProposal",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/CancelSoftwareUpgradeProposal"
                    },
                    "type_url": {
                      "default": "/cosmos.upgrade.v1beta1.CancelSoftwareUpgradeProposal",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.upgrade.v1beta1.CancelSoftwareUpgradeProposal"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.upgrade.v1beta1.CancelSoftwareUpgradeProposal",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/SoftwareUpgradeProposal"
                    },
                    "type_url": {
                      "default": "/cosmos.upgrade.v1beta1.SoftwareUpgradeProposal",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.upgrade.v1beta1.SoftwareUpgradeProposal"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.upgrade.v1beta1.SoftwareUpgradeProposal",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/ClientUpdateProposal"
                    },
                    "type_url": {
                      "default": "/ibc.core.client.v1.ClientUpdateProposal",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.client.v1.ClientUpdateProposal"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.client.v1.ClientUpdateProposal",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/UpgradeProposal"
                    },
                    "type_url": {
                      "default": "/ibc.core.client.v1.UpgradeProposal",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.client.v1.UpgradeProposal"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.client.v1.UpgradeProposal",
                  "type": "object"
                }
              ]
            }
          },
          "title": "Msg Exec Legacy Content",
          "type": "object"
        },
        "ParameterChangeProposal": {
          "additionalProperties": false,
          "description": "ParameterChangeProposal defines a proposal to change one or more parameters.",
          "properties": {
            "changes": {
              "items": {
                "$ref": "#/definitions/cosmos.params.v1beta1.ParamChange"
              },
              "type": "array"
            },
            "description": {
              "type": "string"
            },
            "title": {
              "type": "string"
            }
          },
          "title": "Parameter Change Proposal",
          "type": "object"
        },
        "SoftwareUpgradeProposal": {
          "additionalProperties": false,
          "description": "SoftwareUpgradeProposal is a gov Content type for initiating a software upgrade. Deprecated: This legacy proposal is deprecated in favor of Msg-based gov proposals, see MsgSoftwareUpgrade.",
          "properties": {
            "description": {
              "type": "string"
            },
            "plan": {
              "$ref": "#/definitions/cosmos.upgrade.v1beta1.Plan",
              "additionalProperties": false
            },
            "title": {
              "type": "string"
            }
          },
          "title": "Software Upgrade Proposal",
          "type": "object"
        },
        "TextProposal": {
          "additionalProperties": false,
          "description": "TextProposal defines a standard text proposal whose changes need to be manually updated in case of approval.",
          "properties": {
            "description": {
              "type": "string"
            },
            "title": {
              "type": "string"
            }
          },
          "title": "Text Proposal",
          "type": "object"
        },
        "UpgradeProposal": {
          "additionalProperties": false,
          "description": "UpgradeProposal is a gov Content type for initiating an IBC breaking upgrade.",
          "properties": {
            "description": {
              "type": "string"
            },
            "plan": {
              "$ref": "#/definitions/cosmos.upgrade.v1beta1.Plan",
              "additionalProperties": false
            },
            "title": {
              "type": "string"
            },
            "upgraded_client_state": {
              "additionalProperties": false,
              "description": "An UpgradedClientState must be provided to perform an IBC breaking upgrade. This will make the chain commit to the correct upgraded (self) client state before the upgrade occurs, so that connecting chains can verify that the new upgraded client is valid by verifying a proof on the previous version of the chain. This will allow IBC connections to persist smoothly across planned chain upgrades",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "title": "Upgrade Proposal",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        },
        "cosmos.params.v1beta1.ParamChange": {
          "additionalProperties": false,
          "description": "ParamChange defines an individual parameter change, for use in ParameterChangeProposal.",
          "properties": {
            "key": {
              "type": "string"
            },
            "subspace": {
              "type": "string"
            },
            "value": {
              "type": "string"
            }
          },
          "title": "Param Change",
          "type": "object"
        },
        "cosmos.upgrade.v1beta1.Plan": {
          "additionalProperties": false,
          "description": "Plan specifies information about a planned upgrade and when it should occur.",
          "properties": {
            "height": {
              "description": "The height at which the upgrade must be performed. Only used if Time is not set.",
              "type": "string"
            },
            "info": {
              "description": "Any application specific upgrade info to be included on-chain such as a git commit that validators could automatically upgrade to",
              "type": "string"
            },
            "name": {
              "description": "Sets the name for the upgrade. This name will be used by the upgraded version of the software to apply any special \"on-upgrade\" commands during the first BeginBlock method after the upgrade is applied. It is also used to detect whether a software version can handle a given upgrade. If no upgrade handler with this name has been set in the software, it will be assumed that the software is out-of-date when the upgrade Time or Height is reached and the software will exit.",
              "type": "string"
            },
            "time": {
              "description": "Deprecated: Time based upgrades have been deprecated. Time based upgrade logic has been removed from the SDK. If this field is not empty, an error will be thrown.",
              "format": "date-time",
              "type": "string"
            },
            "upgraded_client_state": {
              "additionalProperties": false,
              "description": "Deprecated: UpgradedClientState field has been deprecated. IBC upgrade logic has been moved to the IBC module in the sub module 02-client. If this field is not empty, an error will be thrown.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "title": "Plan",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.gov.v1/sendMsgSubmitProposal": {
    "http_rules": null,
    "module_name": "cosmos.gov.v1",
    "name": "SubmitProposal",
    "request_schema": {
      "$ref": "#/definitions/MsgSubmitProposal",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgAccept": {
          "additionalProperties": false,
          "description": "Accept the name that was offered to you",
          "properties": {
            "name": {
              "description": "The name to accept",
              "type": "string"
            },
            "new_owner": {
              "description": "The owner address of the name",
              "type": "string"
            }
          },
          "title": "Msg Accept",
          "type": "object"
        },
        "MsgAcknowledgement": {
          "additionalProperties": false,
          "description": "MsgAcknowledgement receives incoming IBC acknowledgement",
          "properties": {
            "acknowledgement": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "packet": {
              "$ref": "#/definitions/ibc.core.channel.v1.Packet",
              "additionalProperties": false
            },
            "proof_acked": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Acknowledgement",
          "type": "object"
        },
        "MsgBeginRedelegate": {
          "additionalProperties": false,
          "description": "MsgBeginRedelegate defines a SDK message for performing a redelegation of coins from a delegator and source validator to a destination validator.",
          "properties": {
            "amount": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false
            },
            "delegator_address": {
              "type": "string"
            },
            "validator_dst_address": {
              "type": "string"
            },
            "validator_src_address": {
              "type": "string"
            }
          },
          "title": "Msg Begin Redelegate",
          "type": "object"
        },
        "MsgBurnCoins": {
          "additionalProperties": false,
          "properties": {
            "amount": {
              "description": "The amount of coins to burn, the owner must have enough coins to burn",
              "type": "string"
            },
            "owner": {
              "description": "The owner of the Dys name",
              "type": "string"
            }
          },
          "title": "Msg Burn Coins",
          "type": "object"
        },
        "MsgBurnNft": {
          "additionalProperties": false,
          "description": "Burn an NFT of the given class ID and NFT ID.",
          "properties": {
            "class_id": {
              "description": "the NFT Class ID",
              "type": "string"
            },
            "class_owner": {
              "description": "The owner of the NFT Class",
              "type": "string"
            },
            "id": {
              "description": "The ID of this NFT to burn. The owner must currently own this NFT to burn it.",
              "type": "string"
            }
          },
          "title": "Msg Burn Nft",
          "type": "object"
        },
        "MsgBuy": {
          "additionalProperties": false,
          "description": "All names have a listed price, this message allows you to buy the name at the listed price.",
          "properties": {
            "buyer": {
              "description": "The address of the buyer",
              "type": "string"
            },
            "name": {
              "description": "The name to buy",
              "type": "string"
            },
            "price": {
              "description": "Confirm the  price of the name is the same as the listed price.",
              "type": "string"
            }
          },
          "title": "Msg Buy",
          "type": "object"
        },
        "MsgCancelUnbondingDelegation": {
          "additionalProperties": false,
          "description": "MsgCancelUnbondingDelegation defines the SDK message for performing a cancel unbonding delegation for delegator Since: cosmos-sdk 0.46",
          "properties": {
            "amount": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false,
              "description": "amount is always less than or equal to unbonding delegation entry balance"
            },
            "creation_height": {
              "description": "creation_height is the height which the unbonding took place.",
              "type": "string"
            },
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Cancel Unbonding Delegation",
          "type": "object"
        },
        "MsgCancelUpgrade": {
          "additionalProperties": false,
          "description": "MsgCancelUpgrade is the Msg/CancelUpgrade request type. Since: cosmos-sdk 0.46",
          "properties": {
            "authority": {
              "description": "authority is the address of the governance account.",
              "type": "string"
            }
          },
          "title": "Msg Cancel Upgrade",
          "type": "object"
        },
        "MsgChannelCloseConfirm": {
          "additionalProperties": false,
          "description": "MsgChannelCloseConfirm defines a msg sent by a Relayer to Chain B to acknowledge the change of channel state to CLOSED on Chain A.",
          "properties": {
            "channel_id": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_init": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Close Confirm",
          "type": "object"
        },
        "MsgChannelCloseInit": {
          "additionalProperties": false,
          "description": "MsgChannelCloseInit defines a msg sent by a Relayer to Chain A to close a channel with Chain B.",
          "properties": {
            "channel_id": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Close Init",
          "type": "object"
        },
        "MsgChannelOpenAck": {
          "additionalProperties": false,
          "description": "MsgChannelOpenAck defines a msg sent by a Relayer to Chain A to acknowledge the change of channel state to TRYOPEN on Chain B.",
          "properties": {
            "channel_id": {
              "type": "string"
            },
            "counterparty_channel_id": {
              "type": "string"
            },
            "counterparty_version": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_try": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Open Ack",
          "type": "object"
        },
        "MsgChannelOpenConfirm": {
          "additionalProperties": false,
          "description": "MsgChannelOpenConfirm defines a msg sent by a Relayer to Chain B to acknowledge the change of channel state to OPEN on Chain A.",
          "properties": {
            "channel_id": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            },
            "proof_ack": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Open Confirm",
          "type": "object"
        },
        "MsgChannelOpenInit": {
          "additionalProperties": false,
          "description": "MsgChannelOpenInit defines an sdk.Msg to initialize a channel handshake. It is called by a relayer on Chain A.",
          "properties": {
            "channel": {
              "$ref": "#/definitions/ibc.core.channel.v1.Channel",
              "additionalProperties": false
            },
            "port_id": {
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Open Init",
          "type": "object"
        },
        "MsgChannelOpenTry": {
          "additionalProperties": false,
          "description": "MsgChannelOpenInit defines a msg sent by a Relayer to try to open a channel on Chain B. The version field within the Channel field has been deprecated. Its value will be ignored by core IBC.",
          "properties": {
            "channel": {
              "$ref": "#/definitions/ibc.core.channel.v1.Channel",
              "additionalProperties": false,
              "description": "NOTE: the version field within the channel has been deprecated. Its value will be ignored by core IBC."
            },
            "counterparty_version": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            },
            "previous_channel_id": {
              "description": "Deprecated: this field is unused. Crossing hello's are no longer supported in core IBC.",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_init": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Open Try",
          "type": "object"
        },
        "MsgConnectionOpenAck": {
          "additionalProperties": false,
          "description": "MsgConnectionOpenAck defines a msg sent by a Relayer to Chain A to acknowledge the change of connection state to TRYOPEN on Chain B.",
          "properties": {
            "client_state": {
              "additionalProperties": false,
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "connection_id": {
              "type": "string"
            },
            "consensus_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "counterparty_connection_id": {
              "type": "string"
            },
            "proof_client": {
              "binaryEncoding": "base64",
              "description": "proof of client state included in message",
              "format": "binary",
              "type": "string"
            },
            "proof_consensus": {
              "binaryEncoding": "base64",
              "description": "proof of client consensus state",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_try": {
              "binaryEncoding": "base64",
              "description": "proof of the initialization the connection on Chain B: `UNITIALIZED -> TRYOPEN`",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            },
            "version": {
              "$ref": "#/definitions/ibc.core.connection.v1.Version",
              "additionalProperties": false
            }
          },
          "title": "Msg Connection Open Ack",
          "type": "object"
        },
        "MsgConnectionOpenConfirm": {
          "additionalProperties": false,
          "description": "MsgConnectionOpenConfirm defines a msg sent by a Relayer to Chain B to acknowledge the change of connection state to OPEN on Chain A.",
          "properties": {
            "connection_id": {
              "type": "string"
            },
            "proof_ack": {
              "binaryEncoding": "base64",
              "description": "proof for the change of the connection state on Chain A: `INIT -> OPEN`",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Connection Open Confirm",
          "type": "object"
        },
        "MsgConnectionOpenInit": {
          "additionalProperties": false,
          "description": "MsgConnectionOpenInit defines the msg sent by an account on Chain A to initialize a connection with Chain B.",
          "properties": {
            "client_id": {
              "type": "string"
            },
            "counterparty": {
              "$ref": "#/definitions/ibc.core.connection.v1.Counterparty",
              "additionalProperties": false
            },
            "delay_period": {
              "type": "string"
            },
            "signer": {
              "type": "string"
            },
            "version": {
              "$ref": "#/definitions/ibc.core.connection.v1.Version",
              "additionalProperties": false
            }
          },
          "title": "Msg Connection Open Init",
          "type": "object"
        },
        "MsgConnectionOpenTry": {
          "additionalProperties": false,
          "description": "MsgConnectionOpenTry defines a msg sent by a Relayer to try to open a connection on Chain B.",
          "properties": {
            "client_id": {
              "type": "string"
            },
            "client_state": {
              "additionalProperties": false,
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "consensus_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "counterparty": {
              "$ref": "#/definitions/ibc.core.connection.v1.Counterparty",
              "additionalProperties": false
            },
            "counterparty_versions": {
              "items": {
                "$ref": "#/definitions/ibc.core.connection.v1.Version"
              },
              "type": "array"
            },
            "delay_period": {
              "type": "string"
            },
            "previous_connection_id": {
              "description": "Deprecated: this field is unused. Crossing hellos are no longer supported in core IBC.",
              "type": "string"
            },
            "proof_client": {
              "binaryEncoding": "base64",
              "description": "proof of client state included in message",
              "format": "binary",
              "type": "string"
            },
            "proof_consensus": {
              "binaryEncoding": "base64",
              "description": "proof of client consensus state",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_init": {
              "binaryEncoding": "base64",
              "description": "proof of the initialization the connection on Chain A: `UNITIALIZED -> INIT`",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Connection Open Try",
          "type": "object"
        },
        "MsgCreateClient": {
          "additionalProperties": false,
          "description": "MsgCreateClient defines a message to create an IBC client",
          "properties": {
            "client_state": {
              "additionalProperties": false,
              "description": "light client state",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "consensus_state": {
              "additionalProperties": false,
              "description": "consensus state associated with the client that corresponds to a given height.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "signer": {
              "description": "signer address",
              "type": "string"
            }
          },
          "title": "Msg Create Client",
          "type": "object"
        },
        "MsgCreateGroup": {
          "additionalProperties": false,
          "description": "Groups  MsgCreateGroup is the Msg/CreateGroup request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "members": {
              "description": "members defines the group members.",
              "items": {
                "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
              },
              "type": "array"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata to attached to the group.",
              "type": "string"
            }
          },
          "title": "Groups",
          "type": "object"
        },
        "MsgCreateGroupPolicy": {
          "additionalProperties": false,
          "description": "Group Policies  MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "decision_policy": {
              "additionalProperties": false,
              "description": "decision_policy specifies the group policy's decision policy.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata attached to the group policy.",
              "type": "string"
            }
          },
          "title": "Group Policies",
          "type": "object"
        },
        "MsgCreateGroupWithPolicy": {
          "additionalProperties": false,
          "description": "MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group and group policy admin.",
              "type": "string"
            },
            "decision_policy": {
              "additionalProperties": false,
              "description": "decision_policy specifies the group policy's decision policy.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "group_metadata": {
              "description": "group_metadata is any arbitrary metadata attached to the group.",
              "type": "string"
            },
            "group_policy_as_admin": {
              "description": "group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group and group policy admin.",
              "type": "boolean"
            },
            "group_policy_metadata": {
              "description": "group_policy_metadata is any arbitrary metadata attached to the group policy.",
              "type": "string"
            },
            "members": {
              "description": "members defines the group members.",
              "items": {
                "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
              },
              "type": "array"
            }
          },
          "title": "Msg Create Group With Policy",
          "type": "object"
        },
        "MsgCreatePeriodicVestingAccount": {
          "additionalProperties": false,
          "description": "MsgCreateVestingAccount defines a message that enables creating a vesting account. Since: cosmos-sdk 0.46",
          "properties": {
            "from_address": {
              "type": "string"
            },
            "start_time": {
              "type": "string"
            },
            "to_address": {
              "type": "string"
            },
            "vesting_periods": {
              "items": {
                "$ref": "#/definitions/cosmos.vesting.v1beta1.Period"
              },
              "type": "array"
            }
          },
          "title": "Msg Create Periodic Vesting Account",
          "type": "object"
        },
        "MsgCreatePermanentLockedAccount": {
          "additionalProperties": false,
          "description": "MsgCreatePermanentLockedAccount defines a message that enables creating a permanent locked account. Since: cosmos-sdk 0.46",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "from_address": {
              "type": "string"
            },
            "to_address": {
              "type": "string"
            }
          },
          "title": "Msg Create Permanent Locked Account",
          "type": "object"
        },
        "MsgCreateScheduledRun": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            },
            "gas": {
              "type": "string"
            },
            "height": {
              "type": "string"
            },
            "msg": {
              "$ref": "#/definitions/dyson.MsgRun",
              "additionalProperties": false
            }
          },
          "title": "Msg Create Scheduled Run",
          "type": "object"
        },
        "MsgCreateStorage": {
          "additionalProperties": false,
          "description": "Create a new storage of arbitrary text",
          "properties": {
            "creator": {
              "description": "The address signing this transaction",
              "type": "string"
            },
            "data": {
              "description": "data to store at this index",
              "type": "string"
            },
            "force": {
              "description": "If true, force will always store the data at this address regardless of already existing storage",
              "type": "boolean"
            },
            "index": {
              "description": "Name of the Storage, must be prefixed with the creators address (for example: \"dys..1a3/some_name\")",
              "type": "string"
            }
          },
          "title": "Msg Create Storage",
          "type": "object"
        },
        "MsgCreateValidator": {
          "additionalProperties": false,
          "description": "MsgCreateValidator defines a SDK message for creating a new validator.",
          "properties": {
            "commission": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.CommissionRates",
              "additionalProperties": false
            },
            "delegator_address": {
              "type": "string"
            },
            "description": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.Description",
              "additionalProperties": false
            },
            "min_self_delegation": {
              "type": "string"
            },
            "pubkey": {
              "additionalProperties": false,
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "validator_address": {
              "type": "string"
            },
            "value": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false
            }
          },
          "title": "Msg Create Validator",
          "type": "object"
        },
        "MsgCreateVestingAccount": {
          "additionalProperties": false,
          "description": "MsgCreateVestingAccount defines a message that enables creating a vesting account.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "delayed": {
              "type": "boolean"
            },
            "end_time": {
              "type": "string"
            },
            "from_address": {
              "type": "string"
            },
            "to_address": {
              "type": "string"
            }
          },
          "title": "Msg Create Vesting Account",
          "type": "object"
        },
        "MsgDelegate": {
          "additionalProperties": false,
          "description": "MsgDelegate defines a SDK message for performing a delegation of coins from a delegator to a validator.",
          "properties": {
            "amount": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false
            },
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Delegate",
          "type": "object"
        },
        "MsgDeleteName": {
          "additionalProperties": false,
          "description": "Delete the Dyson Protocol name",
          "properties": {
            "name": {
              "description": "The name to delete",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            }
          },
          "title": "Msg Delete Name",
          "type": "object"
        },
        "MsgDeleteScheduledRun": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            },
            "index": {
              "type": "string"
            }
          },
          "title": "Msg Delete Scheduled Run",
          "type": "object"
        },
        "MsgDeleteScript": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            }
          },
          "title": "Msg Delete Script",
          "type": "object"
        },
        "MsgDeleteStorage": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            },
            "index": {
              "type": "string"
            }
          },
          "title": "Msg Delete Storage",
          "type": "object"
        },
        "MsgDeployAutonomousScript": {
          "additionalProperties": false,
          "description": "Deploy an Autonomous Script at a new address",
          "properties": {
            "code": {
              "format": "python",
              "type": "string"
            },
            "creator": {
              "type": "string"
            }
          },
          "title": "Msg Deploy Autonomous Script",
          "type": "object"
        },
        "MsgDeposit": {
          "additionalProperties": false,
          "description": "MsgDeposit defines a message to submit a deposit to an existing proposal.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "depositor": {
              "type": "string"
            },
            "proposal_id": {
              "type": "string"
            }
          },
          "title": "Msg Deposit",
          "type": "object"
        },
        "MsgEditValidator": {
          "additionalProperties": false,
          "description": "MsgEditValidator defines a SDK message for editing an existing validator.",
          "properties": {
            "commission_rate": {
              "description": "We pass a reference to the new commission rate and min self delegation as it's not mandatory to update. If not updated, the deserialized rate will be zero with no way to distinguish if an update was intended. REF: #2373",
              "type": "string"
            },
            "description": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.Description",
              "additionalProperties": false
            },
            "min_self_delegation": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Edit Validator",
          "type": "object"
        },
        "MsgExec": {
          "additionalProperties": false,
          "description": "MsgExec is the Msg/Exec request type.",
          "properties": {
            "executor": {
              "description": "executor is the account address used to execute the proposal.",
              "type": "string"
            },
            "proposal_id": {
              "description": "proposal is the unique ID of the proposal.",
              "type": "string"
            }
          },
          "title": "Msg Exec",
          "type": "object"
        },
        "MsgExecLegacyContent": {
          "additionalProperties": false,
          "description": "MsgExecLegacyContent is used to wrap the legacy content field into a message. This ensures backwards compatibility with v1beta1.MsgSubmitProposal.",
          "properties": {
            "authority": {
              "description": "authority must be the gov module address.",
              "type": "string"
            },
            "content": {
              "additionalProperties": false,
              "description": "content is the proposal's content.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "title": "Msg Exec Legacy Content",
          "type": "object"
        },
        "MsgFundCommunityPool": {
          "additionalProperties": false,
          "description": "MsgFundCommunityPool allows an account to directly fund the community pool.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "depositor": {
              "type": "string"
            }
          },
          "title": "Msg Fund Community Pool",
          "type": "object"
        },
        "MsgGrant": {
          "additionalProperties": false,
          "description": "MsgGrant is a request type for Grant method. It declares authorization to the grantee on behalf of the granter with the provided expiration time.",
          "properties": {
            "grant": {
              "$ref": "#/definitions/cosmos.authz.v1beta1.Grant",
              "additionalProperties": false
            },
            "grantee": {
              "type": "string"
            },
            "granter": {
              "type": "string"
            }
          },
          "title": "Msg Grant",
          "type": "object"
        },
        "MsgGrantAllowance": {
          "additionalProperties": false,
          "description": "MsgGrantAllowance adds permission for Grantee to spend up to Allowance of fees from the account of Granter.",
          "properties": {
            "allowance": {
              "additionalProperties": false,
              "description": "allowance can be any of basic, periodic, allowed fee allowance.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "grantee": {
              "description": "grantee is the address of the user being granted an allowance of another user's funds.",
              "type": "string"
            },
            "granter": {
              "description": "granter is the address of the user granting an allowance of their funds.",
              "type": "string"
            }
          },
          "title": "Msg Grant Allowance",
          "type": "object"
        },
        "MsgLeaveGroup": {
          "additionalProperties": false,
          "description": "MsgLeaveGroup is the Msg/LeaveGroup request type.",
          "properties": {
            "address": {
              "description": "address is the account address of the group member.",
              "type": "string"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            }
          },
          "title": "Msg Leave Group",
          "type": "object"
        },
        "MsgMintCoins": {
          "additionalProperties": false,
          "description": "Mint coins with a denom of a name or subname. For example if you own the name \"example.dys\" you can mint coins with the denom \"example.dys\" or \"subname.example.dys\"",
          "properties": {
            "amount": {
              "description": "The amount of coins to mint in the format \"[amount] [denom]\".   Each coin costs 1 gas.",
              "type": "string"
            },
            "owner": {
              "description": "The owner of the Dys name",
              "type": "string"
            }
          },
          "title": "Msg Mint Coins",
          "type": "object"
        },
        "MsgMintNft": {
          "additionalProperties": false,
          "description": "Mint an NFT with the given class ID and NFT ID. The NFT ID is unique to the class ID.",
          "properties": {
            "class_id": {
              "description": "the NFT Class ID",
              "type": "string"
            },
            "class_owner": {
              "description": "The owner of the Dys name",
              "type": "string"
            },
            "id": {
              "description": "The ID of this NFT, must be unique to the class ID",
              "type": "string"
            },
            "uri": {
              "description": "The URI of the NFT (optional)",
              "type": "string"
            },
            "uri_hash": {
              "description": "The URI hash of the NFT (optional)",
              "type": "string"
            }
          },
          "title": "Msg Mint Nft",
          "type": "object"
        },
        "MsgMultiSend": {
          "additionalProperties": false,
          "description": "MsgMultiSend represents an arbitrary multi-in, multi-out send message.",
          "properties": {
            "inputs": {
              "items": {
                "$ref": "#/definitions/cosmos.bank.v1beta1.Input"
              },
              "type": "array"
            },
            "outputs": {
              "items": {
                "$ref": "#/definitions/cosmos.bank.v1beta1.Output"
              },
              "type": "array"
            }
          },
          "title": "Msg Multi Send",
          "type": "object"
        },
        "MsgOfferTo": {
          "additionalProperties": false,
          "description": "Offer the name to a new owner",
          "properties": {
            "name": {
              "description": "The name to offer",
              "type": "string"
            },
            "new_owner": {
              "description": "The address to offer the name to. They can take ownership of the name with the Accept message",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            }
          },
          "title": "Msg Offer To",
          "type": "object"
        },
        "MsgRecvPacket": {
          "additionalProperties": false,
          "description": "MsgRecvPacket receives incoming IBC packet",
          "properties": {
            "packet": {
              "$ref": "#/definitions/ibc.core.channel.v1.Packet",
              "additionalProperties": false
            },
            "proof_commitment": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Recv Packet",
          "type": "object"
        },
        "MsgRegister": {
          "additionalProperties": false,
          "properties": {
            "auto_renew": {
              "description": "Should the name be automatically renewed",
              "type": "boolean"
            },
            "commit": {
              "description": "The Shake256(owner+name+salt) hexdigest",
              "type": "string"
            },
            "owner": {
              "description": "Address of the owner",
              "type": "string"
            },
            "price": {
              "description": "The price that this name is valued at and can be purchased for example 100dys. The yearly fee (31,536,000 blocks) is 1% of this price.",
              "type": "string"
            }
          },
          "title": "Msg Register",
          "type": "object"
        },
        "MsgRegisterInterchainAccount": {
          "additionalProperties": false,
          "description": "MsgRegisterInterchainAccount defines the payload for Msg/MsgRegisterInterchainAccount",
          "properties": {
            "connection_id": {
              "type": "string"
            },
            "owner": {
              "type": "string"
            },
            "version": {
              "type": "string"
            }
          },
          "title": "Msg Register Interchain Account",
          "type": "object"
        },
        "MsgReveal": {
          "additionalProperties": false,
          "description": "Reveal the name that was committed to with the Register message",
          "properties": {
            "name": {
              "description": "The name to reveal",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            },
            "salt": {
              "description": "The salt that was used to commit to the name",
              "type": "string"
            }
          },
          "title": "Msg Reveal",
          "type": "object"
        },
        "MsgRevoke": {
          "additionalProperties": false,
          "description": "MsgRevoke revokes any authorization with the provided sdk.Msg type on the granter's account with that has been granted to the grantee.",
          "properties": {
            "grantee": {
              "type": "string"
            },
            "granter": {
              "type": "string"
            },
            "msg_type_url": {
              "type": "string"
            }
          },
          "title": "Msg Revoke",
          "type": "object"
        },
        "MsgRevokeAllowance": {
          "additionalProperties": false,
          "description": "MsgRevokeAllowance removes any existing Allowance from Granter to Grantee.",
          "properties": {
            "grantee": {
              "description": "grantee is the address of the user being granted an allowance of another user's funds.",
              "type": "string"
            },
            "granter": {
              "description": "granter is the address of the user granting an allowance of their funds.",
              "type": "string"
            }
          },
          "title": "Msg Revoke Allowance",
          "type": "object"
        },
        "MsgRun": {
          "additionalProperties": false,
          "description": "MsgRun runs a script at a specific address",
          "properties": {
            "address": {
              "description": "Dys address of the script to call",
              "type": "string"
            },
            "args": {
              "description": "Optional args to call the function with",
              "type": "string"
            },
            "coins": {
              "description": "Optional comma seperated list of coins to send the script (for example \"123dys,456token\") this entire amount will be sent to the script",
              "type": "string"
            },
            "creator": {
              "description": "The account sending this transaction",
              "type": "string"
            },
            "extra_lines": {
              "description": "Optional extra source code to append to the end of the script before running. Only available to the script address itself.",
              "type": "string"
            },
            "function_name": {
              "description": "Optional function to call",
              "type": "string"
            },
            "kwargs": {
              "description": "Optional kwargs to run",
              "type": "string"
            },
            "nfts": {
              "description": "Optional NFTs to send the script, formatted [class_id]/[id], [class_id]/[id] (for example \"example.dys/123, example.dys/456\")",
              "type": "string"
            }
          },
          "title": "Msg Run",
          "type": "object"
        },
        "MsgSend": {
          "additionalProperties": false,
          "description": "MsgSend represents a message to send a nft from one account to another account.",
          "properties": {
            "class_id": {
              "description": "class_id defines the unique identifier of the nft classification, similar to the contract address of ERC721",
              "type": "string"
            },
            "id": {
              "description": "id defines the unique identification of nft",
              "type": "string"
            },
            "receiver": {
              "description": "receiver is the receiver address of nft",
              "type": "string"
            },
            "sender": {
              "description": "sender is the address of the owner of nft",
              "type": "string"
            }
          },
          "title": "Msg Send",
          "type": "object"
        },
        "MsgSendTx": {
          "additionalProperties": false,
          "description": "MsgSendTx defines the payload for Msg/SendTx",
          "properties": {
            "connection_id": {
              "type": "string"
            },
            "owner": {
              "type": "string"
            },
            "packet_data": {
              "$ref": "#/definitions/ibc.applications.interchain_accounts.v1.InterchainAccountPacketData",
              "additionalProperties": false
            },
            "relative_timeout": {
              "description": "Relative timeout timestamp provided will be added to the current block time during transaction execution. The timeout timestamp must be non-zero.",
              "type": "string"
            }
          },
          "title": "Msg Send Tx",
          "type": "object"
        },
        "MsgSetNftClass": {
          "additionalProperties": false,
          "description": "Create or update an NFT class. The NFT class is identified by the Dys name of the class ID.",
          "properties": {
            "description": {
              "description": "The  description of the NFT class (optional)",
              "type": "string"
            },
            "id": {
              "description": "the ID is the Dys name or subname of the NFT class. For example if you own the name \"example.dys\" you can create an NFT class with the ID \"example.dys\" or \"subname.example.dys\"",
              "type": "string"
            },
            "name": {
              "description": "More descriptive name of the NFT class (optional)",
              "type": "string"
            },
            "owner": {
              "description": "The owner of the Dys name of the NFT class ID",
              "type": "string"
            },
            "symbol": {
              "description": "The symbol of the NFT class (optional)",
              "type": "string"
            },
            "uri": {
              "description": "The URI of the NFT class (optional)",
              "type": "string"
            },
            "uri_hash": {
              "description": "The URI hash of the NFT class (optional)",
              "type": "string"
            }
          },
          "title": "Msg Set Nft Class",
          "type": "object"
        },
        "MsgSetPriceAndExtend": {
          "additionalProperties": false,
          "description": "Set the price of the name and extend the expiration height",
          "properties": {
            "name": {
              "description": "The name to set the price for",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            },
            "price": {
              "description": "The new price that this name is valued at and can be purchased for example 100dys. The fee is 1% of this price and will be paid by the owner now. The expiration height is extended by 31,536,000 blocks.",
              "type": "string"
            }
          },
          "title": "Msg Set Price And Extend",
          "type": "object"
        },
        "MsgSetWithdrawAddress": {
          "additionalProperties": false,
          "description": "MsgSetWithdrawAddress sets the withdraw address for a delegator (or validator self-delegation).",
          "properties": {
            "delegator_address": {
              "type": "string"
            },
            "withdraw_address": {
              "type": "string"
            }
          },
          "title": "Msg Set Withdraw Address",
          "type": "object"
        },
        "MsgSoftwareUpgrade": {
          "additionalProperties": false,
          "description": "MsgSoftwareUpgrade is the Msg/SoftwareUpgrade request type. Since: cosmos-sdk 0.46",
          "properties": {
            "authority": {
              "description": "authority is the address of the governance account.",
              "type": "string"
            },
            "plan": {
              "$ref": "#/definitions/cosmos.upgrade.v1beta1.Plan",
              "additionalProperties": false,
              "description": "plan is the upgrade plan."
            }
          },
          "title": "Msg Software Upgrade",
          "type": "object"
        },
        "MsgSubmitEvidence": {
          "additionalProperties": false,
          "description": "MsgSubmitEvidence represents a message that supports submitting arbitrary Evidence of misbehavior such as equivocation or counterfactual signing.",
          "properties": {
            "evidence": {
              "additionalProperties": false,
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "submitter": {
              "type": "string"
            }
          },
          "title": "Msg Submit Evidence",
          "type": "object"
        },
        "MsgSubmitMisbehaviour": {
          "additionalProperties": false,
          "description": "MsgSubmitMisbehaviour defines an sdk.Msg type that submits Evidence for light client misbehaviour.",
          "properties": {
            "client_id": {
              "description": "client unique identifier",
              "type": "string"
            },
            "misbehaviour": {
              "additionalProperties": false,
              "description": "misbehaviour used for freezing the light client",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "signer": {
              "description": "signer address",
              "type": "string"
            }
          },
          "title": "Msg Submit Misbehaviour",
          "type": "object"
        },
        "MsgSubmitProposal": {
          "additionalProperties": false,
          "description": "MsgSubmitProposal defines an sdk.Msg type that supports submitting arbitrary proposal Content.",
          "properties": {
            "initial_deposit": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "messages": {
              "items": {
                "oneOf": [
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgExec"
                      },
                      "type_url": {
                        "default": "/cosmos.authz.v1beta1.MsgExec",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.authz.v1beta1.MsgExec"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.authz.v1beta1.MsgExec",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgGrant"
                      },
                      "type_url": {
                        "default": "/cosmos.authz.v1beta1.MsgGrant",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.authz.v1beta1.MsgGrant"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.authz.v1beta1.MsgGrant",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgRevoke"
                      },
                      "type_url": {
                        "default": "/cosmos.authz.v1beta1.MsgRevoke",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.authz.v1beta1.MsgRevoke"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.authz.v1beta1.MsgRevoke",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgMultiSend"
                      },
                      "type_url": {
                        "default": "/cosmos.bank.v1beta1.MsgMultiSend",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.bank.v1beta1.MsgMultiSend"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.bank.v1beta1.MsgMultiSend",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSend"
                      },
                      "type_url": {
                        "default": "/cosmos.bank.v1beta1.MsgSend",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.bank.v1beta1.MsgSend"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.bank.v1beta1.MsgSend",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgVerifyInvariant"
                      },
                      "type_url": {
                        "default": "/cosmos.crisis.v1beta1.MsgVerifyInvariant",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.crisis.v1beta1.MsgVerifyInvariant"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.crisis.v1beta1.MsgVerifyInvariant",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgFundCommunityPool"
                      },
                      "type_url": {
                        "default": "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.distribution.v1beta1.MsgFundCommunityPool"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.distribution.v1beta1.MsgFundCommunityPool",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSetWithdrawAddress"
                      },
                      "type_url": {
                        "default": "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgWithdrawDelegatorReward"
                      },
                      "type_url": {
                        "default": "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgWithdrawValidatorCommission"
                      },
                      "type_url": {
                        "default": "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSubmitEvidence"
                      },
                      "type_url": {
                        "default": "/cosmos.evidence.v1beta1.MsgSubmitEvidence",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.evidence.v1beta1.MsgSubmitEvidence"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.evidence.v1beta1.MsgSubmitEvidence",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgGrantAllowance"
                      },
                      "type_url": {
                        "default": "/cosmos.feegrant.v1beta1.MsgGrantAllowance",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.feegrant.v1beta1.MsgGrantAllowance"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.feegrant.v1beta1.MsgGrantAllowance",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgRevokeAllowance"
                      },
                      "type_url": {
                        "default": "/cosmos.feegrant.v1beta1.MsgRevokeAllowance",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.feegrant.v1beta1.MsgRevokeAllowance"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.feegrant.v1beta1.MsgRevokeAllowance",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeposit"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1.MsgDeposit",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1.MsgDeposit"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1.MsgDeposit",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgExecLegacyContent"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1.MsgExecLegacyContent",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1.MsgExecLegacyContent"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1.MsgExecLegacyContent",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSubmitProposal"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1.MsgSubmitProposal",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1.MsgSubmitProposal"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1.MsgSubmitProposal",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgVote"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1.MsgVote",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1.MsgVote"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1.MsgVote",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgVoteWeighted"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1.MsgVoteWeighted",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1.MsgVoteWeighted"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1.MsgVoteWeighted",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeposit"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1beta1.MsgDeposit",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1beta1.MsgDeposit"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1beta1.MsgDeposit",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSubmitProposal"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1beta1.MsgSubmitProposal",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1beta1.MsgSubmitProposal"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1beta1.MsgSubmitProposal",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgVote"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1beta1.MsgVote",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1beta1.MsgVote"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1beta1.MsgVote",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgVoteWeighted"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1beta1.MsgVoteWeighted",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1beta1.MsgVoteWeighted"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1beta1.MsgVoteWeighted",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateGroup"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgCreateGroup",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgCreateGroup"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgCreateGroup",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateGroupPolicy"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgCreateGroupPolicy",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgCreateGroupPolicy"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgCreateGroupPolicy",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateGroupWithPolicy"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgCreateGroupWithPolicy",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgCreateGroupWithPolicy"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgCreateGroupWithPolicy",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgExec"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgExec",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgExec"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgExec",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgLeaveGroup"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgLeaveGroup",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgLeaveGroup"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgLeaveGroup",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSubmitProposal"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgSubmitProposal",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgSubmitProposal"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgSubmitProposal",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateGroupAdmin"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgUpdateGroupAdmin",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgUpdateGroupAdmin"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgUpdateGroupAdmin",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateGroupMembers"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgUpdateGroupMembers",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgUpdateGroupMembers"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgUpdateGroupMembers",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateGroupMetadata"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgUpdateGroupMetadata",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgUpdateGroupMetadata"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgUpdateGroupMetadata",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateGroupPolicyAdmin"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateGroupPolicyDecisionPolicy"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateGroupPolicyMetadata"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgVote"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgVote",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgVote"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgVote",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgWithdrawProposal"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgWithdrawProposal",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgWithdrawProposal"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgWithdrawProposal",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSend"
                      },
                      "type_url": {
                        "default": "/cosmos.nft.v1beta1.MsgSend",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.nft.v1beta1.MsgSend"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.nft.v1beta1.MsgSend",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUnjail"
                      },
                      "type_url": {
                        "default": "/cosmos.slashing.v1beta1.MsgUnjail",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.slashing.v1beta1.MsgUnjail"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.slashing.v1beta1.MsgUnjail",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgBeginRedelegate"
                      },
                      "type_url": {
                        "default": "/cosmos.staking.v1beta1.MsgBeginRedelegate",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.staking.v1beta1.MsgBeginRedelegate"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.staking.v1beta1.MsgBeginRedelegate",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCancelUnbondingDelegation"
                      },
                      "type_url": {
                        "default": "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateValidator"
                      },
                      "type_url": {
                        "default": "/cosmos.staking.v1beta1.MsgCreateValidator",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.staking.v1beta1.MsgCreateValidator"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.staking.v1beta1.MsgCreateValidator",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDelegate"
                      },
                      "type_url": {
                        "default": "/cosmos.staking.v1beta1.MsgDelegate",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.staking.v1beta1.MsgDelegate"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.staking.v1beta1.MsgDelegate",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgEditValidator"
                      },
                      "type_url": {
                        "default": "/cosmos.staking.v1beta1.MsgEditValidator",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.staking.v1beta1.MsgEditValidator"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.staking.v1beta1.MsgEditValidator",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUndelegate"
                      },
                      "type_url": {
                        "default": "/cosmos.staking.v1beta1.MsgUndelegate",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.staking.v1beta1.MsgUndelegate"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.staking.v1beta1.MsgUndelegate",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCancelUpgrade"
                      },
                      "type_url": {
                        "default": "/cosmos.upgrade.v1beta1.MsgCancelUpgrade",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.upgrade.v1beta1.MsgCancelUpgrade"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.upgrade.v1beta1.MsgCancelUpgrade",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSoftwareUpgrade"
                      },
                      "type_url": {
                        "default": "/cosmos.upgrade.v1beta1.MsgSoftwareUpgrade",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.upgrade.v1beta1.MsgSoftwareUpgrade"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.upgrade.v1beta1.MsgSoftwareUpgrade",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreatePeriodicVestingAccount"
                      },
                      "type_url": {
                        "default": "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreatePermanentLockedAccount"
                      },
                      "type_url": {
                        "default": "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateVestingAccount"
                      },
                      "type_url": {
                        "default": "/cosmos.vesting.v1beta1.MsgCreateVestingAccount",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.vesting.v1beta1.MsgCreateVestingAccount"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.vesting.v1beta1.MsgCreateVestingAccount",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateScheduledRun"
                      },
                      "type_url": {
                        "default": "/dyson.MsgCreateScheduledRun",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgCreateScheduledRun"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgCreateScheduledRun",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateStorage"
                      },
                      "type_url": {
                        "default": "/dyson.MsgCreateStorage",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgCreateStorage"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgCreateStorage",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeleteScheduledRun"
                      },
                      "type_url": {
                        "default": "/dyson.MsgDeleteScheduledRun",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgDeleteScheduledRun"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgDeleteScheduledRun",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeleteScript"
                      },
                      "type_url": {
                        "default": "/dyson.MsgDeleteScript",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgDeleteScript"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgDeleteScript",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeleteStorage"
                      },
                      "type_url": {
                        "default": "/dyson.MsgDeleteStorage",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgDeleteStorage"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgDeleteStorage",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeployAutonomousScript"
                      },
                      "type_url": {
                        "default": "/dyson.MsgDeployAutonomousScript",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgDeployAutonomousScript"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgDeployAutonomousScript",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgRun"
                      },
                      "type_url": {
                        "default": "/dyson.MsgRun",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgRun"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgRun",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateScheduledRun"
                      },
                      "type_url": {
                        "default": "/dyson.MsgUpdateScheduledRun",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgUpdateScheduledRun"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgUpdateScheduledRun",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateScript"
                      },
                      "type_url": {
                        "default": "/dyson.MsgUpdateScript",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgUpdateScript"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgUpdateScript",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateStorage"
                      },
                      "type_url": {
                        "default": "/dyson.MsgUpdateStorage",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgUpdateStorage"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgUpdateStorage",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgRegisterInterchainAccount"
                      },
                      "type_url": {
                        "default": "/ibc.applications.interchain_accounts.controller.v1.MsgRegisterInterchainAccount",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.applications.interchain_accounts.controller.v1.MsgRegisterInterchainAccount"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.applications.interchain_accounts.controller.v1.MsgRegisterInterchainAccount",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSendTx"
                      },
                      "type_url": {
                        "default": "/ibc.applications.interchain_accounts.controller.v1.MsgSendTx",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.applications.interchain_accounts.controller.v1.MsgSendTx"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.applications.interchain_accounts.controller.v1.MsgSendTx",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgTransfer"
                      },
                      "type_url": {
                        "default": "/ibc.applications.transfer.v1.MsgTransfer",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.applications.transfer.v1.MsgTransfer"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.applications.transfer.v1.MsgTransfer",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgAcknowledgement"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgAcknowledgement",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgAcknowledgement"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgAcknowledgement",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgChannelCloseConfirm"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgChannelCloseConfirm",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgChannelCloseConfirm"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgChannelCloseConfirm",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgChannelCloseInit"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgChannelCloseInit",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgChannelCloseInit"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgChannelCloseInit",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgChannelOpenAck"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgChannelOpenAck",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgChannelOpenAck"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgChannelOpenAck",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgChannelOpenConfirm"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgChannelOpenConfirm",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgChannelOpenConfirm"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgChannelOpenConfirm",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgChannelOpenInit"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgChannelOpenInit",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgChannelOpenInit"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgChannelOpenInit",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgChannelOpenTry"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgChannelOpenTry",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgChannelOpenTry"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgChannelOpenTry",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgRecvPacket"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgRecvPacket",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgRecvPacket"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgRecvPacket",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgTimeout"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgTimeout",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgTimeout"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgTimeout",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgTimeoutOnClose"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgTimeoutOnClose",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgTimeoutOnClose"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgTimeoutOnClose",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateClient"
                      },
                      "type_url": {
                        "default": "/ibc.core.client.v1.MsgCreateClient",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.client.v1.MsgCreateClient"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.client.v1.MsgCreateClient",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSubmitMisbehaviour"
                      },
                      "type_url": {
                        "default": "/ibc.core.client.v1.MsgSubmitMisbehaviour",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.client.v1.MsgSubmitMisbehaviour"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.client.v1.MsgSubmitMisbehaviour",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateClient"
                      },
                      "type_url": {
                        "default": "/ibc.core.client.v1.MsgUpdateClient",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.client.v1.MsgUpdateClient"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.client.v1.MsgUpdateClient",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpgradeClient"
                      },
                      "type_url": {
                        "default": "/ibc.core.client.v1.MsgUpgradeClient",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.client.v1.MsgUpgradeClient"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.client.v1.MsgUpgradeClient",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgConnectionOpenAck"
                      },
                      "type_url": {
                        "default": "/ibc.core.connection.v1.MsgConnectionOpenAck",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.connection.v1.MsgConnectionOpenAck"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.connection.v1.MsgConnectionOpenAck",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgConnectionOpenConfirm"
                      },
                      "type_url": {
                        "default": "/ibc.core.connection.v1.MsgConnectionOpenConfirm",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.connection.v1.MsgConnectionOpenConfirm"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.connection.v1.MsgConnectionOpenConfirm",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgConnectionOpenInit"
                      },
                      "type_url": {
                        "default": "/ibc.core.connection.v1.MsgConnectionOpenInit",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.connection.v1.MsgConnectionOpenInit"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.connection.v1.MsgConnectionOpenInit",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgConnectionOpenTry"
                      },
                      "type_url": {
                        "default": "/ibc.core.connection.v1.MsgConnectionOpenTry",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.connection.v1.MsgConnectionOpenTry"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.connection.v1.MsgConnectionOpenTry",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgAccept"
                      },
                      "type_url": {
                        "default": "/names.MsgAccept",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgAccept"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgAccept",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgBurnCoins"
                      },
                      "type_url": {
                        "default": "/names.MsgBurnCoins",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgBurnCoins"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgBurnCoins",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgBurnNft"
                      },
                      "type_url": {
                        "default": "/names.MsgBurnNft",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgBurnNft"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgBurnNft",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgBuy"
                      },
                      "type_url": {
                        "default": "/names.MsgBuy",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgBuy"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgBuy",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeleteName"
                      },
                      "type_url": {
                        "default": "/names.MsgDeleteName",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgDeleteName"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgDeleteName",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgMintCoins"
                      },
                      "type_url": {
                        "default": "/names.MsgMintCoins",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgMintCoins"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgMintCoins",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgMintNft"
                      },
                      "type_url": {
                        "default": "/names.MsgMintNft",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgMintNft"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgMintNft",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgOfferTo"
                      },
                      "type_url": {
                        "default": "/names.MsgOfferTo",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgOfferTo"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgOfferTo",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgRegister"
                      },
                      "type_url": {
                        "default": "/names.MsgRegister",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgRegister"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgRegister",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgReveal"
                      },
                      "type_url": {
                        "default": "/names.MsgReveal",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgReveal"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgReveal",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSetNftClass"
                      },
                      "type_url": {
                        "default": "/names.MsgSetNftClass",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgSetNftClass"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgSetNftClass",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSetPriceAndExtend"
                      },
                      "type_url": {
                        "default": "/names.MsgSetPriceAndExtend",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgSetPriceAndExtend"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgSetPriceAndExtend",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateName"
                      },
                      "type_url": {
                        "default": "/names.MsgUpdateName",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgUpdateName"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgUpdateName",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateNft"
                      },
                      "type_url": {
                        "default": "/names.MsgUpdateNft",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgUpdateNft"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgUpdateNft",
                    "type": "object"
                  }
                ]
              },
              "type": "array"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata attached to the proposal.",
              "type": "string"
            },
            "proposer": {
              "type": "string"
            }
          },
          "title": "Msg Submit Proposal",
          "type": "object"
        },
        "MsgTimeout": {
          "additionalProperties": false,
          "description": "MsgTimeout receives timed-out packet",
          "properties": {
            "next_sequence_recv": {
              "type": "string"
            },
            "packet": {
              "$ref": "#/definitions/ibc.core.channel.v1.Packet",
              "additionalProperties": false
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_unreceived": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Timeout",
          "type": "object"
        },
        "MsgTimeoutOnClose": {
          "additionalProperties": false,
          "description": "MsgTimeoutOnClose timed-out packet upon counterparty channel closure.",
          "properties": {
            "next_sequence_recv": {
              "type": "string"
            },
            "packet": {
              "$ref": "#/definitions/ibc.core.channel.v1.Packet",
              "additionalProperties": false
            },
            "proof_close": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_unreceived": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Timeout On Close",
          "type": "object"
        },
        "MsgTransfer": {
          "additionalProperties": false,
          "description": "MsgTransfer defines a msg to transfer fungible tokens (i.e Coins) between ICS20 enabled chains. See ICS Spec here: https://github.com/cosmos/ibc/tree/master/spec/app/ics-020-fungible-token-transfer#data-structures",
          "properties": {
            "memo": {
              "description": "optional memo",
              "type": "string"
            },
            "receiver": {
              "description": "the recipient address on the destination chain",
              "type": "string"
            },
            "sender": {
              "description": "the sender address",
              "type": "string"
            },
            "source_channel": {
              "description": "the channel by which the packet will be sent",
              "type": "string"
            },
            "source_port": {
              "description": "the port on which the packet will be sent",
              "type": "string"
            },
            "timeout_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false,
              "description": "Timeout height relative to the current block height. The timeout is disabled when set to 0."
            },
            "timeout_timestamp": {
              "description": "Timeout timestamp in absolute nanoseconds since unix epoch. The timeout is disabled when set to 0.",
              "type": "string"
            },
            "token": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false,
              "description": "the tokens to be transferred"
            }
          },
          "title": "Msg Transfer",
          "type": "object"
        },
        "MsgUndelegate": {
          "additionalProperties": false,
          "description": "MsgUndelegate defines a SDK message for performing an undelegation from a delegate and a validator.",
          "properties": {
            "amount": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false
            },
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Undelegate",
          "type": "object"
        },
        "MsgUnjail": {
          "additionalProperties": false,
          "description": "MsgUnjail defines the Msg/Unjail request type",
          "properties": {
            "validator_addr": {
              "type": "string"
            }
          },
          "title": "Msg Unjail",
          "type": "object"
        },
        "MsgUpdateClient": {
          "additionalProperties": false,
          "description": "MsgUpdateClient defines an sdk.Msg to update a IBC client state using the given header.",
          "properties": {
            "client_id": {
              "description": "client unique identifier",
              "type": "string"
            },
            "header": {
              "additionalProperties": false,
              "description": "header to update the light client",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "signer": {
              "description": "signer address",
              "type": "string"
            }
          },
          "title": "Msg Update Client",
          "type": "object"
        },
        "MsgUpdateGroupAdmin": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.",
          "properties": {
            "admin": {
              "description": "admin is the current account address of the group admin.",
              "type": "string"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "new_admin": {
              "description": "new_admin is the group new admin account address.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Admin",
          "type": "object"
        },
        "MsgUpdateGroupMembers": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "member_updates": {
              "description": "member_updates is the list of members to update, set weight to 0 to remove a member.",
              "items": {
                "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
              },
              "type": "array"
            }
          },
          "title": "Msg Update Group Members",
          "type": "object"
        },
        "MsgUpdateGroupMetadata": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is the updated group's metadata.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Metadata",
          "type": "object"
        },
        "MsgUpdateGroupPolicyAdmin": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "group_policy_address": {
              "description": "group_policy_address is the account address of the group policy.",
              "type": "string"
            },
            "new_admin": {
              "description": "new_admin is the new group policy admin.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Policy Admin",
          "type": "object"
        },
        "MsgUpdateGroupPolicyDecisionPolicy": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "decision_policy": {
              "additionalProperties": false,
              "description": "decision_policy is the updated group policy's decision policy.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "group_policy_address": {
              "description": "group_policy_address is the account address of group policy.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Policy Decision Policy",
          "type": "object"
        },
        "MsgUpdateGroupPolicyMetadata": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "group_policy_address": {
              "description": "group_policy_address is the account address of group policy.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is the updated group policy metadata.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Policy Metadata",
          "type": "object"
        },
        "MsgUpdateName": {
          "additionalProperties": false,
          "description": "Update the details of the Dyson Protocol name",
          "properties": {
            "authorized": {
              "description": "The address that this name is OfferedTo, they can take ownership of the name with the Accept message",
              "type": "string"
            },
            "auto_renew": {
              "description": "Will the name be automatically renewed at the expiration height. The expiration height is extended by 31,536,000 blocks (about 1 year). The fee is 1% of the price and is paid by the owner at the time of the renewal.",
              "type": "boolean"
            },
            "destination": {
              "description": "The new destination address for the name",
              "type": "string"
            },
            "name": {
              "description": "The name to update",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            }
          },
          "title": "Msg Update Name",
          "type": "object"
        },
        "MsgUpdateNft": {
          "additionalProperties": false,
          "description": "Update the details of an NFT",
          "properties": {
            "class_id": {
              "description": "the NFT Class ID",
              "type": "string"
            },
            "class_owner": {
              "description": "The owner of the NFT Class",
              "type": "string"
            },
            "id": {
              "description": "The ID of this NFT to update",
              "type": "string"
            },
            "uri": {
              "description": "The URI of the NFT (optional)",
              "type": "string"
            },
            "uri_hash": {
              "description": "The URI hash of the NFT (optional)",
              "type": "string"
            }
          },
          "title": "Msg Update Nft",
          "type": "object"
        },
        "MsgUpdateScheduledRun": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            },
            "index": {
              "type": "string"
            },
            "msg": {
              "$ref": "#/definitions/dyson.MsgRun",
              "additionalProperties": false
            }
          },
          "title": "Msg Update Scheduled Run",
          "type": "object"
        },
        "MsgUpdateScript": {
          "additionalProperties": false,
          "properties": {
            "code": {
              "format": "python",
              "type": "string"
            },
            "creator": {
              "type": "string"
            }
          },
          "title": "Msg Update Script",
          "type": "object"
        },
        "MsgUpdateStorage": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "description": "The address signing this transaction",
              "type": "string"
            },
            "data": {
              "description": "data to store at this index",
              "type": "string"
            },
            "force": {
              "description": "If true, force will always store the data at this address regardless of already existing storage",
              "type": "boolean"
            },
            "index": {
              "description": "Name of the Storage, must be prefixed with the creators address (for example: \"dys..1a3/some_name\")",
              "type": "string"
            }
          },
          "title": "Msg Update Storage",
          "type": "object"
        },
        "MsgUpgradeClient": {
          "additionalProperties": false,
          "description": "MsgUpgradeClient defines an sdk.Msg to upgrade an IBC client to a new client state",
          "properties": {
            "client_id": {
              "description": "client unique identifier",
              "type": "string"
            },
            "client_state": {
              "additionalProperties": false,
              "description": "upgraded client state",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "consensus_state": {
              "additionalProperties": false,
              "description": "upgraded consensus state, only contains enough information to serve as a basis of trust in update logic",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "proof_upgrade_client": {
              "binaryEncoding": "base64",
              "description": "proof that old chain committed to new client",
              "format": "binary",
              "type": "string"
            },
            "proof_upgrade_consensus_state": {
              "binaryEncoding": "base64",
              "description": "proof that old chain committed to new consensus state",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "description": "signer address",
              "type": "string"
            }
          },
          "title": "Msg Upgrade Client",
          "type": "object"
        },
        "MsgVerifyInvariant": {
          "additionalProperties": false,
          "description": "MsgVerifyInvariant represents a message to verify a particular invariance.",
          "properties": {
            "invariant_module_name": {
              "type": "string"
            },
            "invariant_route": {
              "type": "string"
            },
            "sender": {
              "type": "string"
            }
          },
          "title": "Msg Verify Invariant",
          "type": "object"
        },
        "MsgVote": {
          "additionalProperties": false,
          "description": "MsgVote is the Msg/Vote request type.",
          "properties": {
            "exec": {
              "description": "Proposals and Voting  Exec defines modes of execution of a proposal on creation or on new vote.",
              "enum": [
                "EXEC_UNSPECIFIED",
                0,
                "EXEC_TRY",
                1
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Proposals and Voting"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata to attached to the vote.",
              "type": "string"
            },
            "option": {
              "description": "VoteOption enumerates the valid vote options for a given proposal.",
              "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                0,
                "VOTE_OPTION_YES",
                1,
                "VOTE_OPTION_ABSTAIN",
                2,
                "VOTE_OPTION_NO",
                3,
                "VOTE_OPTION_NO_WITH_VETO",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Vote Option"
            },
            "proposal_id": {
              "description": "proposal is the unique ID of the proposal.",
              "type": "string"
            },
            "voter": {
              "description": "voter is the voter account address.",
              "type": "string"
            }
          },
          "title": "Msg Vote",
          "type": "object"
        },
        "MsgVoteWeighted": {
          "additionalProperties": false,
          "description": "MsgVoteWeighted defines a message to cast a vote. Since: cosmos-sdk 0.43",
          "properties": {
            "options": {
              "items": {
                "$ref": "#/definitions/cosmos.gov.v1beta1.WeightedVoteOption"
              },
              "type": "array"
            },
            "proposal_id": {
              "type": "string"
            },
            "voter": {
              "type": "string"
            }
          },
          "title": "Msg Vote Weighted",
          "type": "object"
        },
        "MsgWithdrawDelegatorReward": {
          "additionalProperties": false,
          "description": "MsgWithdrawDelegatorReward represents delegation withdrawal to a delegator from a single validator.",
          "properties": {
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Withdraw Delegator Reward",
          "type": "object"
        },
        "MsgWithdrawProposal": {
          "additionalProperties": false,
          "description": "MsgWithdrawProposal is the Msg/WithdrawProposal request type.",
          "properties": {
            "address": {
              "description": "address is the admin of the group policy or one of the proposer of the proposal.",
              "type": "string"
            },
            "proposal_id": {
              "description": "proposal is the unique ID of the proposal.",
              "type": "string"
            }
          },
          "title": "Msg Withdraw Proposal",
          "type": "object"
        },
        "MsgWithdrawValidatorCommission": {
          "additionalProperties": false,
          "description": "MsgWithdrawValidatorCommission withdraws the full commission to the validator address.",
          "properties": {
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Withdraw Validator Commission",
          "type": "object"
        },
        "cosmos.authz.v1beta1.Grant": {
          "additionalProperties": false,
          "description": "Grant gives permissions to execute the provide method with expiration time.",
          "properties": {
            "authorization": {
              "additionalProperties": false,
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "expiration": {
              "description": "time when the grant will expire and will be pruned. If null, then the grant doesn't have a time expiration (other conditions  in `authorization` may apply to invalidate the grant)",
              "format": "date-time",
              "type": "string"
            }
          },
          "title": "Grant",
          "type": "object"
        },
        "cosmos.bank.v1beta1.Input": {
          "additionalProperties": false,
          "description": "Input models transaction input.",
          "properties": {
            "address": {
              "type": "string"
            },
            "coins": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            }
          },
          "title": "Input",
          "type": "object"
        },
        "cosmos.bank.v1beta1.Output": {
          "additionalProperties": false,
          "description": "Output models transaction outputs.",
          "properties": {
            "address": {
              "type": "string"
            },
            "coins": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            }
          },
          "title": "Output",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        },
        "cosmos.gov.v1.WeightedVoteOption": {
          "additionalProperties": false,
          "description": "WeightedVoteOption defines a unit of vote for vote split.",
          "properties": {
            "option": {
              "description": "VoteOption enumerates the valid vote options for a given governance proposal.",
              "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                0,
                "VOTE_OPTION_YES",
                1,
                "VOTE_OPTION_ABSTAIN",
                2,
                "VOTE_OPTION_NO",
                3,
                "VOTE_OPTION_NO_WITH_VETO",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Vote Option"
            },
            "weight": {
              "type": "string"
            }
          },
          "title": "Weighted Vote Option",
          "type": "object"
        },
        "cosmos.gov.v1beta1.WeightedVoteOption": {
          "additionalProperties": false,
          "description": "WeightedVoteOption defines a unit of vote for vote split. Since: cosmos-sdk 0.43",
          "properties": {
            "option": {
              "description": "VoteOption enumerates the valid vote options for a given governance proposal.",
              "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                0,
                "VOTE_OPTION_YES",
                1,
                "VOTE_OPTION_ABSTAIN",
                2,
                "VOTE_OPTION_NO",
                3,
                "VOTE_OPTION_NO_WITH_VETO",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Vote Option"
            },
            "weight": {
              "type": "string"
            }
          },
          "title": "Weighted Vote Option",
          "type": "object"
        },
        "cosmos.group.v1.MemberRequest": {
          "additionalProperties": false,
          "description": "MemberRequest represents a group member to be used in Msg server requests. Contrary to `Member`, it doesn't have any `added_at` field since this field cannot be set as part of requests.",
          "properties": {
            "address": {
              "description": "address is the member's account address.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata attached to the member.",
              "type": "string"
            },
            "weight": {
              "description": "weight is the member's voting weight that should be greater than 0.",
              "type": "string"
            }
          },
          "title": "Member Request",
          "type": "object"
        },
        "cosmos.staking.v1beta1.CommissionRates": {
          "additionalProperties": false,
          "description": "CommissionRates defines the initial commission rates to be used for creating a validator.",
          "properties": {
            "max_change_rate": {
              "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction.",
              "type": "string"
            },
            "max_rate": {
              "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction.",
              "type": "string"
            },
            "rate": {
              "description": "rate is the commission rate charged to delegators, as a fraction.",
              "type": "string"
            }
          },
          "title": "Commission Rates",
          "type": "object"
        },
        "cosmos.staking.v1beta1.Description": {
          "additionalProperties": false,
          "description": "Description defines a validator description.",
          "properties": {
            "details": {
              "description": "details define other optional details.",
              "type": "string"
            },
            "identity": {
              "description": "identity defines an optional identity signature (ex. UPort or Keybase).",
              "type": "string"
            },
            "moniker": {
              "description": "moniker defines a human-readable name for the validator.",
              "type": "string"
            },
            "security_contact": {
              "description": "security_contact defines an optional email for security contact.",
              "type": "string"
            },
            "website": {
              "description": "website defines an optional website link.",
              "type": "string"
            }
          },
          "title": "Description",
          "type": "object"
        },
        "cosmos.upgrade.v1beta1.Plan": {
          "additionalProperties": false,
          "description": "Plan specifies information about a planned upgrade and when it should occur.",
          "properties": {
            "height": {
              "description": "The height at which the upgrade must be performed. Only used if Time is not set.",
              "type": "string"
            },
            "info": {
              "description": "Any application specific upgrade info to be included on-chain such as a git commit that validators could automatically upgrade to",
              "type": "string"
            },
            "name": {
              "description": "Sets the name for the upgrade. This name will be used by the upgraded version of the software to apply any special \"on-upgrade\" commands during the first BeginBlock method after the upgrade is applied. It is also used to detect whether a software version can handle a given upgrade. If no upgrade handler with this name has been set in the software, it will be assumed that the software is out-of-date when the upgrade Time or Height is reached and the software will exit.",
              "type": "string"
            },
            "time": {
              "description": "Deprecated: Time based upgrades have been deprecated. Time based upgrade logic has been removed from the SDK. If this field is not empty, an error will be thrown.",
              "format": "date-time",
              "type": "string"
            },
            "upgraded_client_state": {
              "additionalProperties": false,
              "description": "Deprecated: UpgradedClientState field has been deprecated. IBC upgrade logic has been moved to the IBC module in the sub module 02-client. If this field is not empty, an error will be thrown.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "title": "Plan",
          "type": "object"
        },
        "cosmos.vesting.v1beta1.Period": {
          "additionalProperties": false,
          "description": "Period defines a length of time and amount of coins that will vest.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "length": {
              "type": "string"
            }
          },
          "title": "Period",
          "type": "object"
        },
        "dyson.MsgRun": {
          "additionalProperties": false,
          "description": "MsgRun runs a script at a specific address",
          "properties": {
            "address": {
              "description": "Dys address of the script to call",
              "type": "string"
            },
            "args": {
              "description": "Optional args to call the function with",
              "type": "string"
            },
            "coins": {
              "description": "Optional comma seperated list of coins to send the script (for example \"123dys,456token\") this entire amount will be sent to the script",
              "type": "string"
            },
            "creator": {
              "description": "The account sending this transaction",
              "type": "string"
            },
            "extra_lines": {
              "description": "Optional extra source code to append to the end of the script before running. Only available to the script address itself.",
              "type": "string"
            },
            "function_name": {
              "description": "Optional function to call",
              "type": "string"
            },
            "kwargs": {
              "description": "Optional kwargs to run",
              "type": "string"
            },
            "nfts": {
              "description": "Optional NFTs to send the script, formatted [class_id]/[id], [class_id]/[id] (for example \"example.dys/123, example.dys/456\")",
              "type": "string"
            }
          },
          "title": "Msg Run",
          "type": "object"
        },
        "ibc.applications.interchain_accounts.v1.InterchainAccountPacketData": {
          "additionalProperties": false,
          "description": "InterchainAccountPacketData is comprised of a raw transaction, type of transaction and optional memo field.",
          "properties": {
            "data": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "memo": {
              "type": "string"
            },
            "type": {
              "description": "Type defines a classification of message issued from a controller chain to its associated interchain accounts host",
              "enum": [
                "TYPE_UNSPECIFIED",
                0,
                "TYPE_EXECUTE_TX",
                1
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Type"
            }
          },
          "title": "Interchain Account Packet Data",
          "type": "object"
        },
        "ibc.core.channel.v1.Channel": {
          "additionalProperties": false,
          "description": "Channel defines pipeline for exactly-once packet delivery between specific modules on separate blockchains, which has at least one end capable of sending packets and one end capable of receiving packets.",
          "properties": {
            "connection_hops": {
              "description": "list of connection identifiers, in order, along which packets sent on this channel will travel",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "counterparty": {
              "$ref": "#/definitions/ibc.core.channel.v1.Counterparty",
              "additionalProperties": false,
              "description": "counterparty channel end"
            },
            "ordering": {
              "description": "Order defines if a channel is ORDERED or UNORDERED",
              "enum": [
                "ORDER_NONE_UNSPECIFIED",
                0,
                "ORDER_UNORDERED",
                1,
                "ORDER_ORDERED",
                2
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Order"
            },
            "state": {
              "description": "State defines if a channel is in one of the following states: CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.",
              "enum": [
                "STATE_UNINITIALIZED_UNSPECIFIED",
                0,
                "STATE_INIT",
                1,
                "STATE_TRYOPEN",
                2,
                "STATE_OPEN",
                3,
                "STATE_CLOSED",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "State"
            },
            "version": {
              "description": "opaque channel version, which is agreed upon during the handshake",
              "type": "string"
            }
          },
          "title": "Channel",
          "type": "object"
        },
        "ibc.core.channel.v1.Counterparty": {
          "additionalProperties": false,
          "description": "Counterparty defines a channel end counterparty",
          "properties": {
            "channel_id": {
              "description": "channel end on the counterparty chain",
              "type": "string"
            },
            "port_id": {
              "description": "port on the counterparty chain which owns the other end of the channel.",
              "type": "string"
            }
          },
          "title": "Counterparty",
          "type": "object"
        },
        "ibc.core.channel.v1.Packet": {
          "additionalProperties": false,
          "description": "Packet defines a type that carries data across different chains through IBC",
          "properties": {
            "data": {
              "binaryEncoding": "base64",
              "description": "actual opaque bytes transferred directly to the application module",
              "format": "binary",
              "type": "string"
            },
            "destination_channel": {
              "description": "identifies the channel end on the receiving chain.",
              "type": "string"
            },
            "destination_port": {
              "description": "identifies the port on the receiving chain.",
              "type": "string"
            },
            "sequence": {
              "description": "number corresponds to the order of sends and receives, where a Packet with an earlier sequence number must be sent and received before a Packet with a later sequence number.",
              "type": "string"
            },
            "source_channel": {
              "description": "identifies the channel end on the sending chain.",
              "type": "string"
            },
            "source_port": {
              "description": "identifies the port on the sending chain.",
              "type": "string"
            },
            "timeout_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false,
              "description": "block height after which the packet times out"
            },
            "timeout_timestamp": {
              "description": "block timestamp (in nanoseconds) after which the packet times out",
              "type": "string"
            }
          },
          "title": "Packet",
          "type": "object"
        },
        "ibc.core.client.v1.Height": {
          "additionalProperties": false,
          "description": "Height is a monotonically increasing data type that can be compared against another Height for the purposes of updating and freezing clients Normally the RevisionHeight is incremented at each height while keeping RevisionNumber the same. However some consensus algorithms may choose to reset the height in certain conditions e.g. hard forks, state-machine breaking changes In these cases, the RevisionNumber is incremented so that height continues to be monitonically increasing even as the RevisionHeight gets reset",
          "properties": {
            "revision_height": {
              "description": "the height within the given revision",
              "type": "string"
            },
            "revision_number": {
              "description": "the revision that the client is currently on",
              "type": "string"
            }
          },
          "title": "Height",
          "type": "object"
        },
        "ibc.core.commitment.v1.MerklePrefix": {
          "additionalProperties": false,
          "description": "MerklePrefix is merkle path prefixed to the key. The constructed key from the Path and the key will be append(Path.KeyPath, append(Path.KeyPrefix, key...))",
          "properties": {
            "key_prefix": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            }
          },
          "title": "Merkle Prefix",
          "type": "object"
        },
        "ibc.core.connection.v1.Counterparty": {
          "additionalProperties": false,
          "description": "Counterparty defines the counterparty chain associated with a connection end.",
          "properties": {
            "client_id": {
              "description": "identifies the client on the counterparty chain associated with a given connection.",
              "type": "string"
            },
            "connection_id": {
              "description": "identifies the connection end on the counterparty chain associated with a given connection.",
              "type": "string"
            },
            "prefix": {
              "$ref": "#/definitions/ibc.core.commitment.v1.MerklePrefix",
              "additionalProperties": false,
              "description": "commitment merkle prefix of the counterparty chain."
            }
          },
          "title": "Counterparty",
          "type": "object"
        },
        "ibc.core.connection.v1.Version": {
          "additionalProperties": false,
          "description": "Version defines the versioning scheme used to negotiate the IBC verison in the connection handshake.",
          "properties": {
            "features": {
              "description": "list of features compatible with the specified identifier",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "identifier": {
              "description": "unique version identifier",
              "type": "string"
            }
          },
          "title": "Version",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.gov.v1/sendMsgVote": {
    "http_rules": null,
    "module_name": "cosmos.gov.v1",
    "name": "Vote",
    "request_schema": {
      "$ref": "#/definitions/MsgVote",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgVote": {
          "additionalProperties": false,
          "description": "MsgVote defines a message to cast a vote.",
          "properties": {
            "metadata": {
              "type": "string"
            },
            "option": {
              "description": "VoteOption enumerates the valid vote options for a given governance proposal.",
              "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                0,
                "VOTE_OPTION_YES",
                1,
                "VOTE_OPTION_ABSTAIN",
                2,
                "VOTE_OPTION_NO",
                3,
                "VOTE_OPTION_NO_WITH_VETO",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Vote Option"
            },
            "proposal_id": {
              "type": "string"
            },
            "voter": {
              "type": "string"
            }
          },
          "title": "Msg Vote",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/gov/v1/proposals/{proposal_id}/votes/{voter}",
    "service_name": "Msg"
  },
  "cosmos.gov.v1/sendMsgVoteWeighted": {
    "http_rules": null,
    "module_name": "cosmos.gov.v1",
    "name": "VoteWeighted",
    "request_schema": {
      "$ref": "#/definitions/MsgVoteWeighted",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgVoteWeighted": {
          "additionalProperties": false,
          "description": "MsgVoteWeighted defines a message to cast a vote.",
          "properties": {
            "metadata": {
              "type": "string"
            },
            "options": {
              "items": {
                "$ref": "#/definitions/cosmos.gov.v1.WeightedVoteOption"
              },
              "type": "array"
            },
            "proposal_id": {
              "type": "string"
            },
            "voter": {
              "type": "string"
            }
          },
          "title": "Msg Vote Weighted",
          "type": "object"
        },
        "cosmos.gov.v1.WeightedVoteOption": {
          "additionalProperties": false,
          "description": "WeightedVoteOption defines a unit of vote for vote split.",
          "properties": {
            "option": {
              "description": "VoteOption enumerates the valid vote options for a given governance proposal.",
              "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                0,
                "VOTE_OPTION_YES",
                1,
                "VOTE_OPTION_ABSTAIN",
                2,
                "VOTE_OPTION_NO",
                3,
                "VOTE_OPTION_NO_WITH_VETO",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Vote Option"
            },
            "weight": {
              "type": "string"
            }
          },
          "title": "Weighted Vote Option",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.gov.v1beta1/QueryDeposit": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "proposal_id",
          "depositor"
        ]
      }
    ],
    "module_name": "cosmos.gov.v1beta1",
    "name": "Deposit",
    "request_schema": {
      "$ref": "#/definitions/QueryDepositRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryDepositRequest": {
          "additionalProperties": false,
          "description": "QueryDepositRequest is the request type for the Query/Deposit RPC method.",
          "properties": {
            "depositor": {
              "description": "depositor defines the deposit addresses from the proposals.",
              "type": "string"
            },
            "proposal_id": {
              "description": "proposal_id defines the unique id of the proposal.",
              "type": "string"
            }
          },
          "title": "Query Deposit Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}",
    "service_name": "Query"
  },
  "cosmos.gov.v1beta1/QueryDeposits": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "proposal_id"
        ]
      }
    ],
    "module_name": "cosmos.gov.v1beta1",
    "name": "Deposits",
    "request_schema": {
      "$ref": "#/definitions/QueryDepositsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryDepositsRequest": {
          "additionalProperties": false,
          "description": "QueryDepositsRequest is the request type for the Query/Deposits RPC method.",
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            },
            "proposal_id": {
              "description": "proposal_id defines the unique id of the proposal.",
              "type": "string"
            }
          },
          "title": "Query Deposits Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits",
    "service_name": "Query"
  },
  "cosmos.gov.v1beta1/QueryParams": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "params_type"
        ]
      }
    ],
    "module_name": "cosmos.gov.v1beta1",
    "name": "Params",
    "request_schema": {
      "$ref": "#/definitions/QueryParamsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryParamsRequest": {
          "additionalProperties": false,
          "description": "QueryParamsRequest is the request type for the Query/Params RPC method.",
          "properties": {
            "params_type": {
              "description": "params_type defines which parameters to query for, can be one of \"voting\", \"tallying\" or \"deposit\".",
              "type": "string"
            }
          },
          "title": "Query Params Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/gov/v1beta1/params/{params_type}",
    "service_name": "Query"
  },
  "cosmos.gov.v1beta1/QueryProposal": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "proposal_id"
        ]
      }
    ],
    "module_name": "cosmos.gov.v1beta1",
    "name": "Proposal",
    "request_schema": {
      "$ref": "#/definitions/QueryProposalRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryProposalRequest": {
          "additionalProperties": false,
          "description": "QueryProposalRequest is the request type for the Query/Proposal RPC method.",
          "properties": {
            "proposal_id": {
              "description": "proposal_id defines the unique id of the proposal.",
              "type": "string"
            }
          },
          "title": "Query Proposal Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/gov/v1beta1/proposals/{proposal_id}",
    "service_name": "Query"
  },
  "cosmos.gov.v1beta1/QueryProposals": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "cosmos.gov.v1beta1",
    "name": "Proposals",
    "request_schema": {
      "$ref": "#/definitions/QueryProposalsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryProposalsRequest": {
          "additionalProperties": false,
          "description": "QueryProposalsRequest is the request type for the Query/Proposals RPC method.",
          "properties": {
            "depositor": {
              "description": "depositor defines the deposit addresses from the proposals.",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            },
            "proposal_status": {
              "description": "ProposalStatus enumerates the valid statuses of a proposal.",
              "enum": [
                "PROPOSAL_STATUS_UNSPECIFIED",
                0,
                "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                1,
                "PROPOSAL_STATUS_VOTING_PERIOD",
                2,
                "PROPOSAL_STATUS_PASSED",
                3,
                "PROPOSAL_STATUS_REJECTED",
                4,
                "PROPOSAL_STATUS_FAILED",
                5
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Proposal Status"
            },
            "voter": {
              "description": "voter defines the voter address for the proposals.",
              "type": "string"
            }
          },
          "title": "Query Proposals Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/gov/v1beta1/proposals",
    "service_name": "Query"
  },
  "cosmos.gov.v1beta1/QueryTallyResult": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "proposal_id"
        ]
      }
    ],
    "module_name": "cosmos.gov.v1beta1",
    "name": "TallyResult",
    "request_schema": {
      "$ref": "#/definitions/QueryTallyResultRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryTallyResultRequest": {
          "additionalProperties": false,
          "description": "QueryTallyResultRequest is the request type for the Query/Tally RPC method.",
          "properties": {
            "proposal_id": {
              "description": "proposal_id defines the unique id of the proposal.",
              "type": "string"
            }
          },
          "title": "Query Tally Result Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/gov/v1beta1/proposals/{proposal_id}/tally",
    "service_name": "Query"
  },
  "cosmos.gov.v1beta1/QueryVote": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "proposal_id",
          "voter"
        ]
      }
    ],
    "module_name": "cosmos.gov.v1beta1",
    "name": "Vote",
    "request_schema": {
      "$ref": "#/definitions/QueryVoteRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryVoteRequest": {
          "additionalProperties": false,
          "description": "QueryVoteRequest is the request type for the Query/Vote RPC method.",
          "properties": {
            "proposal_id": {
              "description": "proposal_id defines the unique id of the proposal.",
              "type": "string"
            },
            "voter": {
              "description": "voter defines the voter address for the proposals.",
              "type": "string"
            }
          },
          "title": "Query Vote Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}",
    "service_name": "Query"
  },
  "cosmos.gov.v1beta1/QueryVotes": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "proposal_id"
        ]
      }
    ],
    "module_name": "cosmos.gov.v1beta1",
    "name": "Votes",
    "request_schema": {
      "$ref": "#/definitions/QueryVotesRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryVotesRequest": {
          "additionalProperties": false,
          "description": "QueryVotesRequest is the request type for the Query/Votes RPC method.",
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            },
            "proposal_id": {
              "description": "proposal_id defines the unique id of the proposal.",
              "type": "string"
            }
          },
          "title": "Query Votes Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/gov/v1beta1/proposals/{proposal_id}/votes",
    "service_name": "Query"
  },
  "cosmos.gov.v1beta1/sendMsgDeposit": {
    "http_rules": null,
    "module_name": "cosmos.gov.v1beta1",
    "name": "Deposit",
    "request_schema": {
      "$ref": "#/definitions/MsgDeposit",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgDeposit": {
          "additionalProperties": false,
          "description": "MsgDeposit defines a message to submit a deposit to an existing proposal.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "depositor": {
              "type": "string"
            },
            "proposal_id": {
              "type": "string"
            }
          },
          "title": "Msg Deposit",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}",
    "service_name": "Msg"
  },
  "cosmos.gov.v1beta1/sendMsgSubmitProposal": {
    "http_rules": null,
    "module_name": "cosmos.gov.v1beta1",
    "name": "SubmitProposal",
    "request_schema": {
      "$ref": "#/definitions/MsgSubmitProposal",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "CancelSoftwareUpgradeProposal": {
          "additionalProperties": false,
          "description": "CancelSoftwareUpgradeProposal is a gov Content type for cancelling a software upgrade. Deprecated: This legacy proposal is deprecated in favor of Msg-based gov proposals, see MsgCancelUpgrade.",
          "properties": {
            "description": {
              "type": "string"
            },
            "title": {
              "type": "string"
            }
          },
          "title": "Cancel Software Upgrade Proposal",
          "type": "object"
        },
        "ClientUpdateProposal": {
          "additionalProperties": false,
          "description": "ClientUpdateProposal is a governance proposal. If it passes, the substitute client's latest consensus state is copied over to the subject client. The proposal handler may fail if the subject and the substitute do not match in client and chain parameters (with exception to latest height, frozen height, and chain-id).",
          "properties": {
            "description": {
              "description": "the description of the proposal",
              "type": "string"
            },
            "subject_client_id": {
              "description": "the client identifier for the client to be updated if the proposal passes",
              "type": "string"
            },
            "substitute_client_id": {
              "description": "the substitute client identifier for the client standing in for the subject client",
              "type": "string"
            },
            "title": {
              "description": "the title of the update proposal",
              "type": "string"
            }
          },
          "title": "Client Update Proposal",
          "type": "object"
        },
        "CommunityPoolSpendProposal": {
          "additionalProperties": false,
          "description": "CommunityPoolSpendProposal details a proposal for use of community funds, together with how many coins are proposed to be spent, and to which recipient account.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "description": {
              "type": "string"
            },
            "recipient": {
              "type": "string"
            },
            "title": {
              "type": "string"
            }
          },
          "title": "Community Pool Spend Proposal",
          "type": "object"
        },
        "MsgSubmitProposal": {
          "additionalProperties": false,
          "description": "MsgSubmitProposal defines an sdk.Msg type that supports submitting arbitrary proposal Content.",
          "properties": {
            "content": {
              "oneOf": [
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/CommunityPoolSpendProposal"
                    },
                    "type_url": {
                      "default": "/cosmos.distribution.v1beta1.CommunityPoolSpendProposal",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.distribution.v1beta1.CommunityPoolSpendProposal"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.distribution.v1beta1.CommunityPoolSpendProposal",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/TextProposal"
                    },
                    "type_url": {
                      "default": "/cosmos.gov.v1beta1.TextProposal",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.gov.v1beta1.TextProposal"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.gov.v1beta1.TextProposal",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/ParameterChangeProposal"
                    },
                    "type_url": {
                      "default": "/cosmos.params.v1beta1.ParameterChangeProposal",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.params.v1beta1.ParameterChangeProposal"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.params.v1beta1.ParameterChangeProposal",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/CancelSoftwareUpgradeProposal"
                    },
                    "type_url": {
                      "default": "/cosmos.upgrade.v1beta1.CancelSoftwareUpgradeProposal",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.upgrade.v1beta1.CancelSoftwareUpgradeProposal"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.upgrade.v1beta1.CancelSoftwareUpgradeProposal",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/SoftwareUpgradeProposal"
                    },
                    "type_url": {
                      "default": "/cosmos.upgrade.v1beta1.SoftwareUpgradeProposal",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.upgrade.v1beta1.SoftwareUpgradeProposal"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.upgrade.v1beta1.SoftwareUpgradeProposal",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/ClientUpdateProposal"
                    },
                    "type_url": {
                      "default": "/ibc.core.client.v1.ClientUpdateProposal",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.client.v1.ClientUpdateProposal"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.client.v1.ClientUpdateProposal",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/UpgradeProposal"
                    },
                    "type_url": {
                      "default": "/ibc.core.client.v1.UpgradeProposal",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/ibc.core.client.v1.UpgradeProposal"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "ibc.core.client.v1.UpgradeProposal",
                  "type": "object"
                }
              ]
            },
            "initial_deposit": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "proposer": {
              "type": "string"
            }
          },
          "title": "Msg Submit Proposal",
          "type": "object"
        },
        "ParameterChangeProposal": {
          "additionalProperties": false,
          "description": "ParameterChangeProposal defines a proposal to change one or more parameters.",
          "properties": {
            "changes": {
              "items": {
                "$ref": "#/definitions/cosmos.params.v1beta1.ParamChange"
              },
              "type": "array"
            },
            "description": {
              "type": "string"
            },
            "title": {
              "type": "string"
            }
          },
          "title": "Parameter Change Proposal",
          "type": "object"
        },
        "SoftwareUpgradeProposal": {
          "additionalProperties": false,
          "description": "SoftwareUpgradeProposal is a gov Content type for initiating a software upgrade. Deprecated: This legacy proposal is deprecated in favor of Msg-based gov proposals, see MsgSoftwareUpgrade.",
          "properties": {
            "description": {
              "type": "string"
            },
            "plan": {
              "$ref": "#/definitions/cosmos.upgrade.v1beta1.Plan",
              "additionalProperties": false
            },
            "title": {
              "type": "string"
            }
          },
          "title": "Software Upgrade Proposal",
          "type": "object"
        },
        "TextProposal": {
          "additionalProperties": false,
          "description": "TextProposal defines a standard text proposal whose changes need to be manually updated in case of approval.",
          "properties": {
            "description": {
              "type": "string"
            },
            "title": {
              "type": "string"
            }
          },
          "title": "Text Proposal",
          "type": "object"
        },
        "UpgradeProposal": {
          "additionalProperties": false,
          "description": "UpgradeProposal is a gov Content type for initiating an IBC breaking upgrade.",
          "properties": {
            "description": {
              "type": "string"
            },
            "plan": {
              "$ref": "#/definitions/cosmos.upgrade.v1beta1.Plan",
              "additionalProperties": false
            },
            "title": {
              "type": "string"
            },
            "upgraded_client_state": {
              "additionalProperties": false,
              "description": "An UpgradedClientState must be provided to perform an IBC breaking upgrade. This will make the chain commit to the correct upgraded (self) client state before the upgrade occurs, so that connecting chains can verify that the new upgraded client is valid by verifying a proof on the previous version of the chain. This will allow IBC connections to persist smoothly across planned chain upgrades",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "title": "Upgrade Proposal",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        },
        "cosmos.params.v1beta1.ParamChange": {
          "additionalProperties": false,
          "description": "ParamChange defines an individual parameter change, for use in ParameterChangeProposal.",
          "properties": {
            "key": {
              "type": "string"
            },
            "subspace": {
              "type": "string"
            },
            "value": {
              "type": "string"
            }
          },
          "title": "Param Change",
          "type": "object"
        },
        "cosmos.upgrade.v1beta1.Plan": {
          "additionalProperties": false,
          "description": "Plan specifies information about a planned upgrade and when it should occur.",
          "properties": {
            "height": {
              "description": "The height at which the upgrade must be performed. Only used if Time is not set.",
              "type": "string"
            },
            "info": {
              "description": "Any application specific upgrade info to be included on-chain such as a git commit that validators could automatically upgrade to",
              "type": "string"
            },
            "name": {
              "description": "Sets the name for the upgrade. This name will be used by the upgraded version of the software to apply any special \"on-upgrade\" commands during the first BeginBlock method after the upgrade is applied. It is also used to detect whether a software version can handle a given upgrade. If no upgrade handler with this name has been set in the software, it will be assumed that the software is out-of-date when the upgrade Time or Height is reached and the software will exit.",
              "type": "string"
            },
            "time": {
              "description": "Deprecated: Time based upgrades have been deprecated. Time based upgrade logic has been removed from the SDK. If this field is not empty, an error will be thrown.",
              "format": "date-time",
              "type": "string"
            },
            "upgraded_client_state": {
              "additionalProperties": false,
              "description": "Deprecated: UpgradedClientState field has been deprecated. IBC upgrade logic has been moved to the IBC module in the sub module 02-client. If this field is not empty, an error will be thrown.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "title": "Plan",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.gov.v1beta1/sendMsgVote": {
    "http_rules": null,
    "module_name": "cosmos.gov.v1beta1",
    "name": "Vote",
    "request_schema": {
      "$ref": "#/definitions/MsgVote",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgVote": {
          "additionalProperties": false,
          "description": "MsgVote defines a message to cast a vote.",
          "properties": {
            "option": {
              "description": "VoteOption enumerates the valid vote options for a given governance proposal.",
              "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                0,
                "VOTE_OPTION_YES",
                1,
                "VOTE_OPTION_ABSTAIN",
                2,
                "VOTE_OPTION_NO",
                3,
                "VOTE_OPTION_NO_WITH_VETO",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Vote Option"
            },
            "proposal_id": {
              "type": "string"
            },
            "voter": {
              "type": "string"
            }
          },
          "title": "Msg Vote",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}",
    "service_name": "Msg"
  },
  "cosmos.gov.v1beta1/sendMsgVoteWeighted": {
    "http_rules": null,
    "module_name": "cosmos.gov.v1beta1",
    "name": "VoteWeighted",
    "request_schema": {
      "$ref": "#/definitions/MsgVoteWeighted",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgVoteWeighted": {
          "additionalProperties": false,
          "description": "MsgVoteWeighted defines a message to cast a vote. Since: cosmos-sdk 0.43",
          "properties": {
            "options": {
              "items": {
                "$ref": "#/definitions/cosmos.gov.v1beta1.WeightedVoteOption"
              },
              "type": "array"
            },
            "proposal_id": {
              "type": "string"
            },
            "voter": {
              "type": "string"
            }
          },
          "title": "Msg Vote Weighted",
          "type": "object"
        },
        "cosmos.gov.v1beta1.WeightedVoteOption": {
          "additionalProperties": false,
          "description": "WeightedVoteOption defines a unit of vote for vote split. Since: cosmos-sdk 0.43",
          "properties": {
            "option": {
              "description": "VoteOption enumerates the valid vote options for a given governance proposal.",
              "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                0,
                "VOTE_OPTION_YES",
                1,
                "VOTE_OPTION_ABSTAIN",
                2,
                "VOTE_OPTION_NO",
                3,
                "VOTE_OPTION_NO_WITH_VETO",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Vote Option"
            },
            "weight": {
              "type": "string"
            }
          },
          "title": "Weighted Vote Option",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.group.v1/QueryGroupInfo": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "group_id"
        ]
      }
    ],
    "module_name": "cosmos.group.v1",
    "name": "GroupInfo",
    "request_schema": {
      "$ref": "#/definitions/QueryGroupInfoRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryGroupInfoRequest": {
          "additionalProperties": false,
          "description": "QueryGroupInfoRequest is the Query/GroupInfo request type.",
          "properties": {
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            }
          },
          "title": "Query Group Info Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/group/v1/group_info/{group_id}",
    "service_name": "Query"
  },
  "cosmos.group.v1/QueryGroupMembers": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "group_id"
        ]
      }
    ],
    "module_name": "cosmos.group.v1",
    "name": "GroupMembers",
    "request_schema": {
      "$ref": "#/definitions/QueryGroupMembersRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryGroupMembersRequest": {
          "additionalProperties": false,
          "description": "QueryGroupMembersRequest is the Query/GroupMembers request type.",
          "properties": {
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            }
          },
          "title": "Query Group Members Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/group/v1/group_members/{group_id}",
    "service_name": "Query"
  },
  "cosmos.group.v1/QueryGroupPoliciesByAdmin": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "admin"
        ]
      }
    ],
    "module_name": "cosmos.group.v1",
    "name": "GroupPoliciesByAdmin",
    "request_schema": {
      "$ref": "#/definitions/QueryGroupPoliciesByAdminRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryGroupPoliciesByAdminRequest": {
          "additionalProperties": false,
          "description": "QueryGroupPoliciesByAdminRequest is the Query/GroupPoliciesByAdmin request type.",
          "properties": {
            "admin": {
              "description": "admin is the admin address of the group policy.",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            }
          },
          "title": "Query Group Policies By Admin Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/group/v1/group_policies_by_admin/{admin}",
    "service_name": "Query"
  },
  "cosmos.group.v1/QueryGroupPoliciesByGroup": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "group_id"
        ]
      }
    ],
    "module_name": "cosmos.group.v1",
    "name": "GroupPoliciesByGroup",
    "request_schema": {
      "$ref": "#/definitions/QueryGroupPoliciesByGroupRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryGroupPoliciesByGroupRequest": {
          "additionalProperties": false,
          "description": "QueryGroupPoliciesByGroupRequest is the Query/GroupPoliciesByGroup request type.",
          "properties": {
            "group_id": {
              "description": "group_id is the unique ID of the group policy's group.",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            }
          },
          "title": "Query Group Policies By Group Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/group/v1/group_policies_by_group/{group_id}",
    "service_name": "Query"
  },
  "cosmos.group.v1/QueryGroupPolicyInfo": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "address"
        ]
      }
    ],
    "module_name": "cosmos.group.v1",
    "name": "GroupPolicyInfo",
    "request_schema": {
      "$ref": "#/definitions/QueryGroupPolicyInfoRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryGroupPolicyInfoRequest": {
          "additionalProperties": false,
          "description": "QueryGroupPolicyInfoRequest is the Query/GroupPolicyInfo request type.",
          "properties": {
            "address": {
              "description": "address is the account address of the group policy.",
              "type": "string"
            }
          },
          "title": "Query Group Policy Info Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/group/v1/group_policy_info/{address}",
    "service_name": "Query"
  },
  "cosmos.group.v1/QueryGroupsByAdmin": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "admin"
        ]
      }
    ],
    "module_name": "cosmos.group.v1",
    "name": "GroupsByAdmin",
    "request_schema": {
      "$ref": "#/definitions/QueryGroupsByAdminRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryGroupsByAdminRequest": {
          "additionalProperties": false,
          "description": "QueryGroupsByAdminRequest is the Query/GroupsByAdmin request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of a group's admin.",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            }
          },
          "title": "Query Groups By Admin Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/group/v1/groups_by_admin/{admin}",
    "service_name": "Query"
  },
  "cosmos.group.v1/QueryGroupsByMember": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "address"
        ]
      }
    ],
    "module_name": "cosmos.group.v1",
    "name": "GroupsByMember",
    "request_schema": {
      "$ref": "#/definitions/QueryGroupsByMemberRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryGroupsByMemberRequest": {
          "additionalProperties": false,
          "description": "QueryGroupsByMemberRequest is the Query/GroupsByMember request type.",
          "properties": {
            "address": {
              "description": "address is the group member address.",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            }
          },
          "title": "Query Groups By Member Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/group/v1/groups_by_member/{address}",
    "service_name": "Query"
  },
  "cosmos.group.v1/QueryProposal": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "proposal_id"
        ]
      }
    ],
    "module_name": "cosmos.group.v1",
    "name": "Proposal",
    "request_schema": {
      "$ref": "#/definitions/QueryProposalRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryProposalRequest": {
          "additionalProperties": false,
          "description": "QueryProposalRequest is the Query/Proposal request type.",
          "properties": {
            "proposal_id": {
              "description": "proposal_id is the unique ID of a proposal.",
              "type": "string"
            }
          },
          "title": "Query Proposal Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/group/v1/proposal/{proposal_id}",
    "service_name": "Query"
  },
  "cosmos.group.v1/QueryProposalsByGroupPolicy": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "address"
        ]
      }
    ],
    "module_name": "cosmos.group.v1",
    "name": "ProposalsByGroupPolicy",
    "request_schema": {
      "$ref": "#/definitions/QueryProposalsByGroupPolicyRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryProposalsByGroupPolicyRequest": {
          "additionalProperties": false,
          "description": "QueryProposalsByGroupPolicyRequest is the Query/ProposalByGroupPolicy request type.",
          "properties": {
            "address": {
              "description": "address is the account address of the group policy related to proposals.",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            }
          },
          "title": "Query Proposals By Group Policy Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/group/v1/proposals_by_group_policy/{address}",
    "service_name": "Query"
  },
  "cosmos.group.v1/QueryTallyResult": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "proposal_id"
        ]
      }
    ],
    "module_name": "cosmos.group.v1",
    "name": "TallyResult",
    "request_schema": {
      "$ref": "#/definitions/QueryTallyResultRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryTallyResultRequest": {
          "additionalProperties": false,
          "description": "QueryTallyResultRequest is the Query/TallyResult request type.",
          "properties": {
            "proposal_id": {
              "description": "proposal_id is the unique id of a proposal.",
              "type": "string"
            }
          },
          "title": "Query Tally Result Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/group/v1/proposals/{proposal_id}/tally",
    "service_name": "Query"
  },
  "cosmos.group.v1/QueryVoteByProposalVoter": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "proposal_id",
          "voter"
        ]
      }
    ],
    "module_name": "cosmos.group.v1",
    "name": "VoteByProposalVoter",
    "request_schema": {
      "$ref": "#/definitions/QueryVoteByProposalVoterRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryVoteByProposalVoterRequest": {
          "additionalProperties": false,
          "description": "QueryVoteByProposalVoterRequest is the Query/VoteByProposalVoter request type.",
          "properties": {
            "proposal_id": {
              "description": "proposal_id is the unique ID of a proposal.",
              "type": "string"
            },
            "voter": {
              "description": "voter is a proposal voter account address.",
              "type": "string"
            }
          },
          "title": "Query Vote By Proposal Voter Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/group/v1/vote_by_proposal_voter/{proposal_id}/{voter}",
    "service_name": "Query"
  },
  "cosmos.group.v1/QueryVotesByProposal": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "proposal_id"
        ]
      }
    ],
    "module_name": "cosmos.group.v1",
    "name": "VotesByProposal",
    "request_schema": {
      "$ref": "#/definitions/QueryVotesByProposalRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryVotesByProposalRequest": {
          "additionalProperties": false,
          "description": "QueryVotesByProposalRequest is the Query/VotesByProposal request type.",
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            },
            "proposal_id": {
              "description": "proposal_id is the unique ID of a proposal.",
              "type": "string"
            }
          },
          "title": "Query Votes By Proposal Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/group/v1/votes_by_proposal/{proposal_id}",
    "service_name": "Query"
  },
  "cosmos.group.v1/QueryVotesByVoter": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "voter"
        ]
      }
    ],
    "module_name": "cosmos.group.v1",
    "name": "VotesByVoter",
    "request_schema": {
      "$ref": "#/definitions/QueryVotesByVoterRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryVotesByVoterRequest": {
          "additionalProperties": false,
          "description": "QueryVotesByVoterRequest is the Query/VotesByVoter request type.",
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            },
            "voter": {
              "description": "voter is a proposal voter account address.",
              "type": "string"
            }
          },
          "title": "Query Votes By Voter Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/group/v1/votes_by_voter/{voter}",
    "service_name": "Query"
  },
  "cosmos.group.v1/sendMsgCreateGroup": {
    "http_rules": null,
    "module_name": "cosmos.group.v1",
    "name": "CreateGroup",
    "request_schema": {
      "$ref": "#/definitions/MsgCreateGroup",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgCreateGroup": {
          "additionalProperties": false,
          "description": "Groups  MsgCreateGroup is the Msg/CreateGroup request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "members": {
              "description": "members defines the group members.",
              "items": {
                "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
              },
              "type": "array"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata to attached to the group.",
              "type": "string"
            }
          },
          "title": "Groups",
          "type": "object"
        },
        "cosmos.group.v1.MemberRequest": {
          "additionalProperties": false,
          "description": "MemberRequest represents a group member to be used in Msg server requests. Contrary to `Member`, it doesn't have any `added_at` field since this field cannot be set as part of requests.",
          "properties": {
            "address": {
              "description": "address is the member's account address.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata attached to the member.",
              "type": "string"
            },
            "weight": {
              "description": "weight is the member's voting weight that should be greater than 0.",
              "type": "string"
            }
          },
          "title": "Member Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.group.v1/sendMsgCreateGroupPolicy": {
    "http_rules": null,
    "module_name": "cosmos.group.v1",
    "name": "CreateGroupPolicy",
    "request_schema": {
      "$ref": "#/definitions/MsgCreateGroupPolicy",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgCreateGroupPolicy": {
          "additionalProperties": false,
          "description": "Group Policies  MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "decision_policy": {
              "oneOf": [
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/PercentageDecisionPolicy"
                    },
                    "type_url": {
                      "default": "/cosmos.group.v1.PercentageDecisionPolicy",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.group.v1.PercentageDecisionPolicy"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.group.v1.PercentageDecisionPolicy",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/ThresholdDecisionPolicy"
                    },
                    "type_url": {
                      "default": "/cosmos.group.v1.ThresholdDecisionPolicy",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.group.v1.ThresholdDecisionPolicy"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.group.v1.ThresholdDecisionPolicy",
                  "type": "object"
                }
              ]
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata attached to the group policy.",
              "type": "string"
            }
          },
          "title": "Group Policies",
          "type": "object"
        },
        "PercentageDecisionPolicy": {
          "additionalProperties": false,
          "description": "PercentageDecisionPolicy is a decision policy where a proposal passes when it satisfies the two following conditions: 1. The percentage of all `YES` voters' weights out of the total group weight    is greater or equal than the given `percentage`. 2. The voting and execution periods of the proposal respect the parameters    given by `windows`.",
          "properties": {
            "percentage": {
              "description": "percentage is the minimum percentage the weighted sum of `YES` votes must meet for a proposal to succeed.",
              "type": "string"
            },
            "windows": {
              "$ref": "#/definitions/cosmos.group.v1.DecisionPolicyWindows",
              "additionalProperties": false,
              "description": "windows defines the different windows for voting and execution."
            }
          },
          "title": "Percentage Decision Policy",
          "type": "object"
        },
        "ThresholdDecisionPolicy": {
          "additionalProperties": false,
          "description": "ThresholdDecisionPolicy is a decision policy where a proposal passes when it satisfies the two following conditions: 1. The sum of all `YES` voters' weights is greater or equal than the defined    `threshold`. 2. The voting and execution periods of the proposal respect the parameters    given by `windows`.",
          "properties": {
            "threshold": {
              "description": "threshold is the minimum weighted sum of `YES` votes that must be met or exceeded for a proposal to succeed.",
              "type": "string"
            },
            "windows": {
              "$ref": "#/definitions/cosmos.group.v1.DecisionPolicyWindows",
              "additionalProperties": false,
              "description": "windows defines the different windows for voting and execution."
            }
          },
          "title": "Threshold Decision Policy",
          "type": "object"
        },
        "cosmos.group.v1.DecisionPolicyWindows": {
          "additionalProperties": false,
          "description": "DecisionPolicyWindows defines the different windows for voting and execution.",
          "properties": {
            "min_execution_period": {
              "description": "min_execution_period is the minimum duration after the proposal submission where members can start sending MsgExec. This means that the window for sending a MsgExec transaction is: `[ submission + min_execution_period ; submission + voting_period + max_execution_period]` where max_execution_period is a app-specific config, defined in the keeper. If not set, min_execution_period will default to 0. Please make sure to set a `min_execution_period` that is smaller than `voting_period + max_execution_period`, or else the above execution window is empty, meaning that all proposals created with this decision policy won't be able to be executed.",
              "format": "regex",
              "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
              "type": "string"
            },
            "voting_period": {
              "description": "voting_period is the duration from submission of a proposal to the end of voting period Within this times votes can be submitted with MsgVote.",
              "format": "regex",
              "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
              "type": "string"
            }
          },
          "title": "Decision Policy Windows",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.group.v1/sendMsgCreateGroupWithPolicy": {
    "http_rules": null,
    "module_name": "cosmos.group.v1",
    "name": "CreateGroupWithPolicy",
    "request_schema": {
      "$ref": "#/definitions/MsgCreateGroupWithPolicy",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgCreateGroupWithPolicy": {
          "additionalProperties": false,
          "description": "MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group and group policy admin.",
              "type": "string"
            },
            "decision_policy": {
              "oneOf": [
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/PercentageDecisionPolicy"
                    },
                    "type_url": {
                      "default": "/cosmos.group.v1.PercentageDecisionPolicy",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.group.v1.PercentageDecisionPolicy"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.group.v1.PercentageDecisionPolicy",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/ThresholdDecisionPolicy"
                    },
                    "type_url": {
                      "default": "/cosmos.group.v1.ThresholdDecisionPolicy",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.group.v1.ThresholdDecisionPolicy"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.group.v1.ThresholdDecisionPolicy",
                  "type": "object"
                }
              ]
            },
            "group_metadata": {
              "description": "group_metadata is any arbitrary metadata attached to the group.",
              "type": "string"
            },
            "group_policy_as_admin": {
              "description": "group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group and group policy admin.",
              "type": "boolean"
            },
            "group_policy_metadata": {
              "description": "group_policy_metadata is any arbitrary metadata attached to the group policy.",
              "type": "string"
            },
            "members": {
              "description": "members defines the group members.",
              "items": {
                "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
              },
              "type": "array"
            }
          },
          "title": "Msg Create Group With Policy",
          "type": "object"
        },
        "PercentageDecisionPolicy": {
          "additionalProperties": false,
          "description": "PercentageDecisionPolicy is a decision policy where a proposal passes when it satisfies the two following conditions: 1. The percentage of all `YES` voters' weights out of the total group weight    is greater or equal than the given `percentage`. 2. The voting and execution periods of the proposal respect the parameters    given by `windows`.",
          "properties": {
            "percentage": {
              "description": "percentage is the minimum percentage the weighted sum of `YES` votes must meet for a proposal to succeed.",
              "type": "string"
            },
            "windows": {
              "$ref": "#/definitions/cosmos.group.v1.DecisionPolicyWindows",
              "additionalProperties": false,
              "description": "windows defines the different windows for voting and execution."
            }
          },
          "title": "Percentage Decision Policy",
          "type": "object"
        },
        "ThresholdDecisionPolicy": {
          "additionalProperties": false,
          "description": "ThresholdDecisionPolicy is a decision policy where a proposal passes when it satisfies the two following conditions: 1. The sum of all `YES` voters' weights is greater or equal than the defined    `threshold`. 2. The voting and execution periods of the proposal respect the parameters    given by `windows`.",
          "properties": {
            "threshold": {
              "description": "threshold is the minimum weighted sum of `YES` votes that must be met or exceeded for a proposal to succeed.",
              "type": "string"
            },
            "windows": {
              "$ref": "#/definitions/cosmos.group.v1.DecisionPolicyWindows",
              "additionalProperties": false,
              "description": "windows defines the different windows for voting and execution."
            }
          },
          "title": "Threshold Decision Policy",
          "type": "object"
        },
        "cosmos.group.v1.DecisionPolicyWindows": {
          "additionalProperties": false,
          "description": "DecisionPolicyWindows defines the different windows for voting and execution.",
          "properties": {
            "min_execution_period": {
              "description": "min_execution_period is the minimum duration after the proposal submission where members can start sending MsgExec. This means that the window for sending a MsgExec transaction is: `[ submission + min_execution_period ; submission + voting_period + max_execution_period]` where max_execution_period is a app-specific config, defined in the keeper. If not set, min_execution_period will default to 0. Please make sure to set a `min_execution_period` that is smaller than `voting_period + max_execution_period`, or else the above execution window is empty, meaning that all proposals created with this decision policy won't be able to be executed.",
              "format": "regex",
              "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
              "type": "string"
            },
            "voting_period": {
              "description": "voting_period is the duration from submission of a proposal to the end of voting period Within this times votes can be submitted with MsgVote.",
              "format": "regex",
              "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
              "type": "string"
            }
          },
          "title": "Decision Policy Windows",
          "type": "object"
        },
        "cosmos.group.v1.MemberRequest": {
          "additionalProperties": false,
          "description": "MemberRequest represents a group member to be used in Msg server requests. Contrary to `Member`, it doesn't have any `added_at` field since this field cannot be set as part of requests.",
          "properties": {
            "address": {
              "description": "address is the member's account address.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata attached to the member.",
              "type": "string"
            },
            "weight": {
              "description": "weight is the member's voting weight that should be greater than 0.",
              "type": "string"
            }
          },
          "title": "Member Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.group.v1/sendMsgExec": {
    "http_rules": null,
    "module_name": "cosmos.group.v1",
    "name": "Exec",
    "request_schema": {
      "$ref": "#/definitions/MsgExec",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgExec": {
          "additionalProperties": false,
          "description": "MsgExec is the Msg/Exec request type.",
          "properties": {
            "executor": {
              "description": "executor is the account address used to execute the proposal.",
              "type": "string"
            },
            "proposal_id": {
              "description": "proposal is the unique ID of the proposal.",
              "type": "string"
            }
          },
          "title": "Msg Exec",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.group.v1/sendMsgLeaveGroup": {
    "http_rules": null,
    "module_name": "cosmos.group.v1",
    "name": "LeaveGroup",
    "request_schema": {
      "$ref": "#/definitions/MsgLeaveGroup",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgLeaveGroup": {
          "additionalProperties": false,
          "description": "MsgLeaveGroup is the Msg/LeaveGroup request type.",
          "properties": {
            "address": {
              "description": "address is the account address of the group member.",
              "type": "string"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            }
          },
          "title": "Msg Leave Group",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.group.v1/sendMsgSubmitProposal": {
    "http_rules": null,
    "module_name": "cosmos.group.v1",
    "name": "SubmitProposal",
    "request_schema": {
      "$ref": "#/definitions/MsgSubmitProposal",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgAccept": {
          "additionalProperties": false,
          "description": "Accept the name that was offered to you",
          "properties": {
            "name": {
              "description": "The name to accept",
              "type": "string"
            },
            "new_owner": {
              "description": "The owner address of the name",
              "type": "string"
            }
          },
          "title": "Msg Accept",
          "type": "object"
        },
        "MsgAcknowledgement": {
          "additionalProperties": false,
          "description": "MsgAcknowledgement receives incoming IBC acknowledgement",
          "properties": {
            "acknowledgement": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "packet": {
              "$ref": "#/definitions/ibc.core.channel.v1.Packet",
              "additionalProperties": false
            },
            "proof_acked": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Acknowledgement",
          "type": "object"
        },
        "MsgBeginRedelegate": {
          "additionalProperties": false,
          "description": "MsgBeginRedelegate defines a SDK message for performing a redelegation of coins from a delegator and source validator to a destination validator.",
          "properties": {
            "amount": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false
            },
            "delegator_address": {
              "type": "string"
            },
            "validator_dst_address": {
              "type": "string"
            },
            "validator_src_address": {
              "type": "string"
            }
          },
          "title": "Msg Begin Redelegate",
          "type": "object"
        },
        "MsgBurnCoins": {
          "additionalProperties": false,
          "properties": {
            "amount": {
              "description": "The amount of coins to burn, the owner must have enough coins to burn",
              "type": "string"
            },
            "owner": {
              "description": "The owner of the Dys name",
              "type": "string"
            }
          },
          "title": "Msg Burn Coins",
          "type": "object"
        },
        "MsgBurnNft": {
          "additionalProperties": false,
          "description": "Burn an NFT of the given class ID and NFT ID.",
          "properties": {
            "class_id": {
              "description": "the NFT Class ID",
              "type": "string"
            },
            "class_owner": {
              "description": "The owner of the NFT Class",
              "type": "string"
            },
            "id": {
              "description": "The ID of this NFT to burn. The owner must currently own this NFT to burn it.",
              "type": "string"
            }
          },
          "title": "Msg Burn Nft",
          "type": "object"
        },
        "MsgBuy": {
          "additionalProperties": false,
          "description": "All names have a listed price, this message allows you to buy the name at the listed price.",
          "properties": {
            "buyer": {
              "description": "The address of the buyer",
              "type": "string"
            },
            "name": {
              "description": "The name to buy",
              "type": "string"
            },
            "price": {
              "description": "Confirm the  price of the name is the same as the listed price.",
              "type": "string"
            }
          },
          "title": "Msg Buy",
          "type": "object"
        },
        "MsgCancelUnbondingDelegation": {
          "additionalProperties": false,
          "description": "MsgCancelUnbondingDelegation defines the SDK message for performing a cancel unbonding delegation for delegator Since: cosmos-sdk 0.46",
          "properties": {
            "amount": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false,
              "description": "amount is always less than or equal to unbonding delegation entry balance"
            },
            "creation_height": {
              "description": "creation_height is the height which the unbonding took place.",
              "type": "string"
            },
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Cancel Unbonding Delegation",
          "type": "object"
        },
        "MsgCancelUpgrade": {
          "additionalProperties": false,
          "description": "MsgCancelUpgrade is the Msg/CancelUpgrade request type. Since: cosmos-sdk 0.46",
          "properties": {
            "authority": {
              "description": "authority is the address of the governance account.",
              "type": "string"
            }
          },
          "title": "Msg Cancel Upgrade",
          "type": "object"
        },
        "MsgChannelCloseConfirm": {
          "additionalProperties": false,
          "description": "MsgChannelCloseConfirm defines a msg sent by a Relayer to Chain B to acknowledge the change of channel state to CLOSED on Chain A.",
          "properties": {
            "channel_id": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_init": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Close Confirm",
          "type": "object"
        },
        "MsgChannelCloseInit": {
          "additionalProperties": false,
          "description": "MsgChannelCloseInit defines a msg sent by a Relayer to Chain A to close a channel with Chain B.",
          "properties": {
            "channel_id": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Close Init",
          "type": "object"
        },
        "MsgChannelOpenAck": {
          "additionalProperties": false,
          "description": "MsgChannelOpenAck defines a msg sent by a Relayer to Chain A to acknowledge the change of channel state to TRYOPEN on Chain B.",
          "properties": {
            "channel_id": {
              "type": "string"
            },
            "counterparty_channel_id": {
              "type": "string"
            },
            "counterparty_version": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_try": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Open Ack",
          "type": "object"
        },
        "MsgChannelOpenConfirm": {
          "additionalProperties": false,
          "description": "MsgChannelOpenConfirm defines a msg sent by a Relayer to Chain B to acknowledge the change of channel state to OPEN on Chain A.",
          "properties": {
            "channel_id": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            },
            "proof_ack": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Open Confirm",
          "type": "object"
        },
        "MsgChannelOpenInit": {
          "additionalProperties": false,
          "description": "MsgChannelOpenInit defines an sdk.Msg to initialize a channel handshake. It is called by a relayer on Chain A.",
          "properties": {
            "channel": {
              "$ref": "#/definitions/ibc.core.channel.v1.Channel",
              "additionalProperties": false
            },
            "port_id": {
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Open Init",
          "type": "object"
        },
        "MsgChannelOpenTry": {
          "additionalProperties": false,
          "description": "MsgChannelOpenInit defines a msg sent by a Relayer to try to open a channel on Chain B. The version field within the Channel field has been deprecated. Its value will be ignored by core IBC.",
          "properties": {
            "channel": {
              "$ref": "#/definitions/ibc.core.channel.v1.Channel",
              "additionalProperties": false,
              "description": "NOTE: the version field within the channel has been deprecated. Its value will be ignored by core IBC."
            },
            "counterparty_version": {
              "type": "string"
            },
            "port_id": {
              "type": "string"
            },
            "previous_channel_id": {
              "description": "Deprecated: this field is unused. Crossing hello's are no longer supported in core IBC.",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_init": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Channel Open Try",
          "type": "object"
        },
        "MsgConnectionOpenAck": {
          "additionalProperties": false,
          "description": "MsgConnectionOpenAck defines a msg sent by a Relayer to Chain A to acknowledge the change of connection state to TRYOPEN on Chain B.",
          "properties": {
            "client_state": {
              "additionalProperties": false,
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "connection_id": {
              "type": "string"
            },
            "consensus_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "counterparty_connection_id": {
              "type": "string"
            },
            "proof_client": {
              "binaryEncoding": "base64",
              "description": "proof of client state included in message",
              "format": "binary",
              "type": "string"
            },
            "proof_consensus": {
              "binaryEncoding": "base64",
              "description": "proof of client consensus state",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_try": {
              "binaryEncoding": "base64",
              "description": "proof of the initialization the connection on Chain B: `UNITIALIZED -> TRYOPEN`",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            },
            "version": {
              "$ref": "#/definitions/ibc.core.connection.v1.Version",
              "additionalProperties": false
            }
          },
          "title": "Msg Connection Open Ack",
          "type": "object"
        },
        "MsgConnectionOpenConfirm": {
          "additionalProperties": false,
          "description": "MsgConnectionOpenConfirm defines a msg sent by a Relayer to Chain B to acknowledge the change of connection state to OPEN on Chain A.",
          "properties": {
            "connection_id": {
              "type": "string"
            },
            "proof_ack": {
              "binaryEncoding": "base64",
              "description": "proof for the change of the connection state on Chain A: `INIT -> OPEN`",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Connection Open Confirm",
          "type": "object"
        },
        "MsgConnectionOpenInit": {
          "additionalProperties": false,
          "description": "MsgConnectionOpenInit defines the msg sent by an account on Chain A to initialize a connection with Chain B.",
          "properties": {
            "client_id": {
              "type": "string"
            },
            "counterparty": {
              "$ref": "#/definitions/ibc.core.connection.v1.Counterparty",
              "additionalProperties": false
            },
            "delay_period": {
              "type": "string"
            },
            "signer": {
              "type": "string"
            },
            "version": {
              "$ref": "#/definitions/ibc.core.connection.v1.Version",
              "additionalProperties": false
            }
          },
          "title": "Msg Connection Open Init",
          "type": "object"
        },
        "MsgConnectionOpenTry": {
          "additionalProperties": false,
          "description": "MsgConnectionOpenTry defines a msg sent by a Relayer to try to open a connection on Chain B.",
          "properties": {
            "client_id": {
              "type": "string"
            },
            "client_state": {
              "additionalProperties": false,
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "consensus_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "counterparty": {
              "$ref": "#/definitions/ibc.core.connection.v1.Counterparty",
              "additionalProperties": false
            },
            "counterparty_versions": {
              "items": {
                "$ref": "#/definitions/ibc.core.connection.v1.Version"
              },
              "type": "array"
            },
            "delay_period": {
              "type": "string"
            },
            "previous_connection_id": {
              "description": "Deprecated: this field is unused. Crossing hellos are no longer supported in core IBC.",
              "type": "string"
            },
            "proof_client": {
              "binaryEncoding": "base64",
              "description": "proof of client state included in message",
              "format": "binary",
              "type": "string"
            },
            "proof_consensus": {
              "binaryEncoding": "base64",
              "description": "proof of client consensus state",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_init": {
              "binaryEncoding": "base64",
              "description": "proof of the initialization the connection on Chain A: `UNITIALIZED -> INIT`",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Connection Open Try",
          "type": "object"
        },
        "MsgCreateClient": {
          "additionalProperties": false,
          "description": "MsgCreateClient defines a message to create an IBC client",
          "properties": {
            "client_state": {
              "additionalProperties": false,
              "description": "light client state",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "consensus_state": {
              "additionalProperties": false,
              "description": "consensus state associated with the client that corresponds to a given height.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "signer": {
              "description": "signer address",
              "type": "string"
            }
          },
          "title": "Msg Create Client",
          "type": "object"
        },
        "MsgCreateGroup": {
          "additionalProperties": false,
          "description": "Groups  MsgCreateGroup is the Msg/CreateGroup request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "members": {
              "description": "members defines the group members.",
              "items": {
                "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
              },
              "type": "array"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata to attached to the group.",
              "type": "string"
            }
          },
          "title": "Groups",
          "type": "object"
        },
        "MsgCreateGroupPolicy": {
          "additionalProperties": false,
          "description": "Group Policies  MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "decision_policy": {
              "additionalProperties": false,
              "description": "decision_policy specifies the group policy's decision policy.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata attached to the group policy.",
              "type": "string"
            }
          },
          "title": "Group Policies",
          "type": "object"
        },
        "MsgCreateGroupWithPolicy": {
          "additionalProperties": false,
          "description": "MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group and group policy admin.",
              "type": "string"
            },
            "decision_policy": {
              "additionalProperties": false,
              "description": "decision_policy specifies the group policy's decision policy.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "group_metadata": {
              "description": "group_metadata is any arbitrary metadata attached to the group.",
              "type": "string"
            },
            "group_policy_as_admin": {
              "description": "group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group and group policy admin.",
              "type": "boolean"
            },
            "group_policy_metadata": {
              "description": "group_policy_metadata is any arbitrary metadata attached to the group policy.",
              "type": "string"
            },
            "members": {
              "description": "members defines the group members.",
              "items": {
                "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
              },
              "type": "array"
            }
          },
          "title": "Msg Create Group With Policy",
          "type": "object"
        },
        "MsgCreatePeriodicVestingAccount": {
          "additionalProperties": false,
          "description": "MsgCreateVestingAccount defines a message that enables creating a vesting account. Since: cosmos-sdk 0.46",
          "properties": {
            "from_address": {
              "type": "string"
            },
            "start_time": {
              "type": "string"
            },
            "to_address": {
              "type": "string"
            },
            "vesting_periods": {
              "items": {
                "$ref": "#/definitions/cosmos.vesting.v1beta1.Period"
              },
              "type": "array"
            }
          },
          "title": "Msg Create Periodic Vesting Account",
          "type": "object"
        },
        "MsgCreatePermanentLockedAccount": {
          "additionalProperties": false,
          "description": "MsgCreatePermanentLockedAccount defines a message that enables creating a permanent locked account. Since: cosmos-sdk 0.46",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "from_address": {
              "type": "string"
            },
            "to_address": {
              "type": "string"
            }
          },
          "title": "Msg Create Permanent Locked Account",
          "type": "object"
        },
        "MsgCreateScheduledRun": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            },
            "gas": {
              "type": "string"
            },
            "height": {
              "type": "string"
            },
            "msg": {
              "$ref": "#/definitions/dyson.MsgRun",
              "additionalProperties": false
            }
          },
          "title": "Msg Create Scheduled Run",
          "type": "object"
        },
        "MsgCreateStorage": {
          "additionalProperties": false,
          "description": "Create a new storage of arbitrary text",
          "properties": {
            "creator": {
              "description": "The address signing this transaction",
              "type": "string"
            },
            "data": {
              "description": "data to store at this index",
              "type": "string"
            },
            "force": {
              "description": "If true, force will always store the data at this address regardless of already existing storage",
              "type": "boolean"
            },
            "index": {
              "description": "Name of the Storage, must be prefixed with the creators address (for example: \"dys..1a3/some_name\")",
              "type": "string"
            }
          },
          "title": "Msg Create Storage",
          "type": "object"
        },
        "MsgCreateValidator": {
          "additionalProperties": false,
          "description": "MsgCreateValidator defines a SDK message for creating a new validator.",
          "properties": {
            "commission": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.CommissionRates",
              "additionalProperties": false
            },
            "delegator_address": {
              "type": "string"
            },
            "description": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.Description",
              "additionalProperties": false
            },
            "min_self_delegation": {
              "type": "string"
            },
            "pubkey": {
              "additionalProperties": false,
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "validator_address": {
              "type": "string"
            },
            "value": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false
            }
          },
          "title": "Msg Create Validator",
          "type": "object"
        },
        "MsgCreateVestingAccount": {
          "additionalProperties": false,
          "description": "MsgCreateVestingAccount defines a message that enables creating a vesting account.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "delayed": {
              "type": "boolean"
            },
            "end_time": {
              "type": "string"
            },
            "from_address": {
              "type": "string"
            },
            "to_address": {
              "type": "string"
            }
          },
          "title": "Msg Create Vesting Account",
          "type": "object"
        },
        "MsgDelegate": {
          "additionalProperties": false,
          "description": "MsgDelegate defines a SDK message for performing a delegation of coins from a delegator to a validator.",
          "properties": {
            "amount": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false
            },
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Delegate",
          "type": "object"
        },
        "MsgDeleteName": {
          "additionalProperties": false,
          "description": "Delete the Dyson Protocol name",
          "properties": {
            "name": {
              "description": "The name to delete",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            }
          },
          "title": "Msg Delete Name",
          "type": "object"
        },
        "MsgDeleteScheduledRun": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            },
            "index": {
              "type": "string"
            }
          },
          "title": "Msg Delete Scheduled Run",
          "type": "object"
        },
        "MsgDeleteScript": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            }
          },
          "title": "Msg Delete Script",
          "type": "object"
        },
        "MsgDeleteStorage": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            },
            "index": {
              "type": "string"
            }
          },
          "title": "Msg Delete Storage",
          "type": "object"
        },
        "MsgDeployAutonomousScript": {
          "additionalProperties": false,
          "description": "Deploy an Autonomous Script at a new address",
          "properties": {
            "code": {
              "format": "python",
              "type": "string"
            },
            "creator": {
              "type": "string"
            }
          },
          "title": "Msg Deploy Autonomous Script",
          "type": "object"
        },
        "MsgDeposit": {
          "additionalProperties": false,
          "description": "MsgDeposit defines a message to submit a deposit to an existing proposal.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "depositor": {
              "type": "string"
            },
            "proposal_id": {
              "type": "string"
            }
          },
          "title": "Msg Deposit",
          "type": "object"
        },
        "MsgEditValidator": {
          "additionalProperties": false,
          "description": "MsgEditValidator defines a SDK message for editing an existing validator.",
          "properties": {
            "commission_rate": {
              "description": "We pass a reference to the new commission rate and min self delegation as it's not mandatory to update. If not updated, the deserialized rate will be zero with no way to distinguish if an update was intended. REF: #2373",
              "type": "string"
            },
            "description": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.Description",
              "additionalProperties": false
            },
            "min_self_delegation": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Edit Validator",
          "type": "object"
        },
        "MsgExec": {
          "additionalProperties": false,
          "description": "MsgExec is the Msg/Exec request type.",
          "properties": {
            "executor": {
              "description": "executor is the account address used to execute the proposal.",
              "type": "string"
            },
            "proposal_id": {
              "description": "proposal is the unique ID of the proposal.",
              "type": "string"
            }
          },
          "title": "Msg Exec",
          "type": "object"
        },
        "MsgExecLegacyContent": {
          "additionalProperties": false,
          "description": "MsgExecLegacyContent is used to wrap the legacy content field into a message. This ensures backwards compatibility with v1beta1.MsgSubmitProposal.",
          "properties": {
            "authority": {
              "description": "authority must be the gov module address.",
              "type": "string"
            },
            "content": {
              "additionalProperties": false,
              "description": "content is the proposal's content.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "title": "Msg Exec Legacy Content",
          "type": "object"
        },
        "MsgFundCommunityPool": {
          "additionalProperties": false,
          "description": "MsgFundCommunityPool allows an account to directly fund the community pool.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "depositor": {
              "type": "string"
            }
          },
          "title": "Msg Fund Community Pool",
          "type": "object"
        },
        "MsgGrant": {
          "additionalProperties": false,
          "description": "MsgGrant is a request type for Grant method. It declares authorization to the grantee on behalf of the granter with the provided expiration time.",
          "properties": {
            "grant": {
              "$ref": "#/definitions/cosmos.authz.v1beta1.Grant",
              "additionalProperties": false
            },
            "grantee": {
              "type": "string"
            },
            "granter": {
              "type": "string"
            }
          },
          "title": "Msg Grant",
          "type": "object"
        },
        "MsgGrantAllowance": {
          "additionalProperties": false,
          "description": "MsgGrantAllowance adds permission for Grantee to spend up to Allowance of fees from the account of Granter.",
          "properties": {
            "allowance": {
              "additionalProperties": false,
              "description": "allowance can be any of basic, periodic, allowed fee allowance.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "grantee": {
              "description": "grantee is the address of the user being granted an allowance of another user's funds.",
              "type": "string"
            },
            "granter": {
              "description": "granter is the address of the user granting an allowance of their funds.",
              "type": "string"
            }
          },
          "title": "Msg Grant Allowance",
          "type": "object"
        },
        "MsgLeaveGroup": {
          "additionalProperties": false,
          "description": "MsgLeaveGroup is the Msg/LeaveGroup request type.",
          "properties": {
            "address": {
              "description": "address is the account address of the group member.",
              "type": "string"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            }
          },
          "title": "Msg Leave Group",
          "type": "object"
        },
        "MsgMintCoins": {
          "additionalProperties": false,
          "description": "Mint coins with a denom of a name or subname. For example if you own the name \"example.dys\" you can mint coins with the denom \"example.dys\" or \"subname.example.dys\"",
          "properties": {
            "amount": {
              "description": "The amount of coins to mint in the format \"[amount] [denom]\".   Each coin costs 1 gas.",
              "type": "string"
            },
            "owner": {
              "description": "The owner of the Dys name",
              "type": "string"
            }
          },
          "title": "Msg Mint Coins",
          "type": "object"
        },
        "MsgMintNft": {
          "additionalProperties": false,
          "description": "Mint an NFT with the given class ID and NFT ID. The NFT ID is unique to the class ID.",
          "properties": {
            "class_id": {
              "description": "the NFT Class ID",
              "type": "string"
            },
            "class_owner": {
              "description": "The owner of the Dys name",
              "type": "string"
            },
            "id": {
              "description": "The ID of this NFT, must be unique to the class ID",
              "type": "string"
            },
            "uri": {
              "description": "The URI of the NFT (optional)",
              "type": "string"
            },
            "uri_hash": {
              "description": "The URI hash of the NFT (optional)",
              "type": "string"
            }
          },
          "title": "Msg Mint Nft",
          "type": "object"
        },
        "MsgMultiSend": {
          "additionalProperties": false,
          "description": "MsgMultiSend represents an arbitrary multi-in, multi-out send message.",
          "properties": {
            "inputs": {
              "items": {
                "$ref": "#/definitions/cosmos.bank.v1beta1.Input"
              },
              "type": "array"
            },
            "outputs": {
              "items": {
                "$ref": "#/definitions/cosmos.bank.v1beta1.Output"
              },
              "type": "array"
            }
          },
          "title": "Msg Multi Send",
          "type": "object"
        },
        "MsgOfferTo": {
          "additionalProperties": false,
          "description": "Offer the name to a new owner",
          "properties": {
            "name": {
              "description": "The name to offer",
              "type": "string"
            },
            "new_owner": {
              "description": "The address to offer the name to. They can take ownership of the name with the Accept message",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            }
          },
          "title": "Msg Offer To",
          "type": "object"
        },
        "MsgRecvPacket": {
          "additionalProperties": false,
          "description": "MsgRecvPacket receives incoming IBC packet",
          "properties": {
            "packet": {
              "$ref": "#/definitions/ibc.core.channel.v1.Packet",
              "additionalProperties": false
            },
            "proof_commitment": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Recv Packet",
          "type": "object"
        },
        "MsgRegister": {
          "additionalProperties": false,
          "properties": {
            "auto_renew": {
              "description": "Should the name be automatically renewed",
              "type": "boolean"
            },
            "commit": {
              "description": "The Shake256(owner+name+salt) hexdigest",
              "type": "string"
            },
            "owner": {
              "description": "Address of the owner",
              "type": "string"
            },
            "price": {
              "description": "The price that this name is valued at and can be purchased for example 100dys. The yearly fee (31,536,000 blocks) is 1% of this price.",
              "type": "string"
            }
          },
          "title": "Msg Register",
          "type": "object"
        },
        "MsgRegisterInterchainAccount": {
          "additionalProperties": false,
          "description": "MsgRegisterInterchainAccount defines the payload for Msg/MsgRegisterInterchainAccount",
          "properties": {
            "connection_id": {
              "type": "string"
            },
            "owner": {
              "type": "string"
            },
            "version": {
              "type": "string"
            }
          },
          "title": "Msg Register Interchain Account",
          "type": "object"
        },
        "MsgReveal": {
          "additionalProperties": false,
          "description": "Reveal the name that was committed to with the Register message",
          "properties": {
            "name": {
              "description": "The name to reveal",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            },
            "salt": {
              "description": "The salt that was used to commit to the name",
              "type": "string"
            }
          },
          "title": "Msg Reveal",
          "type": "object"
        },
        "MsgRevoke": {
          "additionalProperties": false,
          "description": "MsgRevoke revokes any authorization with the provided sdk.Msg type on the granter's account with that has been granted to the grantee.",
          "properties": {
            "grantee": {
              "type": "string"
            },
            "granter": {
              "type": "string"
            },
            "msg_type_url": {
              "type": "string"
            }
          },
          "title": "Msg Revoke",
          "type": "object"
        },
        "MsgRevokeAllowance": {
          "additionalProperties": false,
          "description": "MsgRevokeAllowance removes any existing Allowance from Granter to Grantee.",
          "properties": {
            "grantee": {
              "description": "grantee is the address of the user being granted an allowance of another user's funds.",
              "type": "string"
            },
            "granter": {
              "description": "granter is the address of the user granting an allowance of their funds.",
              "type": "string"
            }
          },
          "title": "Msg Revoke Allowance",
          "type": "object"
        },
        "MsgRun": {
          "additionalProperties": false,
          "description": "MsgRun runs a script at a specific address",
          "properties": {
            "address": {
              "description": "Dys address of the script to call",
              "type": "string"
            },
            "args": {
              "description": "Optional args to call the function with",
              "type": "string"
            },
            "coins": {
              "description": "Optional comma seperated list of coins to send the script (for example \"123dys,456token\") this entire amount will be sent to the script",
              "type": "string"
            },
            "creator": {
              "description": "The account sending this transaction",
              "type": "string"
            },
            "extra_lines": {
              "description": "Optional extra source code to append to the end of the script before running. Only available to the script address itself.",
              "type": "string"
            },
            "function_name": {
              "description": "Optional function to call",
              "type": "string"
            },
            "kwargs": {
              "description": "Optional kwargs to run",
              "type": "string"
            },
            "nfts": {
              "description": "Optional NFTs to send the script, formatted [class_id]/[id], [class_id]/[id] (for example \"example.dys/123, example.dys/456\")",
              "type": "string"
            }
          },
          "title": "Msg Run",
          "type": "object"
        },
        "MsgSend": {
          "additionalProperties": false,
          "description": "MsgSend represents a message to send a nft from one account to another account.",
          "properties": {
            "class_id": {
              "description": "class_id defines the unique identifier of the nft classification, similar to the contract address of ERC721",
              "type": "string"
            },
            "id": {
              "description": "id defines the unique identification of nft",
              "type": "string"
            },
            "receiver": {
              "description": "receiver is the receiver address of nft",
              "type": "string"
            },
            "sender": {
              "description": "sender is the address of the owner of nft",
              "type": "string"
            }
          },
          "title": "Msg Send",
          "type": "object"
        },
        "MsgSendTx": {
          "additionalProperties": false,
          "description": "MsgSendTx defines the payload for Msg/SendTx",
          "properties": {
            "connection_id": {
              "type": "string"
            },
            "owner": {
              "type": "string"
            },
            "packet_data": {
              "$ref": "#/definitions/ibc.applications.interchain_accounts.v1.InterchainAccountPacketData",
              "additionalProperties": false
            },
            "relative_timeout": {
              "description": "Relative timeout timestamp provided will be added to the current block time during transaction execution. The timeout timestamp must be non-zero.",
              "type": "string"
            }
          },
          "title": "Msg Send Tx",
          "type": "object"
        },
        "MsgSetNftClass": {
          "additionalProperties": false,
          "description": "Create or update an NFT class. The NFT class is identified by the Dys name of the class ID.",
          "properties": {
            "description": {
              "description": "The  description of the NFT class (optional)",
              "type": "string"
            },
            "id": {
              "description": "the ID is the Dys name or subname of the NFT class. For example if you own the name \"example.dys\" you can create an NFT class with the ID \"example.dys\" or \"subname.example.dys\"",
              "type": "string"
            },
            "name": {
              "description": "More descriptive name of the NFT class (optional)",
              "type": "string"
            },
            "owner": {
              "description": "The owner of the Dys name of the NFT class ID",
              "type": "string"
            },
            "symbol": {
              "description": "The symbol of the NFT class (optional)",
              "type": "string"
            },
            "uri": {
              "description": "The URI of the NFT class (optional)",
              "type": "string"
            },
            "uri_hash": {
              "description": "The URI hash of the NFT class (optional)",
              "type": "string"
            }
          },
          "title": "Msg Set Nft Class",
          "type": "object"
        },
        "MsgSetPriceAndExtend": {
          "additionalProperties": false,
          "description": "Set the price of the name and extend the expiration height",
          "properties": {
            "name": {
              "description": "The name to set the price for",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            },
            "price": {
              "description": "The new price that this name is valued at and can be purchased for example 100dys. The fee is 1% of this price and will be paid by the owner now. The expiration height is extended by 31,536,000 blocks.",
              "type": "string"
            }
          },
          "title": "Msg Set Price And Extend",
          "type": "object"
        },
        "MsgSetWithdrawAddress": {
          "additionalProperties": false,
          "description": "MsgSetWithdrawAddress sets the withdraw address for a delegator (or validator self-delegation).",
          "properties": {
            "delegator_address": {
              "type": "string"
            },
            "withdraw_address": {
              "type": "string"
            }
          },
          "title": "Msg Set Withdraw Address",
          "type": "object"
        },
        "MsgSoftwareUpgrade": {
          "additionalProperties": false,
          "description": "MsgSoftwareUpgrade is the Msg/SoftwareUpgrade request type. Since: cosmos-sdk 0.46",
          "properties": {
            "authority": {
              "description": "authority is the address of the governance account.",
              "type": "string"
            },
            "plan": {
              "$ref": "#/definitions/cosmos.upgrade.v1beta1.Plan",
              "additionalProperties": false,
              "description": "plan is the upgrade plan."
            }
          },
          "title": "Msg Software Upgrade",
          "type": "object"
        },
        "MsgSubmitEvidence": {
          "additionalProperties": false,
          "description": "MsgSubmitEvidence represents a message that supports submitting arbitrary Evidence of misbehavior such as equivocation or counterfactual signing.",
          "properties": {
            "evidence": {
              "additionalProperties": false,
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "submitter": {
              "type": "string"
            }
          },
          "title": "Msg Submit Evidence",
          "type": "object"
        },
        "MsgSubmitMisbehaviour": {
          "additionalProperties": false,
          "description": "MsgSubmitMisbehaviour defines an sdk.Msg type that submits Evidence for light client misbehaviour.",
          "properties": {
            "client_id": {
              "description": "client unique identifier",
              "type": "string"
            },
            "misbehaviour": {
              "additionalProperties": false,
              "description": "misbehaviour used for freezing the light client",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "signer": {
              "description": "signer address",
              "type": "string"
            }
          },
          "title": "Msg Submit Misbehaviour",
          "type": "object"
        },
        "MsgSubmitProposal": {
          "additionalProperties": false,
          "description": "MsgSubmitProposal is the Msg/SubmitProposal request type.",
          "properties": {
            "exec": {
              "description": "Proposals and Voting  Exec defines modes of execution of a proposal on creation or on new vote.",
              "enum": [
                "EXEC_UNSPECIFIED",
                0,
                "EXEC_TRY",
                1
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Proposals and Voting"
            },
            "group_policy_address": {
              "description": "group_policy_address is the account address of group policy.",
              "type": "string"
            },
            "messages": {
              "description": "messages is a list of `sdk.Msg`s that will be executed if the proposal passes.",
              "items": {
                "oneOf": [
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgExec"
                      },
                      "type_url": {
                        "default": "/cosmos.authz.v1beta1.MsgExec",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.authz.v1beta1.MsgExec"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.authz.v1beta1.MsgExec",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgGrant"
                      },
                      "type_url": {
                        "default": "/cosmos.authz.v1beta1.MsgGrant",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.authz.v1beta1.MsgGrant"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.authz.v1beta1.MsgGrant",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgRevoke"
                      },
                      "type_url": {
                        "default": "/cosmos.authz.v1beta1.MsgRevoke",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.authz.v1beta1.MsgRevoke"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.authz.v1beta1.MsgRevoke",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgMultiSend"
                      },
                      "type_url": {
                        "default": "/cosmos.bank.v1beta1.MsgMultiSend",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.bank.v1beta1.MsgMultiSend"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.bank.v1beta1.MsgMultiSend",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSend"
                      },
                      "type_url": {
                        "default": "/cosmos.bank.v1beta1.MsgSend",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.bank.v1beta1.MsgSend"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.bank.v1beta1.MsgSend",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgVerifyInvariant"
                      },
                      "type_url": {
                        "default": "/cosmos.crisis.v1beta1.MsgVerifyInvariant",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.crisis.v1beta1.MsgVerifyInvariant"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.crisis.v1beta1.MsgVerifyInvariant",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgFundCommunityPool"
                      },
                      "type_url": {
                        "default": "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.distribution.v1beta1.MsgFundCommunityPool"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.distribution.v1beta1.MsgFundCommunityPool",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSetWithdrawAddress"
                      },
                      "type_url": {
                        "default": "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgWithdrawDelegatorReward"
                      },
                      "type_url": {
                        "default": "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgWithdrawValidatorCommission"
                      },
                      "type_url": {
                        "default": "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSubmitEvidence"
                      },
                      "type_url": {
                        "default": "/cosmos.evidence.v1beta1.MsgSubmitEvidence",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.evidence.v1beta1.MsgSubmitEvidence"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.evidence.v1beta1.MsgSubmitEvidence",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgGrantAllowance"
                      },
                      "type_url": {
                        "default": "/cosmos.feegrant.v1beta1.MsgGrantAllowance",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.feegrant.v1beta1.MsgGrantAllowance"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.feegrant.v1beta1.MsgGrantAllowance",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgRevokeAllowance"
                      },
                      "type_url": {
                        "default": "/cosmos.feegrant.v1beta1.MsgRevokeAllowance",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.feegrant.v1beta1.MsgRevokeAllowance"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.feegrant.v1beta1.MsgRevokeAllowance",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeposit"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1.MsgDeposit",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1.MsgDeposit"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1.MsgDeposit",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgExecLegacyContent"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1.MsgExecLegacyContent",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1.MsgExecLegacyContent"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1.MsgExecLegacyContent",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSubmitProposal"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1.MsgSubmitProposal",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1.MsgSubmitProposal"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1.MsgSubmitProposal",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgVote"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1.MsgVote",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1.MsgVote"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1.MsgVote",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgVoteWeighted"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1.MsgVoteWeighted",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1.MsgVoteWeighted"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1.MsgVoteWeighted",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeposit"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1beta1.MsgDeposit",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1beta1.MsgDeposit"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1beta1.MsgDeposit",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSubmitProposal"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1beta1.MsgSubmitProposal",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1beta1.MsgSubmitProposal"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1beta1.MsgSubmitProposal",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgVote"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1beta1.MsgVote",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1beta1.MsgVote"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1beta1.MsgVote",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgVoteWeighted"
                      },
                      "type_url": {
                        "default": "/cosmos.gov.v1beta1.MsgVoteWeighted",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.gov.v1beta1.MsgVoteWeighted"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.gov.v1beta1.MsgVoteWeighted",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateGroup"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgCreateGroup",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgCreateGroup"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgCreateGroup",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateGroupPolicy"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgCreateGroupPolicy",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgCreateGroupPolicy"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgCreateGroupPolicy",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateGroupWithPolicy"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgCreateGroupWithPolicy",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgCreateGroupWithPolicy"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgCreateGroupWithPolicy",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgExec"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgExec",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgExec"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgExec",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgLeaveGroup"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgLeaveGroup",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgLeaveGroup"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgLeaveGroup",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSubmitProposal"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgSubmitProposal",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgSubmitProposal"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgSubmitProposal",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateGroupAdmin"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgUpdateGroupAdmin",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgUpdateGroupAdmin"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgUpdateGroupAdmin",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateGroupMembers"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgUpdateGroupMembers",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgUpdateGroupMembers"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgUpdateGroupMembers",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateGroupMetadata"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgUpdateGroupMetadata",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgUpdateGroupMetadata"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgUpdateGroupMetadata",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateGroupPolicyAdmin"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateGroupPolicyDecisionPolicy"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateGroupPolicyMetadata"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgVote"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgVote",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgVote"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgVote",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgWithdrawProposal"
                      },
                      "type_url": {
                        "default": "/cosmos.group.v1.MsgWithdrawProposal",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.group.v1.MsgWithdrawProposal"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.group.v1.MsgWithdrawProposal",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSend"
                      },
                      "type_url": {
                        "default": "/cosmos.nft.v1beta1.MsgSend",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.nft.v1beta1.MsgSend"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.nft.v1beta1.MsgSend",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUnjail"
                      },
                      "type_url": {
                        "default": "/cosmos.slashing.v1beta1.MsgUnjail",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.slashing.v1beta1.MsgUnjail"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.slashing.v1beta1.MsgUnjail",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgBeginRedelegate"
                      },
                      "type_url": {
                        "default": "/cosmos.staking.v1beta1.MsgBeginRedelegate",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.staking.v1beta1.MsgBeginRedelegate"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.staking.v1beta1.MsgBeginRedelegate",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCancelUnbondingDelegation"
                      },
                      "type_url": {
                        "default": "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateValidator"
                      },
                      "type_url": {
                        "default": "/cosmos.staking.v1beta1.MsgCreateValidator",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.staking.v1beta1.MsgCreateValidator"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.staking.v1beta1.MsgCreateValidator",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDelegate"
                      },
                      "type_url": {
                        "default": "/cosmos.staking.v1beta1.MsgDelegate",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.staking.v1beta1.MsgDelegate"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.staking.v1beta1.MsgDelegate",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgEditValidator"
                      },
                      "type_url": {
                        "default": "/cosmos.staking.v1beta1.MsgEditValidator",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.staking.v1beta1.MsgEditValidator"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.staking.v1beta1.MsgEditValidator",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUndelegate"
                      },
                      "type_url": {
                        "default": "/cosmos.staking.v1beta1.MsgUndelegate",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.staking.v1beta1.MsgUndelegate"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.staking.v1beta1.MsgUndelegate",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCancelUpgrade"
                      },
                      "type_url": {
                        "default": "/cosmos.upgrade.v1beta1.MsgCancelUpgrade",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.upgrade.v1beta1.MsgCancelUpgrade"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.upgrade.v1beta1.MsgCancelUpgrade",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSoftwareUpgrade"
                      },
                      "type_url": {
                        "default": "/cosmos.upgrade.v1beta1.MsgSoftwareUpgrade",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.upgrade.v1beta1.MsgSoftwareUpgrade"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.upgrade.v1beta1.MsgSoftwareUpgrade",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreatePeriodicVestingAccount"
                      },
                      "type_url": {
                        "default": "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreatePermanentLockedAccount"
                      },
                      "type_url": {
                        "default": "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateVestingAccount"
                      },
                      "type_url": {
                        "default": "/cosmos.vesting.v1beta1.MsgCreateVestingAccount",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/cosmos.vesting.v1beta1.MsgCreateVestingAccount"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "cosmos.vesting.v1beta1.MsgCreateVestingAccount",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateScheduledRun"
                      },
                      "type_url": {
                        "default": "/dyson.MsgCreateScheduledRun",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgCreateScheduledRun"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgCreateScheduledRun",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateStorage"
                      },
                      "type_url": {
                        "default": "/dyson.MsgCreateStorage",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgCreateStorage"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgCreateStorage",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeleteScheduledRun"
                      },
                      "type_url": {
                        "default": "/dyson.MsgDeleteScheduledRun",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgDeleteScheduledRun"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgDeleteScheduledRun",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeleteScript"
                      },
                      "type_url": {
                        "default": "/dyson.MsgDeleteScript",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgDeleteScript"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgDeleteScript",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeleteStorage"
                      },
                      "type_url": {
                        "default": "/dyson.MsgDeleteStorage",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgDeleteStorage"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgDeleteStorage",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeployAutonomousScript"
                      },
                      "type_url": {
                        "default": "/dyson.MsgDeployAutonomousScript",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgDeployAutonomousScript"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgDeployAutonomousScript",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgRun"
                      },
                      "type_url": {
                        "default": "/dyson.MsgRun",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgRun"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgRun",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateScheduledRun"
                      },
                      "type_url": {
                        "default": "/dyson.MsgUpdateScheduledRun",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgUpdateScheduledRun"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgUpdateScheduledRun",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateScript"
                      },
                      "type_url": {
                        "default": "/dyson.MsgUpdateScript",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgUpdateScript"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgUpdateScript",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateStorage"
                      },
                      "type_url": {
                        "default": "/dyson.MsgUpdateStorage",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/dyson.MsgUpdateStorage"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "dyson.MsgUpdateStorage",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgRegisterInterchainAccount"
                      },
                      "type_url": {
                        "default": "/ibc.applications.interchain_accounts.controller.v1.MsgRegisterInterchainAccount",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.applications.interchain_accounts.controller.v1.MsgRegisterInterchainAccount"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.applications.interchain_accounts.controller.v1.MsgRegisterInterchainAccount",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSendTx"
                      },
                      "type_url": {
                        "default": "/ibc.applications.interchain_accounts.controller.v1.MsgSendTx",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.applications.interchain_accounts.controller.v1.MsgSendTx"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.applications.interchain_accounts.controller.v1.MsgSendTx",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgTransfer"
                      },
                      "type_url": {
                        "default": "/ibc.applications.transfer.v1.MsgTransfer",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.applications.transfer.v1.MsgTransfer"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.applications.transfer.v1.MsgTransfer",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgAcknowledgement"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgAcknowledgement",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgAcknowledgement"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgAcknowledgement",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgChannelCloseConfirm"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgChannelCloseConfirm",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgChannelCloseConfirm"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgChannelCloseConfirm",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgChannelCloseInit"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgChannelCloseInit",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgChannelCloseInit"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgChannelCloseInit",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgChannelOpenAck"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgChannelOpenAck",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgChannelOpenAck"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgChannelOpenAck",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgChannelOpenConfirm"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgChannelOpenConfirm",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgChannelOpenConfirm"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgChannelOpenConfirm",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgChannelOpenInit"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgChannelOpenInit",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgChannelOpenInit"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgChannelOpenInit",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgChannelOpenTry"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgChannelOpenTry",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgChannelOpenTry"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgChannelOpenTry",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgRecvPacket"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgRecvPacket",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgRecvPacket"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgRecvPacket",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgTimeout"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgTimeout",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgTimeout"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgTimeout",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgTimeoutOnClose"
                      },
                      "type_url": {
                        "default": "/ibc.core.channel.v1.MsgTimeoutOnClose",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.channel.v1.MsgTimeoutOnClose"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.channel.v1.MsgTimeoutOnClose",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgCreateClient"
                      },
                      "type_url": {
                        "default": "/ibc.core.client.v1.MsgCreateClient",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.client.v1.MsgCreateClient"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.client.v1.MsgCreateClient",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSubmitMisbehaviour"
                      },
                      "type_url": {
                        "default": "/ibc.core.client.v1.MsgSubmitMisbehaviour",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.client.v1.MsgSubmitMisbehaviour"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.client.v1.MsgSubmitMisbehaviour",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateClient"
                      },
                      "type_url": {
                        "default": "/ibc.core.client.v1.MsgUpdateClient",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.client.v1.MsgUpdateClient"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.client.v1.MsgUpdateClient",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpgradeClient"
                      },
                      "type_url": {
                        "default": "/ibc.core.client.v1.MsgUpgradeClient",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.client.v1.MsgUpgradeClient"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.client.v1.MsgUpgradeClient",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgConnectionOpenAck"
                      },
                      "type_url": {
                        "default": "/ibc.core.connection.v1.MsgConnectionOpenAck",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.connection.v1.MsgConnectionOpenAck"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.connection.v1.MsgConnectionOpenAck",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgConnectionOpenConfirm"
                      },
                      "type_url": {
                        "default": "/ibc.core.connection.v1.MsgConnectionOpenConfirm",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.connection.v1.MsgConnectionOpenConfirm"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.connection.v1.MsgConnectionOpenConfirm",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgConnectionOpenInit"
                      },
                      "type_url": {
                        "default": "/ibc.core.connection.v1.MsgConnectionOpenInit",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.connection.v1.MsgConnectionOpenInit"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.connection.v1.MsgConnectionOpenInit",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgConnectionOpenTry"
                      },
                      "type_url": {
                        "default": "/ibc.core.connection.v1.MsgConnectionOpenTry",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/ibc.core.connection.v1.MsgConnectionOpenTry"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "ibc.core.connection.v1.MsgConnectionOpenTry",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgAccept"
                      },
                      "type_url": {
                        "default": "/names.MsgAccept",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgAccept"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgAccept",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgBurnCoins"
                      },
                      "type_url": {
                        "default": "/names.MsgBurnCoins",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgBurnCoins"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgBurnCoins",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgBurnNft"
                      },
                      "type_url": {
                        "default": "/names.MsgBurnNft",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgBurnNft"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgBurnNft",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgBuy"
                      },
                      "type_url": {
                        "default": "/names.MsgBuy",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgBuy"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgBuy",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgDeleteName"
                      },
                      "type_url": {
                        "default": "/names.MsgDeleteName",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgDeleteName"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgDeleteName",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgMintCoins"
                      },
                      "type_url": {
                        "default": "/names.MsgMintCoins",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgMintCoins"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgMintCoins",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgMintNft"
                      },
                      "type_url": {
                        "default": "/names.MsgMintNft",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgMintNft"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgMintNft",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgOfferTo"
                      },
                      "type_url": {
                        "default": "/names.MsgOfferTo",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgOfferTo"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgOfferTo",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgRegister"
                      },
                      "type_url": {
                        "default": "/names.MsgRegister",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgRegister"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgRegister",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgReveal"
                      },
                      "type_url": {
                        "default": "/names.MsgReveal",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgReveal"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgReveal",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSetNftClass"
                      },
                      "type_url": {
                        "default": "/names.MsgSetNftClass",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgSetNftClass"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgSetNftClass",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgSetPriceAndExtend"
                      },
                      "type_url": {
                        "default": "/names.MsgSetPriceAndExtend",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgSetPriceAndExtend"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgSetPriceAndExtend",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateName"
                      },
                      "type_url": {
                        "default": "/names.MsgUpdateName",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgUpdateName"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgUpdateName",
                    "type": "object"
                  },
                  {
                    "properties": {
                      "object_value": {
                        "$ref": "#/definitions/MsgUpdateNft"
                      },
                      "type_url": {
                        "default": "/names.MsgUpdateNft",
                        "description": "Registered fully-qualified proto name for a message type valid for this request",
                        "enum": [
                          "/names.MsgUpdateNft"
                        ],
                        "readOnly": true,
                        "type": "string"
                      },
                      "value": {
                        "binaryEncoding": "base64",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "binary",
                        "readOnly": true,
                        "type": "string"
                      }
                    },
                    "title": "names.MsgUpdateNft",
                    "type": "object"
                  }
                ]
              },
              "type": "array"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata to attached to the proposal.",
              "type": "string"
            },
            "proposers": {
              "description": "proposers are the account addresses of the proposers. Proposers signatures will be counted as yes votes.",
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          },
          "title": "Msg Submit Proposal",
          "type": "object"
        },
        "MsgTimeout": {
          "additionalProperties": false,
          "description": "MsgTimeout receives timed-out packet",
          "properties": {
            "next_sequence_recv": {
              "type": "string"
            },
            "packet": {
              "$ref": "#/definitions/ibc.core.channel.v1.Packet",
              "additionalProperties": false
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_unreceived": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Timeout",
          "type": "object"
        },
        "MsgTimeoutOnClose": {
          "additionalProperties": false,
          "description": "MsgTimeoutOnClose timed-out packet upon counterparty channel closure.",
          "properties": {
            "next_sequence_recv": {
              "type": "string"
            },
            "packet": {
              "$ref": "#/definitions/ibc.core.channel.v1.Packet",
              "additionalProperties": false
            },
            "proof_close": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "proof_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false
            },
            "proof_unreceived": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "type": "string"
            }
          },
          "title": "Msg Timeout On Close",
          "type": "object"
        },
        "MsgTransfer": {
          "additionalProperties": false,
          "description": "MsgTransfer defines a msg to transfer fungible tokens (i.e Coins) between ICS20 enabled chains. See ICS Spec here: https://github.com/cosmos/ibc/tree/master/spec/app/ics-020-fungible-token-transfer#data-structures",
          "properties": {
            "memo": {
              "description": "optional memo",
              "type": "string"
            },
            "receiver": {
              "description": "the recipient address on the destination chain",
              "type": "string"
            },
            "sender": {
              "description": "the sender address",
              "type": "string"
            },
            "source_channel": {
              "description": "the channel by which the packet will be sent",
              "type": "string"
            },
            "source_port": {
              "description": "the port on which the packet will be sent",
              "type": "string"
            },
            "timeout_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false,
              "description": "Timeout height relative to the current block height. The timeout is disabled when set to 0."
            },
            "timeout_timestamp": {
              "description": "Timeout timestamp in absolute nanoseconds since unix epoch. The timeout is disabled when set to 0.",
              "type": "string"
            },
            "token": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false,
              "description": "the tokens to be transferred"
            }
          },
          "title": "Msg Transfer",
          "type": "object"
        },
        "MsgUndelegate": {
          "additionalProperties": false,
          "description": "MsgUndelegate defines a SDK message for performing an undelegation from a delegate and a validator.",
          "properties": {
            "amount": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false
            },
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Undelegate",
          "type": "object"
        },
        "MsgUnjail": {
          "additionalProperties": false,
          "description": "MsgUnjail defines the Msg/Unjail request type",
          "properties": {
            "validator_addr": {
              "type": "string"
            }
          },
          "title": "Msg Unjail",
          "type": "object"
        },
        "MsgUpdateClient": {
          "additionalProperties": false,
          "description": "MsgUpdateClient defines an sdk.Msg to update a IBC client state using the given header.",
          "properties": {
            "client_id": {
              "description": "client unique identifier",
              "type": "string"
            },
            "header": {
              "additionalProperties": false,
              "description": "header to update the light client",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "signer": {
              "description": "signer address",
              "type": "string"
            }
          },
          "title": "Msg Update Client",
          "type": "object"
        },
        "MsgUpdateGroupAdmin": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.",
          "properties": {
            "admin": {
              "description": "admin is the current account address of the group admin.",
              "type": "string"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "new_admin": {
              "description": "new_admin is the group new admin account address.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Admin",
          "type": "object"
        },
        "MsgUpdateGroupMembers": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "member_updates": {
              "description": "member_updates is the list of members to update, set weight to 0 to remove a member.",
              "items": {
                "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
              },
              "type": "array"
            }
          },
          "title": "Msg Update Group Members",
          "type": "object"
        },
        "MsgUpdateGroupMetadata": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is the updated group's metadata.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Metadata",
          "type": "object"
        },
        "MsgUpdateGroupPolicyAdmin": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "group_policy_address": {
              "description": "group_policy_address is the account address of the group policy.",
              "type": "string"
            },
            "new_admin": {
              "description": "new_admin is the new group policy admin.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Policy Admin",
          "type": "object"
        },
        "MsgUpdateGroupPolicyDecisionPolicy": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "decision_policy": {
              "additionalProperties": false,
              "description": "decision_policy is the updated group policy's decision policy.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "group_policy_address": {
              "description": "group_policy_address is the account address of group policy.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Policy Decision Policy",
          "type": "object"
        },
        "MsgUpdateGroupPolicyMetadata": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "group_policy_address": {
              "description": "group_policy_address is the account address of group policy.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is the updated group policy metadata.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Policy Metadata",
          "type": "object"
        },
        "MsgUpdateName": {
          "additionalProperties": false,
          "description": "Update the details of the Dyson Protocol name",
          "properties": {
            "authorized": {
              "description": "The address that this name is OfferedTo, they can take ownership of the name with the Accept message",
              "type": "string"
            },
            "auto_renew": {
              "description": "Will the name be automatically renewed at the expiration height. The expiration height is extended by 31,536,000 blocks (about 1 year). The fee is 1% of the price and is paid by the owner at the time of the renewal.",
              "type": "boolean"
            },
            "destination": {
              "description": "The new destination address for the name",
              "type": "string"
            },
            "name": {
              "description": "The name to update",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            }
          },
          "title": "Msg Update Name",
          "type": "object"
        },
        "MsgUpdateNft": {
          "additionalProperties": false,
          "description": "Update the details of an NFT",
          "properties": {
            "class_id": {
              "description": "the NFT Class ID",
              "type": "string"
            },
            "class_owner": {
              "description": "The owner of the NFT Class",
              "type": "string"
            },
            "id": {
              "description": "The ID of this NFT to update",
              "type": "string"
            },
            "uri": {
              "description": "The URI of the NFT (optional)",
              "type": "string"
            },
            "uri_hash": {
              "description": "The URI hash of the NFT (optional)",
              "type": "string"
            }
          },
          "title": "Msg Update Nft",
          "type": "object"
        },
        "MsgUpdateScheduledRun": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            },
            "index": {
              "type": "string"
            },
            "msg": {
              "$ref": "#/definitions/dyson.MsgRun",
              "additionalProperties": false
            }
          },
          "title": "Msg Update Scheduled Run",
          "type": "object"
        },
        "MsgUpdateScript": {
          "additionalProperties": false,
          "properties": {
            "code": {
              "format": "python",
              "type": "string"
            },
            "creator": {
              "type": "string"
            }
          },
          "title": "Msg Update Script",
          "type": "object"
        },
        "MsgUpdateStorage": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "description": "The address signing this transaction",
              "type": "string"
            },
            "data": {
              "description": "data to store at this index",
              "type": "string"
            },
            "force": {
              "description": "If true, force will always store the data at this address regardless of already existing storage",
              "type": "boolean"
            },
            "index": {
              "description": "Name of the Storage, must be prefixed with the creators address (for example: \"dys..1a3/some_name\")",
              "type": "string"
            }
          },
          "title": "Msg Update Storage",
          "type": "object"
        },
        "MsgUpgradeClient": {
          "additionalProperties": false,
          "description": "MsgUpgradeClient defines an sdk.Msg to upgrade an IBC client to a new client state",
          "properties": {
            "client_id": {
              "description": "client unique identifier",
              "type": "string"
            },
            "client_state": {
              "additionalProperties": false,
              "description": "upgraded client state",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "consensus_state": {
              "additionalProperties": false,
              "description": "upgraded consensus state, only contains enough information to serve as a basis of trust in update logic",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "proof_upgrade_client": {
              "binaryEncoding": "base64",
              "description": "proof that old chain committed to new client",
              "format": "binary",
              "type": "string"
            },
            "proof_upgrade_consensus_state": {
              "binaryEncoding": "base64",
              "description": "proof that old chain committed to new consensus state",
              "format": "binary",
              "type": "string"
            },
            "signer": {
              "description": "signer address",
              "type": "string"
            }
          },
          "title": "Msg Upgrade Client",
          "type": "object"
        },
        "MsgVerifyInvariant": {
          "additionalProperties": false,
          "description": "MsgVerifyInvariant represents a message to verify a particular invariance.",
          "properties": {
            "invariant_module_name": {
              "type": "string"
            },
            "invariant_route": {
              "type": "string"
            },
            "sender": {
              "type": "string"
            }
          },
          "title": "Msg Verify Invariant",
          "type": "object"
        },
        "MsgVote": {
          "additionalProperties": false,
          "description": "MsgVote is the Msg/Vote request type.",
          "properties": {
            "exec": {
              "description": "Proposals and Voting  Exec defines modes of execution of a proposal on creation or on new vote.",
              "enum": [
                "EXEC_UNSPECIFIED",
                0,
                "EXEC_TRY",
                1
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Proposals and Voting"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata to attached to the vote.",
              "type": "string"
            },
            "option": {
              "description": "VoteOption enumerates the valid vote options for a given proposal.",
              "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                0,
                "VOTE_OPTION_YES",
                1,
                "VOTE_OPTION_ABSTAIN",
                2,
                "VOTE_OPTION_NO",
                3,
                "VOTE_OPTION_NO_WITH_VETO",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Vote Option"
            },
            "proposal_id": {
              "description": "proposal is the unique ID of the proposal.",
              "type": "string"
            },
            "voter": {
              "description": "voter is the voter account address.",
              "type": "string"
            }
          },
          "title": "Msg Vote",
          "type": "object"
        },
        "MsgVoteWeighted": {
          "additionalProperties": false,
          "description": "MsgVoteWeighted defines a message to cast a vote. Since: cosmos-sdk 0.43",
          "properties": {
            "options": {
              "items": {
                "$ref": "#/definitions/cosmos.gov.v1beta1.WeightedVoteOption"
              },
              "type": "array"
            },
            "proposal_id": {
              "type": "string"
            },
            "voter": {
              "type": "string"
            }
          },
          "title": "Msg Vote Weighted",
          "type": "object"
        },
        "MsgWithdrawDelegatorReward": {
          "additionalProperties": false,
          "description": "MsgWithdrawDelegatorReward represents delegation withdrawal to a delegator from a single validator.",
          "properties": {
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Withdraw Delegator Reward",
          "type": "object"
        },
        "MsgWithdrawProposal": {
          "additionalProperties": false,
          "description": "MsgWithdrawProposal is the Msg/WithdrawProposal request type.",
          "properties": {
            "address": {
              "description": "address is the admin of the group policy or one of the proposer of the proposal.",
              "type": "string"
            },
            "proposal_id": {
              "description": "proposal is the unique ID of the proposal.",
              "type": "string"
            }
          },
          "title": "Msg Withdraw Proposal",
          "type": "object"
        },
        "MsgWithdrawValidatorCommission": {
          "additionalProperties": false,
          "description": "MsgWithdrawValidatorCommission withdraws the full commission to the validator address.",
          "properties": {
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Withdraw Validator Commission",
          "type": "object"
        },
        "cosmos.authz.v1beta1.Grant": {
          "additionalProperties": false,
          "description": "Grant gives permissions to execute the provide method with expiration time.",
          "properties": {
            "authorization": {
              "additionalProperties": false,
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "expiration": {
              "description": "time when the grant will expire and will be pruned. If null, then the grant doesn't have a time expiration (other conditions  in `authorization` may apply to invalidate the grant)",
              "format": "date-time",
              "type": "string"
            }
          },
          "title": "Grant",
          "type": "object"
        },
        "cosmos.bank.v1beta1.Input": {
          "additionalProperties": false,
          "description": "Input models transaction input.",
          "properties": {
            "address": {
              "type": "string"
            },
            "coins": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            }
          },
          "title": "Input",
          "type": "object"
        },
        "cosmos.bank.v1beta1.Output": {
          "additionalProperties": false,
          "description": "Output models transaction outputs.",
          "properties": {
            "address": {
              "type": "string"
            },
            "coins": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            }
          },
          "title": "Output",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        },
        "cosmos.gov.v1.WeightedVoteOption": {
          "additionalProperties": false,
          "description": "WeightedVoteOption defines a unit of vote for vote split.",
          "properties": {
            "option": {
              "description": "VoteOption enumerates the valid vote options for a given governance proposal.",
              "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                0,
                "VOTE_OPTION_YES",
                1,
                "VOTE_OPTION_ABSTAIN",
                2,
                "VOTE_OPTION_NO",
                3,
                "VOTE_OPTION_NO_WITH_VETO",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Vote Option"
            },
            "weight": {
              "type": "string"
            }
          },
          "title": "Weighted Vote Option",
          "type": "object"
        },
        "cosmos.gov.v1beta1.WeightedVoteOption": {
          "additionalProperties": false,
          "description": "WeightedVoteOption defines a unit of vote for vote split. Since: cosmos-sdk 0.43",
          "properties": {
            "option": {
              "description": "VoteOption enumerates the valid vote options for a given governance proposal.",
              "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                0,
                "VOTE_OPTION_YES",
                1,
                "VOTE_OPTION_ABSTAIN",
                2,
                "VOTE_OPTION_NO",
                3,
                "VOTE_OPTION_NO_WITH_VETO",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Vote Option"
            },
            "weight": {
              "type": "string"
            }
          },
          "title": "Weighted Vote Option",
          "type": "object"
        },
        "cosmos.group.v1.MemberRequest": {
          "additionalProperties": false,
          "description": "MemberRequest represents a group member to be used in Msg server requests. Contrary to `Member`, it doesn't have any `added_at` field since this field cannot be set as part of requests.",
          "properties": {
            "address": {
              "description": "address is the member's account address.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata attached to the member.",
              "type": "string"
            },
            "weight": {
              "description": "weight is the member's voting weight that should be greater than 0.",
              "type": "string"
            }
          },
          "title": "Member Request",
          "type": "object"
        },
        "cosmos.staking.v1beta1.CommissionRates": {
          "additionalProperties": false,
          "description": "CommissionRates defines the initial commission rates to be used for creating a validator.",
          "properties": {
            "max_change_rate": {
              "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction.",
              "type": "string"
            },
            "max_rate": {
              "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction.",
              "type": "string"
            },
            "rate": {
              "description": "rate is the commission rate charged to delegators, as a fraction.",
              "type": "string"
            }
          },
          "title": "Commission Rates",
          "type": "object"
        },
        "cosmos.staking.v1beta1.Description": {
          "additionalProperties": false,
          "description": "Description defines a validator description.",
          "properties": {
            "details": {
              "description": "details define other optional details.",
              "type": "string"
            },
            "identity": {
              "description": "identity defines an optional identity signature (ex. UPort or Keybase).",
              "type": "string"
            },
            "moniker": {
              "description": "moniker defines a human-readable name for the validator.",
              "type": "string"
            },
            "security_contact": {
              "description": "security_contact defines an optional email for security contact.",
              "type": "string"
            },
            "website": {
              "description": "website defines an optional website link.",
              "type": "string"
            }
          },
          "title": "Description",
          "type": "object"
        },
        "cosmos.upgrade.v1beta1.Plan": {
          "additionalProperties": false,
          "description": "Plan specifies information about a planned upgrade and when it should occur.",
          "properties": {
            "height": {
              "description": "The height at which the upgrade must be performed. Only used if Time is not set.",
              "type": "string"
            },
            "info": {
              "description": "Any application specific upgrade info to be included on-chain such as a git commit that validators could automatically upgrade to",
              "type": "string"
            },
            "name": {
              "description": "Sets the name for the upgrade. This name will be used by the upgraded version of the software to apply any special \"on-upgrade\" commands during the first BeginBlock method after the upgrade is applied. It is also used to detect whether a software version can handle a given upgrade. If no upgrade handler with this name has been set in the software, it will be assumed that the software is out-of-date when the upgrade Time or Height is reached and the software will exit.",
              "type": "string"
            },
            "time": {
              "description": "Deprecated: Time based upgrades have been deprecated. Time based upgrade logic has been removed from the SDK. If this field is not empty, an error will be thrown.",
              "format": "date-time",
              "type": "string"
            },
            "upgraded_client_state": {
              "additionalProperties": false,
              "description": "Deprecated: UpgradedClientState field has been deprecated. IBC upgrade logic has been moved to the IBC module in the sub module 02-client. If this field is not empty, an error will be thrown.",
              "properties": {
                "type_url": {
                  "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows: * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.) Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com. Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.",
                  "type": "string"
                },
                "value": {
                  "binaryEncoding": "base64",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "binary",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "title": "Plan",
          "type": "object"
        },
        "cosmos.vesting.v1beta1.Period": {
          "additionalProperties": false,
          "description": "Period defines a length of time and amount of coins that will vest.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "length": {
              "type": "string"
            }
          },
          "title": "Period",
          "type": "object"
        },
        "dyson.MsgRun": {
          "additionalProperties": false,
          "description": "MsgRun runs a script at a specific address",
          "properties": {
            "address": {
              "description": "Dys address of the script to call",
              "type": "string"
            },
            "args": {
              "description": "Optional args to call the function with",
              "type": "string"
            },
            "coins": {
              "description": "Optional comma seperated list of coins to send the script (for example \"123dys,456token\") this entire amount will be sent to the script",
              "type": "string"
            },
            "creator": {
              "description": "The account sending this transaction",
              "type": "string"
            },
            "extra_lines": {
              "description": "Optional extra source code to append to the end of the script before running. Only available to the script address itself.",
              "type": "string"
            },
            "function_name": {
              "description": "Optional function to call",
              "type": "string"
            },
            "kwargs": {
              "description": "Optional kwargs to run",
              "type": "string"
            },
            "nfts": {
              "description": "Optional NFTs to send the script, formatted [class_id]/[id], [class_id]/[id] (for example \"example.dys/123, example.dys/456\")",
              "type": "string"
            }
          },
          "title": "Msg Run",
          "type": "object"
        },
        "ibc.applications.interchain_accounts.v1.InterchainAccountPacketData": {
          "additionalProperties": false,
          "description": "InterchainAccountPacketData is comprised of a raw transaction, type of transaction and optional memo field.",
          "properties": {
            "data": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "memo": {
              "type": "string"
            },
            "type": {
              "description": "Type defines a classification of message issued from a controller chain to its associated interchain accounts host",
              "enum": [
                "TYPE_UNSPECIFIED",
                0,
                "TYPE_EXECUTE_TX",
                1
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Type"
            }
          },
          "title": "Interchain Account Packet Data",
          "type": "object"
        },
        "ibc.core.channel.v1.Channel": {
          "additionalProperties": false,
          "description": "Channel defines pipeline for exactly-once packet delivery between specific modules on separate blockchains, which has at least one end capable of sending packets and one end capable of receiving packets.",
          "properties": {
            "connection_hops": {
              "description": "list of connection identifiers, in order, along which packets sent on this channel will travel",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "counterparty": {
              "$ref": "#/definitions/ibc.core.channel.v1.Counterparty",
              "additionalProperties": false,
              "description": "counterparty channel end"
            },
            "ordering": {
              "description": "Order defines if a channel is ORDERED or UNORDERED",
              "enum": [
                "ORDER_NONE_UNSPECIFIED",
                0,
                "ORDER_UNORDERED",
                1,
                "ORDER_ORDERED",
                2
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Order"
            },
            "state": {
              "description": "State defines if a channel is in one of the following states: CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.",
              "enum": [
                "STATE_UNINITIALIZED_UNSPECIFIED",
                0,
                "STATE_INIT",
                1,
                "STATE_TRYOPEN",
                2,
                "STATE_OPEN",
                3,
                "STATE_CLOSED",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "State"
            },
            "version": {
              "description": "opaque channel version, which is agreed upon during the handshake",
              "type": "string"
            }
          },
          "title": "Channel",
          "type": "object"
        },
        "ibc.core.channel.v1.Counterparty": {
          "additionalProperties": false,
          "description": "Counterparty defines a channel end counterparty",
          "properties": {
            "channel_id": {
              "description": "channel end on the counterparty chain",
              "type": "string"
            },
            "port_id": {
              "description": "port on the counterparty chain which owns the other end of the channel.",
              "type": "string"
            }
          },
          "title": "Counterparty",
          "type": "object"
        },
        "ibc.core.channel.v1.Packet": {
          "additionalProperties": false,
          "description": "Packet defines a type that carries data across different chains through IBC",
          "properties": {
            "data": {
              "binaryEncoding": "base64",
              "description": "actual opaque bytes transferred directly to the application module",
              "format": "binary",
              "type": "string"
            },
            "destination_channel": {
              "description": "identifies the channel end on the receiving chain.",
              "type": "string"
            },
            "destination_port": {
              "description": "identifies the port on the receiving chain.",
              "type": "string"
            },
            "sequence": {
              "description": "number corresponds to the order of sends and receives, where a Packet with an earlier sequence number must be sent and received before a Packet with a later sequence number.",
              "type": "string"
            },
            "source_channel": {
              "description": "identifies the channel end on the sending chain.",
              "type": "string"
            },
            "source_port": {
              "description": "identifies the port on the sending chain.",
              "type": "string"
            },
            "timeout_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false,
              "description": "block height after which the packet times out"
            },
            "timeout_timestamp": {
              "description": "block timestamp (in nanoseconds) after which the packet times out",
              "type": "string"
            }
          },
          "title": "Packet",
          "type": "object"
        },
        "ibc.core.client.v1.Height": {
          "additionalProperties": false,
          "description": "Height is a monotonically increasing data type that can be compared against another Height for the purposes of updating and freezing clients Normally the RevisionHeight is incremented at each height while keeping RevisionNumber the same. However some consensus algorithms may choose to reset the height in certain conditions e.g. hard forks, state-machine breaking changes In these cases, the RevisionNumber is incremented so that height continues to be monitonically increasing even as the RevisionHeight gets reset",
          "properties": {
            "revision_height": {
              "description": "the height within the given revision",
              "type": "string"
            },
            "revision_number": {
              "description": "the revision that the client is currently on",
              "type": "string"
            }
          },
          "title": "Height",
          "type": "object"
        },
        "ibc.core.commitment.v1.MerklePrefix": {
          "additionalProperties": false,
          "description": "MerklePrefix is merkle path prefixed to the key. The constructed key from the Path and the key will be append(Path.KeyPath, append(Path.KeyPrefix, key...))",
          "properties": {
            "key_prefix": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            }
          },
          "title": "Merkle Prefix",
          "type": "object"
        },
        "ibc.core.connection.v1.Counterparty": {
          "additionalProperties": false,
          "description": "Counterparty defines the counterparty chain associated with a connection end.",
          "properties": {
            "client_id": {
              "description": "identifies the client on the counterparty chain associated with a given connection.",
              "type": "string"
            },
            "connection_id": {
              "description": "identifies the connection end on the counterparty chain associated with a given connection.",
              "type": "string"
            },
            "prefix": {
              "$ref": "#/definitions/ibc.core.commitment.v1.MerklePrefix",
              "additionalProperties": false,
              "description": "commitment merkle prefix of the counterparty chain."
            }
          },
          "title": "Counterparty",
          "type": "object"
        },
        "ibc.core.connection.v1.Version": {
          "additionalProperties": false,
          "description": "Version defines the versioning scheme used to negotiate the IBC verison in the connection handshake.",
          "properties": {
            "features": {
              "description": "list of features compatible with the specified identifier",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "identifier": {
              "description": "unique version identifier",
              "type": "string"
            }
          },
          "title": "Version",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.group.v1/sendMsgUpdateGroupAdmin": {
    "http_rules": null,
    "module_name": "cosmos.group.v1",
    "name": "UpdateGroupAdmin",
    "request_schema": {
      "$ref": "#/definitions/MsgUpdateGroupAdmin",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgUpdateGroupAdmin": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.",
          "properties": {
            "admin": {
              "description": "admin is the current account address of the group admin.",
              "type": "string"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "new_admin": {
              "description": "new_admin is the group new admin account address.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Admin",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.group.v1/sendMsgUpdateGroupMembers": {
    "http_rules": null,
    "module_name": "cosmos.group.v1",
    "name": "UpdateGroupMembers",
    "request_schema": {
      "$ref": "#/definitions/MsgUpdateGroupMembers",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgUpdateGroupMembers": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "member_updates": {
              "description": "member_updates is the list of members to update, set weight to 0 to remove a member.",
              "items": {
                "$ref": "#/definitions/cosmos.group.v1.MemberRequest"
              },
              "type": "array"
            }
          },
          "title": "Msg Update Group Members",
          "type": "object"
        },
        "cosmos.group.v1.MemberRequest": {
          "additionalProperties": false,
          "description": "MemberRequest represents a group member to be used in Msg server requests. Contrary to `Member`, it doesn't have any `added_at` field since this field cannot be set as part of requests.",
          "properties": {
            "address": {
              "description": "address is the member's account address.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata attached to the member.",
              "type": "string"
            },
            "weight": {
              "description": "weight is the member's voting weight that should be greater than 0.",
              "type": "string"
            }
          },
          "title": "Member Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.group.v1/sendMsgUpdateGroupMetadata": {
    "http_rules": null,
    "module_name": "cosmos.group.v1",
    "name": "UpdateGroupMetadata",
    "request_schema": {
      "$ref": "#/definitions/MsgUpdateGroupMetadata",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgUpdateGroupMetadata": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "group_id": {
              "description": "group_id is the unique ID of the group.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is the updated group's metadata.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Metadata",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.group.v1/sendMsgUpdateGroupPolicyAdmin": {
    "http_rules": null,
    "module_name": "cosmos.group.v1",
    "name": "UpdateGroupPolicyAdmin",
    "request_schema": {
      "$ref": "#/definitions/MsgUpdateGroupPolicyAdmin",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgUpdateGroupPolicyAdmin": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "group_policy_address": {
              "description": "group_policy_address is the account address of the group policy.",
              "type": "string"
            },
            "new_admin": {
              "description": "new_admin is the new group policy admin.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Policy Admin",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.group.v1/sendMsgUpdateGroupPolicyDecisionPolicy": {
    "http_rules": null,
    "module_name": "cosmos.group.v1",
    "name": "UpdateGroupPolicyDecisionPolicy",
    "request_schema": {
      "$ref": "#/definitions/MsgUpdateGroupPolicyDecisionPolicy",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgUpdateGroupPolicyDecisionPolicy": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "decision_policy": {
              "oneOf": [
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/PercentageDecisionPolicy"
                    },
                    "type_url": {
                      "default": "/cosmos.group.v1.PercentageDecisionPolicy",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.group.v1.PercentageDecisionPolicy"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.group.v1.PercentageDecisionPolicy",
                  "type": "object"
                },
                {
                  "properties": {
                    "object_value": {
                      "$ref": "#/definitions/ThresholdDecisionPolicy"
                    },
                    "type_url": {
                      "default": "/cosmos.group.v1.ThresholdDecisionPolicy",
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "enum": [
                        "/cosmos.group.v1.ThresholdDecisionPolicy"
                      ],
                      "readOnly": true,
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "readOnly": true,
                      "type": "string"
                    }
                  },
                  "title": "cosmos.group.v1.ThresholdDecisionPolicy",
                  "type": "object"
                }
              ]
            },
            "group_policy_address": {
              "description": "group_policy_address is the account address of group policy.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Policy Decision Policy",
          "type": "object"
        },
        "PercentageDecisionPolicy": {
          "additionalProperties": false,
          "description": "PercentageDecisionPolicy is a decision policy where a proposal passes when it satisfies the two following conditions: 1. The percentage of all `YES` voters' weights out of the total group weight    is greater or equal than the given `percentage`. 2. The voting and execution periods of the proposal respect the parameters    given by `windows`.",
          "properties": {
            "percentage": {
              "description": "percentage is the minimum percentage the weighted sum of `YES` votes must meet for a proposal to succeed.",
              "type": "string"
            },
            "windows": {
              "$ref": "#/definitions/cosmos.group.v1.DecisionPolicyWindows",
              "additionalProperties": false,
              "description": "windows defines the different windows for voting and execution."
            }
          },
          "title": "Percentage Decision Policy",
          "type": "object"
        },
        "ThresholdDecisionPolicy": {
          "additionalProperties": false,
          "description": "ThresholdDecisionPolicy is a decision policy where a proposal passes when it satisfies the two following conditions: 1. The sum of all `YES` voters' weights is greater or equal than the defined    `threshold`. 2. The voting and execution periods of the proposal respect the parameters    given by `windows`.",
          "properties": {
            "threshold": {
              "description": "threshold is the minimum weighted sum of `YES` votes that must be met or exceeded for a proposal to succeed.",
              "type": "string"
            },
            "windows": {
              "$ref": "#/definitions/cosmos.group.v1.DecisionPolicyWindows",
              "additionalProperties": false,
              "description": "windows defines the different windows for voting and execution."
            }
          },
          "title": "Threshold Decision Policy",
          "type": "object"
        },
        "cosmos.group.v1.DecisionPolicyWindows": {
          "additionalProperties": false,
          "description": "DecisionPolicyWindows defines the different windows for voting and execution.",
          "properties": {
            "min_execution_period": {
              "description": "min_execution_period is the minimum duration after the proposal submission where members can start sending MsgExec. This means that the window for sending a MsgExec transaction is: `[ submission + min_execution_period ; submission + voting_period + max_execution_period]` where max_execution_period is a app-specific config, defined in the keeper. If not set, min_execution_period will default to 0. Please make sure to set a `min_execution_period` that is smaller than `voting_period + max_execution_period`, or else the above execution window is empty, meaning that all proposals created with this decision policy won't be able to be executed.",
              "format": "regex",
              "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
              "type": "string"
            },
            "voting_period": {
              "description": "voting_period is the duration from submission of a proposal to the end of voting period Within this times votes can be submitted with MsgVote.",
              "format": "regex",
              "pattern": "^([0-9]+\\.?[0-9]*|\\.[0-9]+)s$",
              "type": "string"
            }
          },
          "title": "Decision Policy Windows",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.group.v1/sendMsgUpdateGroupPolicyMetadata": {
    "http_rules": null,
    "module_name": "cosmos.group.v1",
    "name": "UpdateGroupPolicyMetadata",
    "request_schema": {
      "$ref": "#/definitions/MsgUpdateGroupPolicyMetadata",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgUpdateGroupPolicyMetadata": {
          "additionalProperties": false,
          "description": "MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.",
          "properties": {
            "admin": {
              "description": "admin is the account address of the group admin.",
              "type": "string"
            },
            "group_policy_address": {
              "description": "group_policy_address is the account address of group policy.",
              "type": "string"
            },
            "metadata": {
              "description": "metadata is the updated group policy metadata.",
              "type": "string"
            }
          },
          "title": "Msg Update Group Policy Metadata",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.group.v1/sendMsgVote": {
    "http_rules": null,
    "module_name": "cosmos.group.v1",
    "name": "Vote",
    "request_schema": {
      "$ref": "#/definitions/MsgVote",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgVote": {
          "additionalProperties": false,
          "description": "MsgVote is the Msg/Vote request type.",
          "properties": {
            "exec": {
              "description": "Proposals and Voting  Exec defines modes of execution of a proposal on creation or on new vote.",
              "enum": [
                "EXEC_UNSPECIFIED",
                0,
                "EXEC_TRY",
                1
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Proposals and Voting"
            },
            "metadata": {
              "description": "metadata is any arbitrary metadata to attached to the vote.",
              "type": "string"
            },
            "option": {
              "description": "VoteOption enumerates the valid vote options for a given proposal.",
              "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                0,
                "VOTE_OPTION_YES",
                1,
                "VOTE_OPTION_ABSTAIN",
                2,
                "VOTE_OPTION_NO",
                3,
                "VOTE_OPTION_NO_WITH_VETO",
                4
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Vote Option"
            },
            "proposal_id": {
              "description": "proposal is the unique ID of the proposal.",
              "type": "string"
            },
            "voter": {
              "description": "voter is the voter account address.",
              "type": "string"
            }
          },
          "title": "Msg Vote",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.group.v1/sendMsgWithdrawProposal": {
    "http_rules": null,
    "module_name": "cosmos.group.v1",
    "name": "WithdrawProposal",
    "request_schema": {
      "$ref": "#/definitions/MsgWithdrawProposal",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgWithdrawProposal": {
          "additionalProperties": false,
          "description": "MsgWithdrawProposal is the Msg/WithdrawProposal request type.",
          "properties": {
            "address": {
              "description": "address is the admin of the group policy or one of the proposer of the proposal.",
              "type": "string"
            },
            "proposal_id": {
              "description": "proposal is the unique ID of the proposal.",
              "type": "string"
            }
          },
          "title": "Msg Withdraw Proposal",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.mint.v1beta1/QueryAnnualProvisions": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "cosmos.mint.v1beta1",
    "name": "AnnualProvisions",
    "request_schema": {
      "$ref": "#/definitions/QueryAnnualProvisionsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryAnnualProvisionsRequest": {
          "additionalProperties": false,
          "description": "QueryAnnualProvisionsRequest is the request type for the Query/AnnualProvisions RPC method.",
          "title": "Query Annual Provisions Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/mint/v1beta1/annual_provisions",
    "service_name": "Query"
  },
  "cosmos.mint.v1beta1/QueryInflation": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "cosmos.mint.v1beta1",
    "name": "Inflation",
    "request_schema": {
      "$ref": "#/definitions/QueryInflationRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryInflationRequest": {
          "additionalProperties": false,
          "description": "QueryInflationRequest is the request type for the Query/Inflation RPC method.",
          "title": "Query Inflation Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/mint/v1beta1/inflation",
    "service_name": "Query"
  },
  "cosmos.mint.v1beta1/QueryParams": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "cosmos.mint.v1beta1",
    "name": "Params",
    "request_schema": {
      "$ref": "#/definitions/QueryParamsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryParamsRequest": {
          "additionalProperties": false,
          "description": "QueryParamsRequest is the request type for the Query/Params RPC method.",
          "title": "Query Params Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/mint/v1beta1/params",
    "service_name": "Query"
  },
  "cosmos.nft.v1beta1/QueryBalance": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "owner",
          "class_id"
        ]
      }
    ],
    "module_name": "cosmos.nft.v1beta1",
    "name": "Balance",
    "request_schema": {
      "$ref": "#/definitions/QueryBalanceRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryBalanceRequest": {
          "additionalProperties": false,
          "description": "QueryBalanceRequest is the request type for the Query/Balance RPC method",
          "properties": {
            "class_id": {
              "type": "string"
            },
            "owner": {
              "type": "string"
            }
          },
          "title": "Query Balance Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/nft/v1beta1/balance/{owner}/{class_id}",
    "service_name": "Query"
  },
  "cosmos.nft.v1beta1/QueryClass": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "class_id"
        ]
      }
    ],
    "module_name": "cosmos.nft.v1beta1",
    "name": "Class",
    "request_schema": {
      "$ref": "#/definitions/QueryClassRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryClassRequest": {
          "additionalProperties": false,
          "description": "QueryClassRequest is the request type for the Query/Class RPC method",
          "properties": {
            "class_id": {
              "type": "string"
            }
          },
          "title": "Query Class Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/nft/v1beta1/classes/{class_id}",
    "service_name": "Query"
  },
  "cosmos.nft.v1beta1/QueryClasses": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "cosmos.nft.v1beta1",
    "name": "Classes",
    "request_schema": {
      "$ref": "#/definitions/QueryClassesRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryClassesRequest": {
          "additionalProperties": false,
          "description": "QueryClassesRequest is the request type for the Query/Classes RPC method",
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            }
          },
          "title": "Query Classes Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/nft/v1beta1/classes",
    "service_name": "Query"
  },
  "cosmos.nft.v1beta1/QueryNFT": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "class_id",
          "id"
        ]
      }
    ],
    "module_name": "cosmos.nft.v1beta1",
    "name": "NFT",
    "request_schema": {
      "$ref": "#/definitions/QueryNFTRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryNFTRequest": {
          "additionalProperties": false,
          "description": "QueryNFTRequest is the request type for the Query/NFT RPC method",
          "properties": {
            "class_id": {
              "type": "string"
            },
            "id": {
              "type": "string"
            }
          },
          "title": "Query NFT Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/nft/v1beta1/nfts/{class_id}/{id}",
    "service_name": "Query"
  },
  "cosmos.nft.v1beta1/QueryNFTs": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "cosmos.nft.v1beta1",
    "name": "NFTs",
    "request_schema": {
      "$ref": "#/definitions/QueryNFTsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryNFTsRequest": {
          "additionalProperties": false,
          "description": "QueryNFTstRequest is the request type for the Query/NFTs RPC method",
          "properties": {
            "class_id": {
              "type": "string"
            },
            "owner": {
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false
            }
          },
          "title": "Query NF Ts Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/nft/v1beta1/nfts",
    "service_name": "Query"
  },
  "cosmos.nft.v1beta1/QueryOwner": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "class_id",
          "id"
        ]
      }
    ],
    "module_name": "cosmos.nft.v1beta1",
    "name": "Owner",
    "request_schema": {
      "$ref": "#/definitions/QueryOwnerRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryOwnerRequest": {
          "additionalProperties": false,
          "description": "QueryOwnerRequest is the request type for the Query/Owner RPC method",
          "properties": {
            "class_id": {
              "type": "string"
            },
            "id": {
              "type": "string"
            }
          },
          "title": "Query Owner Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/nft/v1beta1/owner/{class_id}/{id}",
    "service_name": "Query"
  },
  "cosmos.nft.v1beta1/QuerySupply": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "class_id"
        ]
      }
    ],
    "module_name": "cosmos.nft.v1beta1",
    "name": "Supply",
    "request_schema": {
      "$ref": "#/definitions/QuerySupplyRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QuerySupplyRequest": {
          "additionalProperties": false,
          "description": "QuerySupplyRequest is the request type for the Query/Supply RPC method",
          "properties": {
            "class_id": {
              "type": "string"
            }
          },
          "title": "Query Supply Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/nft/v1beta1/supply/{class_id}",
    "service_name": "Query"
  },
  "cosmos.nft.v1beta1/sendMsgSend": {
    "http_rules": null,
    "module_name": "cosmos.nft.v1beta1",
    "name": "Send",
    "request_schema": {
      "$ref": "#/definitions/MsgSend",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgSend": {
          "additionalProperties": false,
          "description": "MsgSend represents a message to send a nft from one account to another account.",
          "properties": {
            "class_id": {
              "description": "class_id defines the unique identifier of the nft classification, similar to the contract address of ERC721",
              "type": "string"
            },
            "id": {
              "description": "id defines the unique identification of nft",
              "type": "string"
            },
            "receiver": {
              "description": "receiver is the receiver address of nft",
              "type": "string"
            },
            "sender": {
              "description": "sender is the address of the owner of nft",
              "type": "string"
            }
          },
          "title": "Msg Send",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.params.v1beta1/QueryParams": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "cosmos.params.v1beta1",
    "name": "Params",
    "request_schema": {
      "$ref": "#/definitions/QueryParamsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryParamsRequest": {
          "additionalProperties": false,
          "description": "QueryParamsRequest is request type for the Query/Params RPC method.",
          "properties": {
            "key": {
              "description": "key defines the key of the parameter in the subspace.",
              "type": "string"
            },
            "subspace": {
              "description": "subspace defines the module to query the parameter for.",
              "type": "string"
            }
          },
          "title": "Query Params Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/params/v1beta1/params",
    "service_name": "Query"
  },
  "cosmos.params.v1beta1/QuerySubspaces": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "cosmos.params.v1beta1",
    "name": "Subspaces",
    "request_schema": {
      "$ref": "#/definitions/QuerySubspacesRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QuerySubspacesRequest": {
          "additionalProperties": false,
          "description": "QuerySubspacesRequest defines a request type for querying for all registered subspaces and all keys for a subspace. Since: cosmos-sdk 0.46",
          "title": "Query Subspaces Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/params/v1beta1/subspaces",
    "service_name": "Query"
  },
  "cosmos.slashing.v1beta1/QueryParams": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "cosmos.slashing.v1beta1",
    "name": "Params",
    "request_schema": {
      "$ref": "#/definitions/QueryParamsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryParamsRequest": {
          "additionalProperties": false,
          "description": "QueryParamsRequest is the request type for the Query/Params RPC method",
          "title": "Query Params Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/slashing/v1beta1/params",
    "service_name": "Query"
  },
  "cosmos.slashing.v1beta1/QuerySigningInfo": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "cons_address"
        ]
      }
    ],
    "module_name": "cosmos.slashing.v1beta1",
    "name": "SigningInfo",
    "request_schema": {
      "$ref": "#/definitions/QuerySigningInfoRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QuerySigningInfoRequest": {
          "additionalProperties": false,
          "description": "QuerySigningInfoRequest is the request type for the Query/SigningInfo RPC method",
          "properties": {
            "cons_address": {
              "description": "cons_address is the address to query signing info of",
              "type": "string"
            }
          },
          "title": "Query Signing Info Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/slashing/v1beta1/signing_infos/{cons_address}",
    "service_name": "Query"
  },
  "cosmos.slashing.v1beta1/QuerySigningInfos": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "cosmos.slashing.v1beta1",
    "name": "SigningInfos",
    "request_schema": {
      "$ref": "#/definitions/QuerySigningInfosRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QuerySigningInfosRequest": {
          "additionalProperties": false,
          "description": "QuerySigningInfosRequest is the request type for the Query/SigningInfos RPC method",
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false
            }
          },
          "title": "Query Signing Infos Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/slashing/v1beta1/signing_infos",
    "service_name": "Query"
  },
  "cosmos.slashing.v1beta1/sendMsgUnjail": {
    "http_rules": null,
    "module_name": "cosmos.slashing.v1beta1",
    "name": "Unjail",
    "request_schema": {
      "$ref": "#/definitions/MsgUnjail",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgUnjail": {
          "additionalProperties": false,
          "description": "MsgUnjail defines the Msg/Unjail request type",
          "properties": {
            "validator_addr": {
              "type": "string"
            }
          },
          "title": "Msg Unjail",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.staking.v1beta1/QueryDelegation": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "validator_addr",
          "delegator_addr"
        ]
      }
    ],
    "module_name": "cosmos.staking.v1beta1",
    "name": "Delegation",
    "request_schema": {
      "$ref": "#/definitions/QueryDelegationRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryDelegationRequest": {
          "additionalProperties": false,
          "description": "QueryDelegationRequest is request type for the Query/Delegation RPC method.",
          "properties": {
            "delegator_addr": {
              "description": "delegator_addr defines the delegator address to query for.",
              "type": "string"
            },
            "validator_addr": {
              "description": "validator_addr defines the validator address to query for.",
              "type": "string"
            }
          },
          "title": "Query Delegation Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}",
    "service_name": "Query"
  },
  "cosmos.staking.v1beta1/QueryDelegatorDelegations": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "delegator_addr"
        ]
      }
    ],
    "module_name": "cosmos.staking.v1beta1",
    "name": "DelegatorDelegations",
    "request_schema": {
      "$ref": "#/definitions/QueryDelegatorDelegationsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryDelegatorDelegationsRequest": {
          "additionalProperties": false,
          "description": "QueryDelegatorDelegationsRequest is request type for the Query/DelegatorDelegations RPC method.",
          "properties": {
            "delegator_addr": {
              "description": "delegator_addr defines the delegator address to query for.",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            }
          },
          "title": "Query Delegator Delegations Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/staking/v1beta1/delegations/{delegator_addr}",
    "service_name": "Query"
  },
  "cosmos.staking.v1beta1/QueryDelegatorUnbondingDelegations": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "delegator_addr"
        ]
      }
    ],
    "module_name": "cosmos.staking.v1beta1",
    "name": "DelegatorUnbondingDelegations",
    "request_schema": {
      "$ref": "#/definitions/QueryDelegatorUnbondingDelegationsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryDelegatorUnbondingDelegationsRequest": {
          "additionalProperties": false,
          "description": "QueryDelegatorUnbondingDelegationsRequest is request type for the Query/DelegatorUnbondingDelegations RPC method.",
          "properties": {
            "delegator_addr": {
              "description": "delegator_addr defines the delegator address to query for.",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            }
          },
          "title": "Query Delegator Unbonding Delegations Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations",
    "service_name": "Query"
  },
  "cosmos.staking.v1beta1/QueryDelegatorValidator": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "delegator_addr",
          "validator_addr"
        ]
      }
    ],
    "module_name": "cosmos.staking.v1beta1",
    "name": "DelegatorValidator",
    "request_schema": {
      "$ref": "#/definitions/QueryDelegatorValidatorRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryDelegatorValidatorRequest": {
          "additionalProperties": false,
          "description": "QueryDelegatorValidatorRequest is request type for the Query/DelegatorValidator RPC method.",
          "properties": {
            "delegator_addr": {
              "description": "delegator_addr defines the delegator address to query for.",
              "type": "string"
            },
            "validator_addr": {
              "description": "validator_addr defines the validator address to query for.",
              "type": "string"
            }
          },
          "title": "Query Delegator Validator Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators/{validator_addr}",
    "service_name": "Query"
  },
  "cosmos.staking.v1beta1/QueryDelegatorValidators": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "delegator_addr"
        ]
      }
    ],
    "module_name": "cosmos.staking.v1beta1",
    "name": "DelegatorValidators",
    "request_schema": {
      "$ref": "#/definitions/QueryDelegatorValidatorsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryDelegatorValidatorsRequest": {
          "additionalProperties": false,
          "description": "QueryDelegatorValidatorsRequest is request type for the Query/DelegatorValidators RPC method.",
          "properties": {
            "delegator_addr": {
              "description": "delegator_addr defines the delegator address to query for.",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            }
          },
          "title": "Query Delegator Validators Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators",
    "service_name": "Query"
  },
  "cosmos.staking.v1beta1/QueryHistoricalInfo": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "height"
        ]
      }
    ],
    "module_name": "cosmos.staking.v1beta1",
    "name": "HistoricalInfo",
    "request_schema": {
      "$ref": "#/definitions/QueryHistoricalInfoRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryHistoricalInfoRequest": {
          "additionalProperties": false,
          "description": "QueryHistoricalInfoRequest is request type for the Query/HistoricalInfo RPC method.",
          "properties": {
            "height": {
              "description": "height defines at which height to query the historical info.",
              "type": "string"
            }
          },
          "title": "Query Historical Info Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/staking/v1beta1/historical_info/{height}",
    "service_name": "Query"
  },
  "cosmos.staking.v1beta1/QueryParams": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "cosmos.staking.v1beta1",
    "name": "Params",
    "request_schema": {
      "$ref": "#/definitions/QueryParamsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryParamsRequest": {
          "additionalProperties": false,
          "description": "QueryParamsRequest is request type for the Query/Params RPC method.",
          "title": "Query Params Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/staking/v1beta1/params",
    "service_name": "Query"
  },
  "cosmos.staking.v1beta1/QueryPool": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "cosmos.staking.v1beta1",
    "name": "Pool",
    "request_schema": {
      "$ref": "#/definitions/QueryPoolRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryPoolRequest": {
          "additionalProperties": false,
          "description": "QueryPoolRequest is request type for the Query/Pool RPC method.",
          "title": "Query Pool Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/staking/v1beta1/pool",
    "service_name": "Query"
  },
  "cosmos.staking.v1beta1/QueryRedelegations": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "delegator_addr"
        ]
      }
    ],
    "module_name": "cosmos.staking.v1beta1",
    "name": "Redelegations",
    "request_schema": {
      "$ref": "#/definitions/QueryRedelegationsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryRedelegationsRequest": {
          "additionalProperties": false,
          "description": "QueryRedelegationsRequest is request type for the Query/Redelegations RPC method.",
          "properties": {
            "delegator_addr": {
              "description": "delegator_addr defines the delegator address to query for.",
              "type": "string"
            },
            "dst_validator_addr": {
              "description": "dst_validator_addr defines the validator address to redelegate to.",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            },
            "src_validator_addr": {
              "description": "src_validator_addr defines the validator address to redelegate from.",
              "type": "string"
            }
          },
          "title": "Query Redelegations Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/staking/v1beta1/delegators/{delegator_addr}/redelegations",
    "service_name": "Query"
  },
  "cosmos.staking.v1beta1/QueryUnbondingDelegation": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "validator_addr",
          "delegator_addr"
        ]
      }
    ],
    "module_name": "cosmos.staking.v1beta1",
    "name": "UnbondingDelegation",
    "request_schema": {
      "$ref": "#/definitions/QueryUnbondingDelegationRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryUnbondingDelegationRequest": {
          "additionalProperties": false,
          "description": "QueryUnbondingDelegationRequest is request type for the Query/UnbondingDelegation RPC method.",
          "properties": {
            "delegator_addr": {
              "description": "delegator_addr defines the delegator address to query for.",
              "type": "string"
            },
            "validator_addr": {
              "description": "validator_addr defines the validator address to query for.",
              "type": "string"
            }
          },
          "title": "Query Unbonding Delegation Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}/unbonding_delegation",
    "service_name": "Query"
  },
  "cosmos.staking.v1beta1/QueryValidator": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "validator_addr"
        ]
      }
    ],
    "module_name": "cosmos.staking.v1beta1",
    "name": "Validator",
    "request_schema": {
      "$ref": "#/definitions/QueryValidatorRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryValidatorRequest": {
          "additionalProperties": false,
          "description": "QueryValidatorRequest is response type for the Query/Validator RPC method",
          "properties": {
            "validator_addr": {
              "description": "validator_addr defines the validator address to query for.",
              "type": "string"
            }
          },
          "title": "Query Validator Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/staking/v1beta1/validators/{validator_addr}",
    "service_name": "Query"
  },
  "cosmos.staking.v1beta1/QueryValidatorDelegations": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "validator_addr"
        ]
      }
    ],
    "module_name": "cosmos.staking.v1beta1",
    "name": "ValidatorDelegations",
    "request_schema": {
      "$ref": "#/definitions/QueryValidatorDelegationsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryValidatorDelegationsRequest": {
          "additionalProperties": false,
          "description": "QueryValidatorDelegationsRequest is request type for the Query/ValidatorDelegations RPC method",
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            },
            "validator_addr": {
              "description": "validator_addr defines the validator address to query for.",
              "type": "string"
            }
          },
          "title": "Query Validator Delegations Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations",
    "service_name": "Query"
  },
  "cosmos.staking.v1beta1/QueryValidatorUnbondingDelegations": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "validator_addr"
        ]
      }
    ],
    "module_name": "cosmos.staking.v1beta1",
    "name": "ValidatorUnbondingDelegations",
    "request_schema": {
      "$ref": "#/definitions/QueryValidatorUnbondingDelegationsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryValidatorUnbondingDelegationsRequest": {
          "additionalProperties": false,
          "description": "QueryValidatorUnbondingDelegationsRequest is required type for the Query/ValidatorUnbondingDelegations RPC method",
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            },
            "validator_addr": {
              "description": "validator_addr defines the validator address to query for.",
              "type": "string"
            }
          },
          "title": "Query Validator Unbonding Delegations Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/staking/v1beta1/validators/{validator_addr}/unbonding_delegations",
    "service_name": "Query"
  },
  "cosmos.staking.v1beta1/QueryValidators": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "cosmos.staking.v1beta1",
    "name": "Validators",
    "request_schema": {
      "$ref": "#/definitions/QueryValidatorsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryValidatorsRequest": {
          "additionalProperties": false,
          "description": "QueryValidatorsRequest is request type for Query/Validators RPC method.",
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            },
            "status": {
              "description": "status enables to query for validators matching a given status.",
              "type": "string"
            }
          },
          "title": "Query Validators Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/staking/v1beta1/validators",
    "service_name": "Query"
  },
  "cosmos.staking.v1beta1/sendMsgBeginRedelegate": {
    "http_rules": null,
    "module_name": "cosmos.staking.v1beta1",
    "name": "BeginRedelegate",
    "request_schema": {
      "$ref": "#/definitions/MsgBeginRedelegate",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgBeginRedelegate": {
          "additionalProperties": false,
          "description": "MsgBeginRedelegate defines a SDK message for performing a redelegation of coins from a delegator and source validator to a destination validator.",
          "properties": {
            "amount": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false
            },
            "delegator_address": {
              "type": "string"
            },
            "validator_dst_address": {
              "type": "string"
            },
            "validator_src_address": {
              "type": "string"
            }
          },
          "title": "Msg Begin Redelegate",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.staking.v1beta1/sendMsgCancelUnbondingDelegation": {
    "http_rules": null,
    "module_name": "cosmos.staking.v1beta1",
    "name": "CancelUnbondingDelegation",
    "request_schema": {
      "$ref": "#/definitions/MsgCancelUnbondingDelegation",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgCancelUnbondingDelegation": {
          "additionalProperties": false,
          "description": "MsgCancelUnbondingDelegation defines the SDK message for performing a cancel unbonding delegation for delegator Since: cosmos-sdk 0.46",
          "properties": {
            "amount": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false,
              "description": "amount is always less than or equal to unbonding delegation entry balance"
            },
            "creation_height": {
              "description": "creation_height is the height which the unbonding took place.",
              "type": "string"
            },
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Cancel Unbonding Delegation",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.staking.v1beta1/sendMsgCreateValidator": {
    "http_rules": null,
    "module_name": "cosmos.staking.v1beta1",
    "name": "CreateValidator",
    "request_schema": {
      "$ref": "#/definitions/MsgCreateValidator",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgCreateValidator": {
          "additionalProperties": false,
          "description": "MsgCreateValidator defines a SDK message for creating a new validator.",
          "properties": {
            "commission": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.CommissionRates",
              "additionalProperties": false
            },
            "delegator_address": {
              "type": "string"
            },
            "description": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.Description",
              "additionalProperties": false
            },
            "min_self_delegation": {
              "type": "string"
            },
            "pubkey": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "properties": {
                    "json_value": {
                      "description": "Must be a valid json object of the above specified type.",
                      "format": "json",
                      "type": "string"
                    },
                    "type_url": {
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "type": "string"
                    }
                  },
                  "title": "JSON",
                  "type": "object"
                }
              ]
            },
            "validator_address": {
              "type": "string"
            },
            "value": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false
            }
          },
          "title": "Msg Create Validator",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        },
        "cosmos.staking.v1beta1.CommissionRates": {
          "additionalProperties": false,
          "description": "CommissionRates defines the initial commission rates to be used for creating a validator.",
          "properties": {
            "max_change_rate": {
              "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction.",
              "type": "string"
            },
            "max_rate": {
              "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction.",
              "type": "string"
            },
            "rate": {
              "description": "rate is the commission rate charged to delegators, as a fraction.",
              "type": "string"
            }
          },
          "title": "Commission Rates",
          "type": "object"
        },
        "cosmos.staking.v1beta1.Description": {
          "additionalProperties": false,
          "description": "Description defines a validator description.",
          "properties": {
            "details": {
              "description": "details define other optional details.",
              "type": "string"
            },
            "identity": {
              "description": "identity defines an optional identity signature (ex. UPort or Keybase).",
              "type": "string"
            },
            "moniker": {
              "description": "moniker defines a human-readable name for the validator.",
              "type": "string"
            },
            "security_contact": {
              "description": "security_contact defines an optional email for security contact.",
              "type": "string"
            },
            "website": {
              "description": "website defines an optional website link.",
              "type": "string"
            }
          },
          "title": "Description",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.staking.v1beta1/sendMsgDelegate": {
    "http_rules": null,
    "module_name": "cosmos.staking.v1beta1",
    "name": "Delegate",
    "request_schema": {
      "$ref": "#/definitions/MsgDelegate",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgDelegate": {
          "additionalProperties": false,
          "description": "MsgDelegate defines a SDK message for performing a delegation of coins from a delegator to a validator.",
          "properties": {
            "amount": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false
            },
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Delegate",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.staking.v1beta1/sendMsgEditValidator": {
    "http_rules": null,
    "module_name": "cosmos.staking.v1beta1",
    "name": "EditValidator",
    "request_schema": {
      "$ref": "#/definitions/MsgEditValidator",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgEditValidator": {
          "additionalProperties": false,
          "description": "MsgEditValidator defines a SDK message for editing an existing validator.",
          "properties": {
            "commission_rate": {
              "description": "We pass a reference to the new commission rate and min self delegation as it's not mandatory to update. If not updated, the deserialized rate will be zero with no way to distinguish if an update was intended. REF: #2373",
              "type": "string"
            },
            "description": {
              "$ref": "#/definitions/cosmos.staking.v1beta1.Description",
              "additionalProperties": false
            },
            "min_self_delegation": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Edit Validator",
          "type": "object"
        },
        "cosmos.staking.v1beta1.Description": {
          "additionalProperties": false,
          "description": "Description defines a validator description.",
          "properties": {
            "details": {
              "description": "details define other optional details.",
              "type": "string"
            },
            "identity": {
              "description": "identity defines an optional identity signature (ex. UPort or Keybase).",
              "type": "string"
            },
            "moniker": {
              "description": "moniker defines a human-readable name for the validator.",
              "type": "string"
            },
            "security_contact": {
              "description": "security_contact defines an optional email for security contact.",
              "type": "string"
            },
            "website": {
              "description": "website defines an optional website link.",
              "type": "string"
            }
          },
          "title": "Description",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.staking.v1beta1/sendMsgUndelegate": {
    "http_rules": null,
    "module_name": "cosmos.staking.v1beta1",
    "name": "Undelegate",
    "request_schema": {
      "$ref": "#/definitions/MsgUndelegate",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgUndelegate": {
          "additionalProperties": false,
          "description": "MsgUndelegate defines a SDK message for performing an undelegation from a delegate and a validator.",
          "properties": {
            "amount": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false
            },
            "delegator_address": {
              "type": "string"
            },
            "validator_address": {
              "type": "string"
            }
          },
          "title": "Msg Undelegate",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.upgrade.v1beta1/QueryAppliedPlan": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "name"
        ]
      }
    ],
    "module_name": "cosmos.upgrade.v1beta1",
    "name": "AppliedPlan",
    "request_schema": {
      "$ref": "#/definitions/QueryAppliedPlanRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryAppliedPlanRequest": {
          "additionalProperties": false,
          "description": "QueryCurrentPlanRequest is the request type for the Query/AppliedPlan RPC method.",
          "properties": {
            "name": {
              "description": "name is the name of the applied plan to query for.",
              "type": "string"
            }
          },
          "title": "Query Applied Plan Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/upgrade/v1beta1/applied_plan/{name}",
    "service_name": "Query"
  },
  "cosmos.upgrade.v1beta1/QueryAuthority": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "cosmos.upgrade.v1beta1",
    "name": "Authority",
    "request_schema": {
      "$ref": "#/definitions/QueryAuthorityRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryAuthorityRequest": {
          "additionalProperties": false,
          "description": "QueryAuthorityRequest is the request type for Query/Authority Since: cosmos-sdk 0.46",
          "title": "Query Authority Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/upgrade/v1beta1/authority",
    "service_name": "Query"
  },
  "cosmos.upgrade.v1beta1/QueryCurrentPlan": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "cosmos.upgrade.v1beta1",
    "name": "CurrentPlan",
    "request_schema": {
      "$ref": "#/definitions/QueryCurrentPlanRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryCurrentPlanRequest": {
          "additionalProperties": false,
          "description": "QueryCurrentPlanRequest is the request type for the Query/CurrentPlan RPC method.",
          "title": "Query Current Plan Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/upgrade/v1beta1/current_plan",
    "service_name": "Query"
  },
  "cosmos.upgrade.v1beta1/QueryModuleVersions": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "cosmos.upgrade.v1beta1",
    "name": "ModuleVersions",
    "request_schema": {
      "$ref": "#/definitions/QueryModuleVersionsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryModuleVersionsRequest": {
          "additionalProperties": false,
          "description": "QueryModuleVersionsRequest is the request type for the Query/ModuleVersions RPC method. Since: cosmos-sdk 0.43",
          "properties": {
            "module_name": {
              "description": "module_name is a field to query a specific module consensus version from state. Leaving this empty will fetch the full list of module versions from state",
              "type": "string"
            }
          },
          "title": "Query Module Versions Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/upgrade/v1beta1/module_versions",
    "service_name": "Query"
  },
  "cosmos.upgrade.v1beta1/QueryUpgradedConsensusState": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "last_height"
        ]
      }
    ],
    "module_name": "cosmos.upgrade.v1beta1",
    "name": "UpgradedConsensusState",
    "request_schema": {
      "$ref": "#/definitions/QueryUpgradedConsensusStateRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryUpgradedConsensusStateRequest": {
          "additionalProperties": false,
          "description": "QueryUpgradedConsensusStateRequest is the request type for the Query/UpgradedConsensusState RPC method.",
          "properties": {
            "last_height": {
              "description": "last height of the current chain must be sent in request as this is the height under which next consensus state is stored",
              "type": "string"
            }
          },
          "title": "Query Upgraded Consensus State Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/cosmos/upgrade/v1beta1/upgraded_consensus_state/{last_height}",
    "service_name": "Query"
  },
  "cosmos.upgrade.v1beta1/sendMsgCancelUpgrade": {
    "http_rules": null,
    "module_name": "cosmos.upgrade.v1beta1",
    "name": "CancelUpgrade",
    "request_schema": {
      "$ref": "#/definitions/MsgCancelUpgrade",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgCancelUpgrade": {
          "additionalProperties": false,
          "description": "MsgCancelUpgrade is the Msg/CancelUpgrade request type. Since: cosmos-sdk 0.46",
          "properties": {
            "authority": {
              "description": "authority is the address of the governance account.",
              "type": "string"
            }
          },
          "title": "Msg Cancel Upgrade",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.upgrade.v1beta1/sendMsgSoftwareUpgrade": {
    "http_rules": null,
    "module_name": "cosmos.upgrade.v1beta1",
    "name": "SoftwareUpgrade",
    "request_schema": {
      "$ref": "#/definitions/MsgSoftwareUpgrade",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgSoftwareUpgrade": {
          "additionalProperties": false,
          "description": "MsgSoftwareUpgrade is the Msg/SoftwareUpgrade request type. Since: cosmos-sdk 0.46",
          "properties": {
            "authority": {
              "description": "authority is the address of the governance account.",
              "type": "string"
            },
            "plan": {
              "$ref": "#/definitions/cosmos.upgrade.v1beta1.Plan",
              "additionalProperties": false,
              "description": "plan is the upgrade plan."
            }
          },
          "title": "Msg Software Upgrade",
          "type": "object"
        },
        "cosmos.upgrade.v1beta1.Plan": {
          "additionalProperties": false,
          "description": "Plan specifies information about a planned upgrade and when it should occur.",
          "properties": {
            "height": {
              "description": "The height at which the upgrade must be performed. Only used if Time is not set.",
              "type": "string"
            },
            "info": {
              "description": "Any application specific upgrade info to be included on-chain such as a git commit that validators could automatically upgrade to",
              "type": "string"
            },
            "name": {
              "description": "Sets the name for the upgrade. This name will be used by the upgraded version of the software to apply any special \"on-upgrade\" commands during the first BeginBlock method after the upgrade is applied. It is also used to detect whether a software version can handle a given upgrade. If no upgrade handler with this name has been set in the software, it will be assumed that the software is out-of-date when the upgrade Time or Height is reached and the software will exit.",
              "type": "string"
            },
            "time": {
              "description": "Deprecated: Time based upgrades have been deprecated. Time based upgrade logic has been removed from the SDK. If this field is not empty, an error will be thrown.",
              "format": "date-time",
              "type": "string"
            },
            "upgraded_client_state": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "description": "Deprecated: UpgradedClientState field has been deprecated. IBC upgrade logic has been moved to the IBC module in the sub module 02-client. If this field is not empty, an error will be thrown.",
                  "properties": {
                    "json_value": {
                      "description": "Must be a valid json object of the above specified type.",
                      "format": "json",
                      "type": "string"
                    },
                    "type_url": {
                      "description": "Registered fully-qualified proto name for a message type valid for this request",
                      "type": "string"
                    },
                    "value": {
                      "binaryEncoding": "base64",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "binary",
                      "type": "string"
                    }
                  },
                  "title": "JSON",
                  "type": "object"
                }
              ]
            }
          },
          "title": "Plan",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.vesting.v1beta1/sendMsgCreatePeriodicVestingAccount": {
    "http_rules": null,
    "module_name": "cosmos.vesting.v1beta1",
    "name": "CreatePeriodicVestingAccount",
    "request_schema": {
      "$ref": "#/definitions/MsgCreatePeriodicVestingAccount",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgCreatePeriodicVestingAccount": {
          "additionalProperties": false,
          "description": "MsgCreateVestingAccount defines a message that enables creating a vesting account. Since: cosmos-sdk 0.46",
          "properties": {
            "from_address": {
              "type": "string"
            },
            "start_time": {
              "type": "string"
            },
            "to_address": {
              "type": "string"
            },
            "vesting_periods": {
              "items": {
                "$ref": "#/definitions/cosmos.vesting.v1beta1.Period"
              },
              "type": "array"
            }
          },
          "title": "Msg Create Periodic Vesting Account",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        },
        "cosmos.vesting.v1beta1.Period": {
          "additionalProperties": false,
          "description": "Period defines a length of time and amount of coins that will vest.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "length": {
              "type": "string"
            }
          },
          "title": "Period",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.vesting.v1beta1/sendMsgCreatePermanentLockedAccount": {
    "http_rules": null,
    "module_name": "cosmos.vesting.v1beta1",
    "name": "CreatePermanentLockedAccount",
    "request_schema": {
      "$ref": "#/definitions/MsgCreatePermanentLockedAccount",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgCreatePermanentLockedAccount": {
          "additionalProperties": false,
          "description": "MsgCreatePermanentLockedAccount defines a message that enables creating a permanent locked account. Since: cosmos-sdk 0.46",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "from_address": {
              "type": "string"
            },
            "to_address": {
              "type": "string"
            }
          },
          "title": "Msg Create Permanent Locked Account",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "cosmos.vesting.v1beta1/sendMsgCreateVestingAccount": {
    "http_rules": null,
    "module_name": "cosmos.vesting.v1beta1",
    "name": "CreateVestingAccount",
    "request_schema": {
      "$ref": "#/definitions/MsgCreateVestingAccount",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgCreateVestingAccount": {
          "additionalProperties": false,
          "description": "MsgCreateVestingAccount defines a message that enables creating a vesting account.",
          "properties": {
            "amount": {
              "items": {
                "$ref": "#/definitions/cosmos.base.v1beta1.Coin"
              },
              "type": "array"
            },
            "delayed": {
              "type": "boolean"
            },
            "end_time": {
              "type": "string"
            },
            "from_address": {
              "type": "string"
            },
            "to_address": {
              "type": "string"
            }
          },
          "title": "Msg Create Vesting Account",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "dyson/QueryCron": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "dyson",
    "name": "Cron",
    "request_schema": {
      "$ref": "#/definitions/QueryGetCronRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryGetCronRequest": {
          "additionalProperties": false,
          "properties": {
            "blockHeight": {
              "type": "string"
            }
          },
          "title": "Query Get Cron Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/dyson/cron",
    "service_name": "Query"
  },
  "dyson/QueryCronAll": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "dyson",
    "name": "CronAll",
    "request_schema": {
      "$ref": "#/definitions/QueryAllCronRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryAllCronRequest": {
          "additionalProperties": false,
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false
            }
          },
          "title": "Query All Cron Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/dyson/cronAll",
    "service_name": "Query"
  },
  "dyson/QueryEncodeProtoAny": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "dyson",
    "name": "EncodeProtoAny",
    "request_schema": {
      "$ref": "#/definitions/QueryEncodeProtoAnyRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryEncodeProtoAnyRequest": {
          "additionalProperties": false,
          "properties": {
            "json_value": {
              "type": "string"
            },
            "type_url": {
              "type": "string"
            }
          },
          "title": "Query Encode Proto Any Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/org/dyson/dyson/encode_proto_any",
    "service_name": "Query"
  },
  "dyson/QueryPrefixStorage": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "dyson",
    "name": "PrefixStorage",
    "request_schema": {
      "$ref": "#/definitions/QueryPrefixStorageRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryPrefixStorageRequest": {
          "additionalProperties": false,
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false
            },
            "prefix": {
              "type": "string"
            }
          },
          "title": "Query Prefix Storage Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/dyson/storageprefix",
    "service_name": "Query"
  },
  "dyson/QueryQueryScript": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "dyson",
    "name": "QueryScript",
    "request_schema": {
      "$ref": "#/definitions/MsgRun",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgRun": {
          "additionalProperties": false,
          "description": "MsgRun runs a script at a specific address",
          "properties": {
            "address": {
              "description": "Dys address of the script to call",
              "type": "string"
            },
            "args": {
              "description": "Optional args to call the function with",
              "type": "string"
            },
            "coins": {
              "description": "Optional comma seperated list of coins to send the script (for example \"123dys,456token\") this entire amount will be sent to the script",
              "type": "string"
            },
            "creator": {
              "description": "The account sending this transaction",
              "type": "string"
            },
            "extra_lines": {
              "description": "Optional extra source code to append to the end of the script before running. Only available to the script address itself.",
              "format": "python",
              "type": "string"
            },
            "function_name": {
              "description": "Optional function to call",
              "type": "string"
            },
            "kwargs": {
              "description": "Optional kwargs to run",
              "type": "string"
            },
            "nfts": {
              "description": "Optional NFTs to send the script, formatted [class_id]/[id], [class_id]/[id] (for example \"example.dys/123, example.dys/456\")",
              "type": "string"
            }
          },
          "title": "Msg Run",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/dyson/query",
    "service_name": "Query"
  },
  "dyson/QueryScheduledGasPriceAndFeeAtBlock": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "dyson",
    "name": "ScheduledGasPriceAndFeeAtBlock",
    "request_schema": {
      "$ref": "#/definitions/QueryScheduledGasPriceAndFeeAtBlockRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryScheduledGasPriceAndFeeAtBlockRequest": {
          "additionalProperties": false,
          "properties": {
            "blockheight": {
              "type": "string"
            },
            "gaswanted": {
              "type": "string"
            }
          },
          "title": "Query Scheduled Gas Price And Fee At Block Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/dyson/scheduled_gas_price_at_block",
    "service_name": "Query"
  },
  "dyson/QueryScheduledRun": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "dyson",
    "name": "ScheduledRun",
    "request_schema": {
      "$ref": "#/definitions/QueryGetScheduledRunRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryGetScheduledRunRequest": {
          "additionalProperties": false,
          "properties": {
            "index": {
              "description": "index is the script address",
              "type": "string"
            }
          },
          "title": "Query Get Scheduled Run Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/dyson/scheduledRun",
    "service_name": "Query"
  },
  "dyson/QueryScheduledRunAll": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "dyson",
    "name": "ScheduledRunAll",
    "request_schema": {
      "$ref": "#/definitions/QueryAllScheduledRunRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryAllScheduledRunRequest": {
          "additionalProperties": false,
          "properties": {
            "index": {
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false
            }
          },
          "title": "Query All Scheduled Run Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/dyson/scheduledRunAll",
    "service_name": "Query"
  },
  "dyson/QuerySchema": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "dyson",
    "name": "Schema",
    "request_schema": {
      "$ref": "#/definitions/QueryGetSchemaRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryGetSchemaRequest": {
          "additionalProperties": false,
          "properties": {
            "index": {
              "type": "string"
            }
          },
          "title": "Query Get Schema Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/dyson/schema",
    "service_name": "Query"
  },
  "dyson/QueryScript": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "dyson",
    "name": "Script",
    "request_schema": {
      "$ref": "#/definitions/QueryGetScriptRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryGetScriptRequest": {
          "additionalProperties": false,
          "properties": {
            "index": {
              "type": "string"
            }
          },
          "title": "Query Get Script Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/dyson/script",
    "service_name": "Query"
  },
  "dyson/QueryScriptAll": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "dyson",
    "name": "ScriptAll",
    "request_schema": {
      "$ref": "#/definitions/QueryAllScriptRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryAllScriptRequest": {
          "additionalProperties": false,
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false
            }
          },
          "title": "Query All Script Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/dyson/scriptAll",
    "service_name": "Query"
  },
  "dyson/QueryStorage": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "dyson",
    "name": "Storage",
    "request_schema": {
      "$ref": "#/definitions/QueryGetStorageRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryGetStorageRequest": {
          "additionalProperties": false,
          "properties": {
            "index": {
              "type": "string"
            }
          },
          "title": "Query Get Storage Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/dyson/storage",
    "service_name": "Query"
  },
  "dyson/QueryStorageAll": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "dyson",
    "name": "StorageAll",
    "request_schema": {
      "$ref": "#/definitions/QueryAllStorageRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryAllStorageRequest": {
          "additionalProperties": false,
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false
            }
          },
          "title": "Query All Storage Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/dyson/storageAll",
    "service_name": "Query"
  },
  "dyson/QueryWsgi": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "dyson",
    "name": "Wsgi",
    "request_schema": {
      "$ref": "#/definitions/QueryWsgiRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryWsgiRequest": {
          "additionalProperties": false,
          "properties": {
            "gaslimit": {
              "description": "Gas to allow the WSGI request",
              "type": "string"
            },
            "httprequest": {
              "type": "string"
            },
            "index": {
              "type": "string"
            }
          },
          "title": "Query Wsgi Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/dyson/wsgi",
    "service_name": "Query"
  },
  "dyson/sendMsgCreateScheduledRun": {
    "http_rules": null,
    "module_name": "dyson",
    "name": "CreateScheduledRun",
    "request_schema": {
      "$ref": "#/definitions/MsgCreateScheduledRun",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgCreateScheduledRun": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            },
            "gas": {
              "type": "string"
            },
            "height": {
              "type": "string"
            },
            "msg": {
              "$ref": "#/definitions/dyson.MsgRun",
              "additionalProperties": false
            }
          },
          "title": "Msg Create Scheduled Run",
          "type": "object"
        },
        "dyson.MsgRun": {
          "additionalProperties": false,
          "description": "MsgRun runs a script at a specific address",
          "properties": {
            "address": {
              "description": "Dys address of the script to call",
              "type": "string"
            },
            "args": {
              "description": "Optional args to call the function with",
              "type": "string"
            },
            "coins": {
              "description": "Optional comma seperated list of coins to send the script (for example \"123dys,456token\") this entire amount will be sent to the script",
              "type": "string"
            },
            "creator": {
              "description": "The account sending this transaction",
              "type": "string"
            },
            "extra_lines": {
              "description": "Optional extra source code to append to the end of the script before running. Only available to the script address itself.",
              "type": "string"
            },
            "function_name": {
              "description": "Optional function to call",
              "type": "string"
            },
            "kwargs": {
              "description": "Optional kwargs to run",
              "type": "string"
            },
            "nfts": {
              "description": "Optional NFTs to send the script, formatted [class_id]/[id], [class_id]/[id] (for example \"example.dys/123, example.dys/456\")",
              "type": "string"
            }
          },
          "title": "Msg Run",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "dyson/sendMsgCreateStorage": {
    "http_rules": null,
    "module_name": "dyson",
    "name": "CreateStorage",
    "request_schema": {
      "$ref": "#/definitions/MsgCreateStorage",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgCreateStorage": {
          "additionalProperties": false,
          "description": "Create a new storage of arbitrary text",
          "properties": {
            "creator": {
              "description": "The address signing this transaction",
              "type": "string"
            },
            "data": {
              "description": "data to store at this index",
              "format": "json",
              "type": "string"
            },
            "force": {
              "description": "If true, force will always store the data at this address regardless of already existing storage",
              "type": "boolean"
            },
            "index": {
              "description": "Name of the Storage, must be prefixed with the creators address (for example: \"dys..1a3/some_name\")",
              "type": "string"
            }
          },
          "title": "Msg Create Storage",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "dyson/sendMsgDeleteScript": {
    "http_rules": null,
    "module_name": "dyson",
    "name": "DeleteScript",
    "request_schema": {
      "$ref": "#/definitions/MsgDeleteScript",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgDeleteScript": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            }
          },
          "title": "Msg Delete Script",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "dyson/sendMsgDeleteStorage": {
    "http_rules": null,
    "module_name": "dyson",
    "name": "DeleteStorage",
    "request_schema": {
      "$ref": "#/definitions/MsgDeleteStorage",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgDeleteStorage": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "type": "string"
            },
            "index": {
              "type": "string"
            }
          },
          "title": "Msg Delete Storage",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "dyson/sendMsgDeployAutonomousScript": {
    "http_rules": null,
    "module_name": "dyson",
    "name": "DeployAutonomousScript",
    "request_schema": {
      "$ref": "#/definitions/MsgDeployAutonomousScript",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgDeployAutonomousScript": {
          "additionalProperties": false,
          "description": "Deploy an Autonomous Script at a new address",
          "properties": {
            "code": {
              "format": "python",
              "type": "string"
            },
            "creator": {
              "type": "string"
            }
          },
          "title": "Msg Deploy Autonomous Script",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "dyson/sendMsgRun": {
    "http_rules": null,
    "module_name": "dyson",
    "name": "Run",
    "request_schema": {
      "$ref": "#/definitions/MsgRun",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgRun": {
          "additionalProperties": false,
          "description": "MsgRun runs a script at a specific address",
          "properties": {
            "address": {
              "description": "Dys address of the script to call",
              "type": "string"
            },
            "args": {
              "description": "Optional args to call the function with",
              "type": "string"
            },
            "coins": {
              "description": "Optional comma seperated list of coins to send the script (for example \"123dys,456token\") this entire amount will be sent to the script",
              "type": "string"
            },
            "creator": {
              "description": "The account sending this transaction",
              "type": "string"
            },
            "extra_lines": {
              "description": "Optional extra source code to append to the end of the script before running. Only available to the script address itself.",
              "format": "python",
              "type": "string"
            },
            "function_name": {
              "description": "Optional function to call",
              "type": "string"
            },
            "kwargs": {
              "description": "Optional kwargs to run",
              "type": "string"
            },
            "nfts": {
              "description": "Optional NFTs to send the script, formatted [class_id]/[id], [class_id]/[id] (for example \"example.dys/123, example.dys/456\")",
              "type": "string"
            }
          },
          "title": "Msg Run",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "dyson/sendMsgUpdateScript": {
    "http_rules": null,
    "module_name": "dyson",
    "name": "UpdateScript",
    "request_schema": {
      "$ref": "#/definitions/MsgUpdateScript",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgUpdateScript": {
          "additionalProperties": false,
          "properties": {
            "code": {
              "format": "python",
              "type": "string"
            },
            "creator": {
              "type": "string"
            }
          },
          "title": "Msg Update Script",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "dyson/sendMsgUpdateStorage": {
    "http_rules": null,
    "module_name": "dyson",
    "name": "UpdateStorage",
    "request_schema": {
      "$ref": "#/definitions/MsgUpdateStorage",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgUpdateStorage": {
          "additionalProperties": false,
          "properties": {
            "creator": {
              "description": "The address signing this transaction",
              "type": "string"
            },
            "data": {
              "description": "data to store at this index",
              "format": "json",
              "type": "string"
            },
            "force": {
              "description": "If true, force will always store the data at this address regardless of already existing storage",
              "type": "boolean"
            },
            "index": {
              "description": "Name of the Storage, must be prefixed with the creators address (for example: \"dys..1a3/some_name\")",
              "type": "string"
            }
          },
          "title": "Msg Update Storage",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "ibc.applications.interchain_accounts.controller.v1/QueryInterchainAccount": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "owner",
          "connection_id"
        ]
      }
    ],
    "module_name": "ibc.applications.interchain_accounts.controller.v1",
    "name": "InterchainAccount",
    "request_schema": {
      "$ref": "#/definitions/QueryInterchainAccountRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryInterchainAccountRequest": {
          "additionalProperties": false,
          "description": "QueryInterchainAccountRequest is the request type for the Query/InterchainAccount RPC method.",
          "properties": {
            "connection_id": {
              "type": "string"
            },
            "owner": {
              "type": "string"
            }
          },
          "title": "Query Interchain Account Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Query"
  },
  "ibc.applications.interchain_accounts.controller.v1/QueryParams": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "ibc.applications.interchain_accounts.controller.v1",
    "name": "Params",
    "request_schema": {
      "$ref": "#/definitions/QueryParamsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryParamsRequest": {
          "additionalProperties": false,
          "description": "QueryParamsRequest is the request type for the Query/Params RPC method.",
          "title": "Query Params Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Query"
  },
  "ibc.applications.interchain_accounts.controller.v1/sendMsgRegisterInterchainAccount": {
    "http_rules": null,
    "module_name": "ibc.applications.interchain_accounts.controller.v1",
    "name": "RegisterInterchainAccount",
    "request_schema": {
      "$ref": "#/definitions/MsgRegisterInterchainAccount",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgRegisterInterchainAccount": {
          "additionalProperties": false,
          "description": "MsgRegisterInterchainAccount defines the payload for Msg/MsgRegisterInterchainAccount",
          "properties": {
            "connection_id": {
              "type": "string"
            },
            "owner": {
              "type": "string"
            },
            "version": {
              "type": "string"
            }
          },
          "title": "Msg Register Interchain Account",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "ibc.applications.interchain_accounts.controller.v1/sendMsgSendTx": {
    "http_rules": null,
    "module_name": "ibc.applications.interchain_accounts.controller.v1",
    "name": "SendTx",
    "request_schema": {
      "$ref": "#/definitions/MsgSendTx",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgSendTx": {
          "additionalProperties": false,
          "description": "MsgSendTx defines the payload for Msg/SendTx",
          "properties": {
            "connection_id": {
              "type": "string"
            },
            "owner": {
              "type": "string"
            },
            "packet_data": {
              "$ref": "#/definitions/ibc.applications.interchain_accounts.v1.InterchainAccountPacketData",
              "additionalProperties": false
            },
            "relative_timeout": {
              "description": "Relative timeout timestamp provided will be added to the current block time during transaction execution. The timeout timestamp must be non-zero.",
              "type": "string"
            }
          },
          "title": "Msg Send Tx",
          "type": "object"
        },
        "ibc.applications.interchain_accounts.v1.InterchainAccountPacketData": {
          "additionalProperties": false,
          "description": "InterchainAccountPacketData is comprised of a raw transaction, type of transaction and optional memo field.",
          "properties": {
            "data": {
              "binaryEncoding": "base64",
              "format": "binary",
              "type": "string"
            },
            "memo": {
              "type": "string"
            },
            "type": {
              "description": "Type defines a classification of message issued from a controller chain to its associated interchain accounts host",
              "enum": [
                "TYPE_UNSPECIFIED",
                0,
                "TYPE_EXECUTE_TX",
                1
              ],
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "title": "Type"
            }
          },
          "title": "Interchain Account Packet Data",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "ibc.applications.interchain_accounts.host.v1/QueryParams": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "ibc.applications.interchain_accounts.host.v1",
    "name": "Params",
    "request_schema": {
      "$ref": "#/definitions/QueryParamsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryParamsRequest": {
          "additionalProperties": false,
          "description": "QueryParamsRequest is the request type for the Query/Params RPC method.",
          "title": "Query Params Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Query"
  },
  "ibc.applications.transfer.v1/QueryDenomHash": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "trace"
        ]
      }
    ],
    "module_name": "ibc.applications.transfer.v1",
    "name": "DenomHash",
    "request_schema": {
      "$ref": "#/definitions/QueryDenomHashRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryDenomHashRequest": {
          "additionalProperties": false,
          "description": "QueryDenomHashRequest is the request type for the Query/DenomHash RPC method",
          "properties": {
            "trace": {
              "description": "The denomination trace ([port_id]/[channel_id])+/[denom]",
              "type": "string"
            }
          },
          "title": "Query Denom Hash Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/apps/transfer/v1/denom_hashes/{trace}",
    "service_name": "Query"
  },
  "ibc.applications.transfer.v1/QueryDenomTrace": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "hash"
        ]
      }
    ],
    "module_name": "ibc.applications.transfer.v1",
    "name": "DenomTrace",
    "request_schema": {
      "$ref": "#/definitions/QueryDenomTraceRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryDenomTraceRequest": {
          "additionalProperties": false,
          "description": "QueryDenomTraceRequest is the request type for the Query/DenomTrace RPC method",
          "properties": {
            "hash": {
              "description": "hash (in hex format) or denom (full denom with ibc prefix) of the denomination trace information.",
              "type": "string"
            }
          },
          "title": "Query Denom Trace Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/apps/transfer/v1/denom_traces/{hash}",
    "service_name": "Query"
  },
  "ibc.applications.transfer.v1/QueryDenomTraces": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "ibc.applications.transfer.v1",
    "name": "DenomTraces",
    "request_schema": {
      "$ref": "#/definitions/QueryDenomTracesRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryDenomTracesRequest": {
          "additionalProperties": false,
          "description": "QueryConnectionsRequest is the request type for the Query/DenomTraces RPC method",
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination defines an optional pagination for the request."
            }
          },
          "title": "Query Denom Traces Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/apps/transfer/v1/denom_traces",
    "service_name": "Query"
  },
  "ibc.applications.transfer.v1/QueryEscrowAddress": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "channel_id",
          "port_id"
        ]
      }
    ],
    "module_name": "ibc.applications.transfer.v1",
    "name": "EscrowAddress",
    "request_schema": {
      "$ref": "#/definitions/QueryEscrowAddressRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryEscrowAddressRequest": {
          "additionalProperties": false,
          "description": "QueryEscrowAddressRequest is the request type for the EscrowAddress RPC method.",
          "properties": {
            "channel_id": {
              "description": "unique channel identifier",
              "type": "string"
            },
            "port_id": {
              "description": "unique port identifier",
              "type": "string"
            }
          },
          "title": "Query Escrow Address Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/apps/transfer/v1/channels/{channel_id}/ports/{port_id}/escrow_address",
    "service_name": "Query"
  },
  "ibc.applications.transfer.v1/QueryParams": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "ibc.applications.transfer.v1",
    "name": "Params",
    "request_schema": {
      "$ref": "#/definitions/QueryParamsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryParamsRequest": {
          "additionalProperties": false,
          "description": "QueryParamsRequest is the request type for the Query/Params RPC method.",
          "title": "Query Params Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/apps/transfer/v1/params",
    "service_name": "Query"
  },
  "ibc.applications.transfer.v1/sendMsgTransfer": {
    "http_rules": null,
    "module_name": "ibc.applications.transfer.v1",
    "name": "Transfer",
    "request_schema": {
      "$ref": "#/definitions/MsgTransfer",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgTransfer": {
          "additionalProperties": false,
          "description": "MsgTransfer defines a msg to transfer fungible tokens (i.e Coins) between ICS20 enabled chains. See ICS Spec here: https://github.com/cosmos/ibc/tree/master/spec/app/ics-020-fungible-token-transfer#data-structures",
          "properties": {
            "memo": {
              "description": "optional memo",
              "type": "string"
            },
            "receiver": {
              "description": "the recipient address on the destination chain",
              "type": "string"
            },
            "sender": {
              "description": "the sender address",
              "type": "string"
            },
            "source_channel": {
              "description": "the channel by which the packet will be sent",
              "type": "string"
            },
            "source_port": {
              "description": "the port on which the packet will be sent",
              "type": "string"
            },
            "timeout_height": {
              "$ref": "#/definitions/ibc.core.client.v1.Height",
              "additionalProperties": false,
              "description": "Timeout height relative to the current block height. The timeout is disabled when set to 0."
            },
            "timeout_timestamp": {
              "description": "Timeout timestamp in absolute nanoseconds since unix epoch. The timeout is disabled when set to 0.",
              "type": "string"
            },
            "token": {
              "$ref": "#/definitions/cosmos.base.v1beta1.Coin",
              "additionalProperties": false,
              "description": "the tokens to be transferred"
            }
          },
          "title": "Msg Transfer",
          "type": "object"
        },
        "cosmos.base.v1beta1.Coin": {
          "additionalProperties": false,
          "description": "Coin defines a token with a denomination and an amount. NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
          "properties": {
            "amount": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            }
          },
          "title": "Coin",
          "type": "object"
        },
        "ibc.core.client.v1.Height": {
          "additionalProperties": false,
          "description": "Height is a monotonically increasing data type that can be compared against another Height for the purposes of updating and freezing clients Normally the RevisionHeight is incremented at each height while keeping RevisionNumber the same. However some consensus algorithms may choose to reset the height in certain conditions e.g. hard forks, state-machine breaking changes In these cases, the RevisionNumber is incremented so that height continues to be monitonically increasing even as the RevisionHeight gets reset",
          "properties": {
            "revision_height": {
              "description": "the height within the given revision",
              "type": "string"
            },
            "revision_number": {
              "description": "the revision that the client is currently on",
              "type": "string"
            }
          },
          "title": "Height",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "ibc.core.channel.v1/QueryChannel": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "channel_id",
          "port_id"
        ]
      }
    ],
    "module_name": "ibc.core.channel.v1",
    "name": "Channel",
    "request_schema": {
      "$ref": "#/definitions/QueryChannelRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryChannelRequest": {
          "additionalProperties": false,
          "description": "QueryChannelRequest is the request type for the Query/Channel RPC method",
          "properties": {
            "channel_id": {
              "description": "channel unique identifier",
              "type": "string"
            },
            "port_id": {
              "description": "port unique identifier",
              "type": "string"
            }
          },
          "title": "Query Channel Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}",
    "service_name": "Query"
  },
  "ibc.core.channel.v1/QueryChannelClientState": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "channel_id",
          "port_id"
        ]
      }
    ],
    "module_name": "ibc.core.channel.v1",
    "name": "ChannelClientState",
    "request_schema": {
      "$ref": "#/definitions/QueryChannelClientStateRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryChannelClientStateRequest": {
          "additionalProperties": false,
          "description": "QueryChannelClientStateRequest is the request type for the Query/ClientState RPC method",
          "properties": {
            "channel_id": {
              "description": "channel unique identifier",
              "type": "string"
            },
            "port_id": {
              "description": "port unique identifier",
              "type": "string"
            }
          },
          "title": "Query Channel Client State Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/client_state",
    "service_name": "Query"
  },
  "ibc.core.channel.v1/QueryChannelConsensusState": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "channel_id",
          "port_id",
          "revision_number",
          "revision_height"
        ]
      }
    ],
    "module_name": "ibc.core.channel.v1",
    "name": "ChannelConsensusState",
    "request_schema": {
      "$ref": "#/definitions/QueryChannelConsensusStateRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryChannelConsensusStateRequest": {
          "additionalProperties": false,
          "description": "QueryChannelConsensusStateRequest is the request type for the Query/ConsensusState RPC method",
          "properties": {
            "channel_id": {
              "description": "channel unique identifier",
              "type": "string"
            },
            "port_id": {
              "description": "port unique identifier",
              "type": "string"
            },
            "revision_height": {
              "description": "revision height of the consensus state",
              "type": "string"
            },
            "revision_number": {
              "description": "revision number of the consensus state",
              "type": "string"
            }
          },
          "title": "Query Channel Consensus State Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_number}/height/{revision_height}",
    "service_name": "Query"
  },
  "ibc.core.channel.v1/QueryChannels": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "ibc.core.channel.v1",
    "name": "Channels",
    "request_schema": {
      "$ref": "#/definitions/QueryChannelsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryChannelsRequest": {
          "additionalProperties": false,
          "description": "QueryChannelsRequest is the request type for the Query/Channels RPC method",
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination request"
            }
          },
          "title": "Query Channels Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/channel/v1/channels",
    "service_name": "Query"
  },
  "ibc.core.channel.v1/QueryConnectionChannels": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "connection"
        ]
      }
    ],
    "module_name": "ibc.core.channel.v1",
    "name": "ConnectionChannels",
    "request_schema": {
      "$ref": "#/definitions/QueryConnectionChannelsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryConnectionChannelsRequest": {
          "additionalProperties": false,
          "description": "QueryConnectionChannelsRequest is the request type for the Query/QueryConnectionChannels RPC method",
          "properties": {
            "connection": {
              "description": "connection unique identifier",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination request"
            }
          },
          "title": "Query Connection Channels Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/channel/v1/connections/{connection}/channels",
    "service_name": "Query"
  },
  "ibc.core.channel.v1/QueryNextSequenceReceive": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "channel_id",
          "port_id"
        ]
      }
    ],
    "module_name": "ibc.core.channel.v1",
    "name": "NextSequenceReceive",
    "request_schema": {
      "$ref": "#/definitions/QueryNextSequenceReceiveRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryNextSequenceReceiveRequest": {
          "additionalProperties": false,
          "description": "QueryNextSequenceReceiveRequest is the request type for the Query/QueryNextSequenceReceiveRequest RPC method",
          "properties": {
            "channel_id": {
              "description": "channel unique identifier",
              "type": "string"
            },
            "port_id": {
              "description": "port unique identifier",
              "type": "string"
            }
          },
          "title": "Query Next Sequence Receive Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence",
    "service_name": "Query"
  },
  "ibc.core.channel.v1/QueryPacketAcknowledgement": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "channel_id",
          "port_id",
          "sequence"
        ]
      }
    ],
    "module_name": "ibc.core.channel.v1",
    "name": "PacketAcknowledgement",
    "request_schema": {
      "$ref": "#/definitions/QueryPacketAcknowledgementRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryPacketAcknowledgementRequest": {
          "additionalProperties": false,
          "description": "QueryPacketAcknowledgementRequest is the request type for the Query/PacketAcknowledgement RPC method",
          "properties": {
            "channel_id": {
              "description": "channel unique identifier",
              "type": "string"
            },
            "port_id": {
              "description": "port unique identifier",
              "type": "string"
            },
            "sequence": {
              "description": "packet sequence",
              "type": "string"
            }
          },
          "title": "Query Packet Acknowledgement Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}",
    "service_name": "Query"
  },
  "ibc.core.channel.v1/QueryPacketAcknowledgements": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "channel_id",
          "port_id"
        ]
      }
    ],
    "module_name": "ibc.core.channel.v1",
    "name": "PacketAcknowledgements",
    "request_schema": {
      "$ref": "#/definitions/QueryPacketAcknowledgementsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryPacketAcknowledgementsRequest": {
          "additionalProperties": false,
          "description": "QueryPacketAcknowledgementsRequest is the request type for the Query/QueryPacketCommitments RPC method",
          "properties": {
            "channel_id": {
              "description": "channel unique identifier",
              "type": "string"
            },
            "packet_commitment_sequences": {
              "description": "list of packet sequences",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination request"
            },
            "port_id": {
              "description": "port unique identifier",
              "type": "string"
            }
          },
          "title": "Query Packet Acknowledgements Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acknowledgements",
    "service_name": "Query"
  },
  "ibc.core.channel.v1/QueryPacketCommitment": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "channel_id",
          "port_id",
          "sequence"
        ]
      }
    ],
    "module_name": "ibc.core.channel.v1",
    "name": "PacketCommitment",
    "request_schema": {
      "$ref": "#/definitions/QueryPacketCommitmentRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryPacketCommitmentRequest": {
          "additionalProperties": false,
          "description": "QueryPacketCommitmentRequest is the request type for the Query/PacketCommitment RPC method",
          "properties": {
            "channel_id": {
              "description": "channel unique identifier",
              "type": "string"
            },
            "port_id": {
              "description": "port unique identifier",
              "type": "string"
            },
            "sequence": {
              "description": "packet sequence",
              "type": "string"
            }
          },
          "title": "Query Packet Commitment Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}",
    "service_name": "Query"
  },
  "ibc.core.channel.v1/QueryPacketCommitments": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "channel_id",
          "port_id"
        ]
      }
    ],
    "module_name": "ibc.core.channel.v1",
    "name": "PacketCommitments",
    "request_schema": {
      "$ref": "#/definitions/QueryPacketCommitmentsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryPacketCommitmentsRequest": {
          "additionalProperties": false,
          "description": "QueryPacketCommitmentsRequest is the request type for the Query/QueryPacketCommitments RPC method",
          "properties": {
            "channel_id": {
              "description": "channel unique identifier",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination request"
            },
            "port_id": {
              "description": "port unique identifier",
              "type": "string"
            }
          },
          "title": "Query Packet Commitments Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments",
    "service_name": "Query"
  },
  "ibc.core.channel.v1/QueryPacketReceipt": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "channel_id",
          "port_id",
          "sequence"
        ]
      }
    ],
    "module_name": "ibc.core.channel.v1",
    "name": "PacketReceipt",
    "request_schema": {
      "$ref": "#/definitions/QueryPacketReceiptRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryPacketReceiptRequest": {
          "additionalProperties": false,
          "description": "QueryPacketReceiptRequest is the request type for the Query/PacketReceipt RPC method",
          "properties": {
            "channel_id": {
              "description": "channel unique identifier",
              "type": "string"
            },
            "port_id": {
              "description": "port unique identifier",
              "type": "string"
            },
            "sequence": {
              "description": "packet sequence",
              "type": "string"
            }
          },
          "title": "Query Packet Receipt Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}",
    "service_name": "Query"
  },
  "ibc.core.channel.v1/QueryUnreceivedAcks": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "channel_id",
          "port_id",
          "packet_ack_sequences"
        ]
      }
    ],
    "module_name": "ibc.core.channel.v1",
    "name": "UnreceivedAcks",
    "request_schema": {
      "$ref": "#/definitions/QueryUnreceivedAcksRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryUnreceivedAcksRequest": {
          "additionalProperties": false,
          "description": "QueryUnreceivedAcks is the request type for the Query/UnreceivedAcks RPC method",
          "properties": {
            "channel_id": {
              "description": "channel unique identifier",
              "type": "string"
            },
            "packet_ack_sequences": {
              "description": "list of acknowledgement sequences",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "port_id": {
              "description": "port unique identifier",
              "type": "string"
            }
          },
          "title": "Query Unreceived Acks Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_ack_sequences}/unreceived_acks",
    "service_name": "Query"
  },
  "ibc.core.channel.v1/QueryUnreceivedPackets": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "channel_id",
          "port_id",
          "packet_commitment_sequences"
        ]
      }
    ],
    "module_name": "ibc.core.channel.v1",
    "name": "UnreceivedPackets",
    "request_schema": {
      "$ref": "#/definitions/QueryUnreceivedPacketsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryUnreceivedPacketsRequest": {
          "additionalProperties": false,
          "description": "QueryUnreceivedPacketsRequest is the request type for the Query/UnreceivedPackets RPC method",
          "properties": {
            "channel_id": {
              "description": "channel unique identifier",
              "type": "string"
            },
            "packet_commitment_sequences": {
              "description": "list of packet sequences",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "port_id": {
              "description": "port unique identifier",
              "type": "string"
            }
          },
          "title": "Query Unreceived Packets Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/unreceived_packets",
    "service_name": "Query"
  },
  "ibc.core.client.v1/QueryClientParams": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "ibc.core.client.v1",
    "name": "ClientParams",
    "request_schema": {
      "$ref": "#/definitions/QueryClientParamsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryClientParamsRequest": {
          "additionalProperties": false,
          "description": "QueryClientParamsRequest is the request type for the Query/ClientParams RPC method.",
          "title": "Query Client Params Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/client/v1/params",
    "service_name": "Query"
  },
  "ibc.core.client.v1/QueryClientState": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "client_id"
        ]
      }
    ],
    "module_name": "ibc.core.client.v1",
    "name": "ClientState",
    "request_schema": {
      "$ref": "#/definitions/QueryClientStateRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryClientStateRequest": {
          "additionalProperties": false,
          "description": "QueryClientStateRequest is the request type for the Query/ClientState RPC method",
          "properties": {
            "client_id": {
              "description": "client state unique identifier",
              "type": "string"
            }
          },
          "title": "Query Client State Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/client/v1/client_states/{client_id}",
    "service_name": "Query"
  },
  "ibc.core.client.v1/QueryClientStates": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "ibc.core.client.v1",
    "name": "ClientStates",
    "request_schema": {
      "$ref": "#/definitions/QueryClientStatesRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryClientStatesRequest": {
          "additionalProperties": false,
          "description": "QueryClientStatesRequest is the request type for the Query/ClientStates RPC method",
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination request"
            }
          },
          "title": "Query Client States Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/client/v1/client_states",
    "service_name": "Query"
  },
  "ibc.core.client.v1/QueryClientStatus": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "client_id"
        ]
      }
    ],
    "module_name": "ibc.core.client.v1",
    "name": "ClientStatus",
    "request_schema": {
      "$ref": "#/definitions/QueryClientStatusRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryClientStatusRequest": {
          "additionalProperties": false,
          "description": "QueryClientStatusRequest is the request type for the Query/ClientStatus RPC method",
          "properties": {
            "client_id": {
              "description": "client unique identifier",
              "type": "string"
            }
          },
          "title": "Query Client Status Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/client/v1/client_status/{client_id}",
    "service_name": "Query"
  },
  "ibc.core.client.v1/QueryConsensusState": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "client_id",
          "revision_number",
          "revision_height"
        ]
      }
    ],
    "module_name": "ibc.core.client.v1",
    "name": "ConsensusState",
    "request_schema": {
      "$ref": "#/definitions/QueryConsensusStateRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryConsensusStateRequest": {
          "additionalProperties": false,
          "description": "QueryConsensusStateRequest is the request type for the Query/ConsensusState RPC method. Besides the consensus state, it includes a proof and the height from which the proof was retrieved.",
          "properties": {
            "client_id": {
              "description": "client identifier",
              "type": "string"
            },
            "latest_height": {
              "description": "latest_height overrrides the height field and queries the latest stored ConsensusState",
              "type": "boolean"
            },
            "revision_height": {
              "description": "consensus state revision height",
              "type": "string"
            },
            "revision_number": {
              "description": "consensus state revision number",
              "type": "string"
            }
          },
          "title": "Query Consensus State Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/client/v1/consensus_states/{client_id}/revision/{revision_number}/height/{revision_height}",
    "service_name": "Query"
  },
  "ibc.core.client.v1/QueryConsensusStateHeights": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "client_id"
        ]
      }
    ],
    "module_name": "ibc.core.client.v1",
    "name": "ConsensusStateHeights",
    "request_schema": {
      "$ref": "#/definitions/QueryConsensusStateHeightsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryConsensusStateHeightsRequest": {
          "additionalProperties": false,
          "description": "QueryConsensusStateHeightsRequest is the request type for Query/ConsensusStateHeights RPC method.",
          "properties": {
            "client_id": {
              "description": "client identifier",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination request"
            }
          },
          "title": "Query Consensus State Heights Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/client/v1/consensus_states/{client_id}/heights",
    "service_name": "Query"
  },
  "ibc.core.client.v1/QueryConsensusStates": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": [
          "client_id"
        ]
      }
    ],
    "module_name": "ibc.core.client.v1",
    "name": "ConsensusStates",
    "request_schema": {
      "$ref": "#/definitions/QueryConsensusStatesRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryConsensusStatesRequest": {
          "additionalProperties": false,
          "description": "QueryConsensusStatesRequest is the request type for the Query/ConsensusStates RPC method.",
          "properties": {
            "client_id": {
              "description": "client identifier",
              "type": "string"
            },
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false,
              "description": "pagination request"
            }
          },
          "title": "Query Consensus States Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/client/v1/consensus_states/{client_id}",
    "service_name": "Query"
  },
  "ibc.core.client.v1/QueryUpgradedClientState": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "ibc.core.client.v1",
    "name": "UpgradedClientState",
    "request_schema": {
      "$ref": "#/definitions/QueryUpgradedClientStateRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryUpgradedClientStateRequest": {
          "additionalProperties": false,
          "description": "QueryUpgradedClientStateRequest is the request type for the Query/UpgradedClientState RPC method",
          "title": "Query Upgraded Client State Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/client/v1/upgraded_client_states",
    "service_name": "Query"
  },
  "ibc.core.client.v1/QueryUpgradedConsensusState": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "ibc.core.client.v1",
    "name": "UpgradedConsensusState",
    "request_schema": {
      "$ref": "#/definitions/QueryUpgradedConsensusStateRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryUpgradedConsensusStateRequest": {
          "additionalProperties": false,
          "description": "QueryUpgradedConsensusStateRequest is the request type for the Query/UpgradedConsensusState RPC method",
          "title": "Query Upgraded Consensus State Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/client/v1/upgraded_consensus_states",
    "service_name": "Query"
  },
  "ibc.core.connection.v1/QueryClientConnections": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "client_id"
        ]
      }
    ],
    "module_name": "ibc.core.connection.v1",
    "name": "ClientConnections",
    "request_schema": {
      "$ref": "#/definitions/QueryClientConnectionsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryClientConnectionsRequest": {
          "additionalProperties": false,
          "description": "QueryClientConnectionsRequest is the request type for the Query/ClientConnections RPC method",
          "properties": {
            "client_id": {
              "description": "client identifier associated with a connection",
              "type": "string"
            }
          },
          "title": "Query Client Connections Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/connection/v1/client_connections/{client_id}",
    "service_name": "Query"
  },
  "ibc.core.connection.v1/QueryConnection": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "connection_id"
        ]
      }
    ],
    "module_name": "ibc.core.connection.v1",
    "name": "Connection",
    "request_schema": {
      "$ref": "#/definitions/QueryConnectionRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryConnectionRequest": {
          "additionalProperties": false,
          "description": "QueryConnectionRequest is the request type for the Query/Connection RPC method",
          "properties": {
            "connection_id": {
              "description": "connection unique identifier",
              "type": "string"
            }
          },
          "title": "Query Connection Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/connection/v1/connections/{connection_id}",
    "service_name": "Query"
  },
  "ibc.core.connection.v1/QueryConnectionClientState": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "connection_id"
        ]
      }
    ],
    "module_name": "ibc.core.connection.v1",
    "name": "ConnectionClientState",
    "request_schema": {
      "$ref": "#/definitions/QueryConnectionClientStateRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryConnectionClientStateRequest": {
          "additionalProperties": false,
          "description": "QueryConnectionClientStateRequest is the request type for the Query/ConnectionClientState RPC method",
          "properties": {
            "connection_id": {
              "description": "connection identifier",
              "type": "string"
            }
          },
          "title": "Query Connection Client State Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/connection/v1/connections/{connection_id}/client_state",
    "service_name": "Query"
  },
  "ibc.core.connection.v1/QueryConnectionConsensusState": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "connection_id",
          "revision_number",
          "revision_height"
        ]
      }
    ],
    "module_name": "ibc.core.connection.v1",
    "name": "ConnectionConsensusState",
    "request_schema": {
      "$ref": "#/definitions/QueryConnectionConsensusStateRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryConnectionConsensusStateRequest": {
          "additionalProperties": false,
          "description": "QueryConnectionConsensusStateRequest is the request type for the Query/ConnectionConsensusState RPC method",
          "properties": {
            "connection_id": {
              "description": "connection identifier",
              "type": "string"
            },
            "revision_height": {
              "type": "string"
            },
            "revision_number": {
              "type": "string"
            }
          },
          "title": "Query Connection Consensus State Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/connection/v1/connections/{connection_id}/consensus_state/revision/{revision_number}/height/{revision_height}",
    "service_name": "Query"
  },
  "ibc.core.connection.v1/QueryConnectionParams": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "ibc.core.connection.v1",
    "name": "ConnectionParams",
    "request_schema": {
      "$ref": "#/definitions/QueryConnectionParamsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryConnectionParamsRequest": {
          "additionalProperties": false,
          "description": "QueryConnectionParamsRequest is the request type for the Query/ConnectionParams RPC method.",
          "title": "Query Connection Params Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/connection/v1/params",
    "service_name": "Query"
  },
  "ibc.core.connection.v1/QueryConnections": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "ibc.core.connection.v1",
    "name": "Connections",
    "request_schema": {
      "$ref": "#/definitions/QueryConnectionsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryConnectionsRequest": {
          "additionalProperties": false,
          "description": "QueryConnectionsRequest is the request type for the Query/Connections RPC method",
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false
            }
          },
          "title": "Query Connections Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/ibc/core/connection/v1/connections",
    "service_name": "Query"
  },
  "names/QueryExpirations": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": [
          "blockHeight"
        ]
      }
    ],
    "module_name": "names",
    "name": "Expirations",
    "request_schema": {
      "$ref": "#/definitions/QueryGetExpirationsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryGetExpirationsRequest": {
          "additionalProperties": false,
          "properties": {
            "blockHeight": {
              "type": "string"
            }
          },
          "title": "Query Get Expirations Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/org/dyson/names/expirations/{blockHeight}",
    "service_name": "Query"
  },
  "names/QueryExpirationsAll": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "names",
    "name": "ExpirationsAll",
    "request_schema": {
      "$ref": "#/definitions/QueryAllExpirationsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryAllExpirationsRequest": {
          "additionalProperties": false,
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false
            }
          },
          "title": "Query All Expirations Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/org/dyson/names/expirations",
    "service_name": "Query"
  },
  "names/QueryGenerateCommit": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "names",
    "name": "GenerateCommit",
    "request_schema": {
      "$ref": "#/definitions/QueryGenerateCommitRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryGenerateCommitRequest": {
          "additionalProperties": false,
          "properties": {
            "name": {
              "type": "string"
            },
            "owner": {
              "type": "string"
            },
            "salt": {
              "type": "string"
            }
          },
          "title": "Query Generate Commit Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/org/dyson/names/generate_commit",
    "service_name": "Query"
  },
  "names/QueryName": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "names",
    "name": "Name",
    "request_schema": {
      "$ref": "#/definitions/QueryGetNameRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryGetNameRequest": {
          "additionalProperties": false,
          "properties": {
            "name": {
              "type": "string"
            }
          },
          "title": "Query Get Name Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/org/dyson/names/name",
    "service_name": "Query"
  },
  "names/QueryNameAll": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "names",
    "name": "NameAll",
    "request_schema": {
      "$ref": "#/definitions/QueryAllNameRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryAllNameRequest": {
          "additionalProperties": false,
          "properties": {
            "pagination": {
              "$ref": "#/definitions/cosmos.base.query.v1beta1.PageRequest",
              "additionalProperties": false
            }
          },
          "title": "Query All Name Request",
          "type": "object"
        },
        "cosmos.base.query.v1beta1.PageRequest": {
          "additionalProperties": false,
          "description": "PageRequest is to be embedded in gRPC request messages for efficient pagination. Ex:  message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }",
          "options": {
            "required_by_default": false,
            "show_opt_in": true
          },
          "properties": {
            "count_total": {
              "description": "count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.",
              "type": "boolean"
            },
            "key": {
              "binaryEncoding": "base64",
              "description": "key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.",
              "format": "binary",
              "type": "string"
            },
            "limit": {
              "description": "limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.",
              "type": "string"
            },
            "offset": {
              "description": "offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.",
              "type": "string"
            },
            "reverse": {
              "description": "reverse is set to true if results are to be returned in the descending order. Since: cosmos-sdk 0.43",
              "type": "boolean"
            }
          },
          "required": [],
          "title": "Page Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/org/dyson/names/nameall",
    "service_name": "Query"
  },
  "names/QueryParams": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": false,
        "Params": null
      }
    ],
    "module_name": "names",
    "name": "Params",
    "request_schema": {
      "$ref": "#/definitions/QueryParamsRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryParamsRequest": {
          "additionalProperties": false,
          "description": "QueryParamsRequest is request type for the Query/Params RPC method.",
          "title": "Query Params Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/org/dyson/names/params",
    "service_name": "Query"
  },
  "names/QueryResolve": {
    "http_rules": [
      {
        "HasBody": false,
        "HasQuery": true,
        "Params": null
      }
    ],
    "module_name": "names",
    "name": "Resolve",
    "request_schema": {
      "$ref": "#/definitions/QueryResolveRequest",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "QueryResolveRequest": {
          "additionalProperties": false,
          "properties": {
            "name": {
              "type": "string"
            }
          },
          "title": "Query Resolve Request",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": "/org/dyson/names/resolve",
    "service_name": "Query"
  },
  "names/sendMsgAccept": {
    "http_rules": null,
    "module_name": "names",
    "name": "Accept",
    "request_schema": {
      "$ref": "#/definitions/MsgAccept",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgAccept": {
          "additionalProperties": false,
          "description": "Accept the name that was offered to you",
          "properties": {
            "name": {
              "description": "The name to accept",
              "type": "string"
            },
            "new_owner": {
              "description": "The owner address of the name",
              "type": "string"
            }
          },
          "title": "Msg Accept",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "names/sendMsgBurnCoins": {
    "http_rules": null,
    "module_name": "names",
    "name": "BurnCoins",
    "request_schema": {
      "$ref": "#/definitions/MsgBurnCoins",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgBurnCoins": {
          "additionalProperties": false,
          "properties": {
            "amount": {
              "description": "The amount of coins to burn, the owner must have enough coins to burn",
              "type": "string"
            },
            "owner": {
              "description": "The owner of the Dys name",
              "type": "string"
            }
          },
          "title": "Msg Burn Coins",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "names/sendMsgBurnNft": {
    "http_rules": null,
    "module_name": "names",
    "name": "BurnNft",
    "request_schema": {
      "$ref": "#/definitions/MsgBurnNft",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgBurnNft": {
          "additionalProperties": false,
          "description": "Burn an NFT of the given class ID and NFT ID.",
          "properties": {
            "class_id": {
              "description": "the NFT Class ID",
              "type": "string"
            },
            "class_owner": {
              "description": "The owner of the NFT Class",
              "type": "string"
            },
            "id": {
              "description": "The ID of this NFT to burn. The owner must currently own this NFT to burn it.",
              "type": "string"
            }
          },
          "title": "Msg Burn Nft",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "names/sendMsgBuy": {
    "http_rules": null,
    "module_name": "names",
    "name": "Buy",
    "request_schema": {
      "$ref": "#/definitions/MsgBuy",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgBuy": {
          "additionalProperties": false,
          "description": "All names have a listed price, this message allows you to buy the name at the listed price.",
          "properties": {
            "buyer": {
              "description": "The address of the buyer",
              "type": "string"
            },
            "name": {
              "description": "The name to buy",
              "type": "string"
            },
            "price": {
              "description": "Confirm the  price of the name is the same as the listed price.",
              "type": "string"
            }
          },
          "title": "Msg Buy",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "names/sendMsgDeleteName": {
    "http_rules": null,
    "module_name": "names",
    "name": "DeleteName",
    "request_schema": {
      "$ref": "#/definitions/MsgDeleteName",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgDeleteName": {
          "additionalProperties": false,
          "description": "Delete the Dyson Protocol name",
          "properties": {
            "name": {
              "description": "The name to delete",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            }
          },
          "title": "Msg Delete Name",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "names/sendMsgMintCoins": {
    "http_rules": null,
    "module_name": "names",
    "name": "MintCoins",
    "request_schema": {
      "$ref": "#/definitions/MsgMintCoins",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgMintCoins": {
          "additionalProperties": false,
          "description": "Mint coins with a denom of a name or subname. For example if you own the name \"example.dys\" you can mint coins with the denom \"example.dys\" or \"subname.example.dys\"",
          "properties": {
            "amount": {
              "description": "The amount of coins to mint in the format \"[amount] [denom]\".   Each coin costs 1 gas.",
              "type": "string"
            },
            "owner": {
              "description": "The owner of the Dys name",
              "type": "string"
            }
          },
          "title": "Msg Mint Coins",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "names/sendMsgMintNft": {
    "http_rules": null,
    "module_name": "names",
    "name": "MintNft",
    "request_schema": {
      "$ref": "#/definitions/MsgMintNft",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgMintNft": {
          "additionalProperties": false,
          "description": "Mint an NFT with the given class ID and NFT ID. The NFT ID is unique to the class ID.",
          "properties": {
            "class_id": {
              "description": "the NFT Class ID",
              "type": "string"
            },
            "class_owner": {
              "description": "The owner of the Dys name",
              "type": "string"
            },
            "id": {
              "description": "The ID of this NFT, must be unique to the class ID",
              "type": "string"
            },
            "uri": {
              "description": "The URI of the NFT (optional)",
              "type": "string"
            },
            "uri_hash": {
              "description": "The URI hash of the NFT (optional)",
              "type": "string"
            }
          },
          "title": "Msg Mint Nft",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "names/sendMsgOfferTo": {
    "http_rules": null,
    "module_name": "names",
    "name": "OfferTo",
    "request_schema": {
      "$ref": "#/definitions/MsgOfferTo",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgOfferTo": {
          "additionalProperties": false,
          "description": "Offer the name to a new owner",
          "properties": {
            "name": {
              "description": "The name to offer",
              "type": "string"
            },
            "new_owner": {
              "description": "The address to offer the name to. They can take ownership of the name with the Accept message",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            }
          },
          "title": "Msg Offer To",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "names/sendMsgRegister": {
    "http_rules": null,
    "module_name": "names",
    "name": "Register",
    "request_schema": {
      "$ref": "#/definitions/MsgRegister",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgRegister": {
          "additionalProperties": false,
          "properties": {
            "auto_renew": {
              "description": "Should the name be automatically renewed",
              "type": "boolean"
            },
            "commit": {
              "description": "The Shake256(owner+name+salt) hexdigest",
              "type": "string"
            },
            "owner": {
              "description": "Address of the owner",
              "type": "string"
            },
            "price": {
              "description": "The price that this name is valued at and can be purchased for example 100dys. The yearly fee (31,536,000 blocks) is 1% of this price.",
              "type": "string"
            }
          },
          "title": "Msg Register",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "names/sendMsgReveal": {
    "http_rules": null,
    "module_name": "names",
    "name": "Reveal",
    "request_schema": {
      "$ref": "#/definitions/MsgReveal",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgReveal": {
          "additionalProperties": false,
          "description": "Reveal the name that was committed to with the Register message",
          "properties": {
            "name": {
              "description": "The name to reveal",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            },
            "salt": {
              "description": "The salt that was used to commit to the name",
              "type": "string"
            }
          },
          "title": "Msg Reveal",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "names/sendMsgSetNftClass": {
    "http_rules": null,
    "module_name": "names",
    "name": "SetNftClass",
    "request_schema": {
      "$ref": "#/definitions/MsgSetNftClass",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgSetNftClass": {
          "additionalProperties": false,
          "description": "Create or update an NFT class. The NFT class is identified by the Dys name of the class ID.",
          "properties": {
            "description": {
              "description": "The  description of the NFT class (optional)",
              "type": "string"
            },
            "id": {
              "description": "the ID is the Dys name or subname of the NFT class. For example if you own the name \"example.dys\" you can create an NFT class with the ID \"example.dys\" or \"subname.example.dys\"",
              "type": "string"
            },
            "name": {
              "description": "More descriptive name of the NFT class (optional)",
              "type": "string"
            },
            "owner": {
              "description": "The owner of the Dys name of the NFT class ID",
              "type": "string"
            },
            "symbol": {
              "description": "The symbol of the NFT class (optional)",
              "type": "string"
            },
            "uri": {
              "description": "The URI of the NFT class (optional)",
              "type": "string"
            },
            "uri_hash": {
              "description": "The URI hash of the NFT class (optional)",
              "type": "string"
            }
          },
          "title": "Msg Set Nft Class",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "names/sendMsgSetPriceAndExtend": {
    "http_rules": null,
    "module_name": "names",
    "name": "SetPriceAndExtend",
    "request_schema": {
      "$ref": "#/definitions/MsgSetPriceAndExtend",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgSetPriceAndExtend": {
          "additionalProperties": false,
          "description": "Set the price of the name and extend the expiration height",
          "properties": {
            "name": {
              "description": "The name to set the price for",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            },
            "price": {
              "description": "The new price that this name is valued at and can be purchased for example 100dys. The fee is 1% of this price and will be paid by the owner now. The expiration height is extended by 31,536,000 blocks.",
              "type": "string"
            }
          },
          "title": "Msg Set Price And Extend",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "names/sendMsgUpdateName": {
    "http_rules": null,
    "module_name": "names",
    "name": "UpdateName",
    "request_schema": {
      "$ref": "#/definitions/MsgUpdateName",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgUpdateName": {
          "additionalProperties": false,
          "description": "Update the details of the Dyson Protocol name",
          "properties": {
            "authorized": {
              "description": "The address that this name is OfferedTo, they can take ownership of the name with the Accept message",
              "type": "string"
            },
            "auto_renew": {
              "description": "Will the name be automatically renewed at the expiration height. The expiration height is extended by 31,536,000 blocks (about 1 year). The fee is 1% of the price and is paid by the owner at the time of the renewal.",
              "type": "boolean"
            },
            "destination": {
              "description": "The new destination address for the name",
              "type": "string"
            },
            "name": {
              "description": "The name to update",
              "type": "string"
            },
            "owner": {
              "description": "The owner address of the name",
              "type": "string"
            }
          },
          "title": "Msg Update Name",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  },
  "names/sendMsgUpdateNft": {
    "http_rules": null,
    "module_name": "names",
    "name": "UpdateNft",
    "request_schema": {
      "$ref": "#/definitions/MsgUpdateNft",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "definitions": {
        "MsgUpdateNft": {
          "additionalProperties": false,
          "description": "Update the details of an NFT",
          "properties": {
            "class_id": {
              "description": "the NFT Class ID",
              "type": "string"
            },
            "class_owner": {
              "description": "The owner of the NFT Class",
              "type": "string"
            },
            "id": {
              "description": "The ID of this NFT to update",
              "type": "string"
            },
            "uri": {
              "description": "The URI of the NFT (optional)",
              "type": "string"
            },
            "uri_hash": {
              "description": "The URI hash of the NFT (optional)",
              "type": "string"
            }
          },
          "title": "Msg Update Nft",
          "type": "object"
        }
      }
    },
    "resp_schema": {
      "format": "json",
      "title": "Response",
      "type": "string"
    },
    "rest_path": null,
    "service_name": "Msg"
  }
}